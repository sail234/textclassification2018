微型机 与 应用 MICROCOMPUTERITSAPPLICATIONSVolNoPLINUX 字符 设备 管理 设计 方法 的 研究 叶绿 摘要 ： 对 比较 典型 的 鼠标 和 行式打印机 的 设备 驱动程序 进行 了 研究 ， 用来 说明 和 分析 LINUX 系统 字符 设备 的 管理 。 关键词 ： LINUX 字符 设备 设备 管理 　 　 同 其它 UNIX 系统 类似 ， LINUX 系统 包含 类 基本 设备 块 设备 和 字符 设备 。 所谓 字符 设备 ， 即 操作 的 基本 单位 是 个个 的 字符 ， 并且 操作 顺序 固定 ， 不能 进行 随机 操作 。 字符 设备 驱动程序 可以 自己 带有 小型 缓冲区 ， 例如 行打 。 字符 设备 的 文件系统 接口 如 open 、 write 等 与 块 设备 管理 不同 ， 它 是 直接 与 设备 驱动程序 连在一起 的 ， 这样 大大简化 了 管理 过程 。 本文 将 通过 分析 种 比较 典型 的 字符 设备 ： 鼠标 mouse 和 行式打印机 lineprinter ， 来 说明 字符 设备 的 管理 。 LINUX 系统 设备 驱动程序 的 主要 结构 有 大块 ， 分别 为 初始化 过程 ＿ init 、 组 文件 操作 接口 structfile ＿ operations 的 定义 、 中断 处理过程 或者 是 Polling 过程 ， 视 具体情况 而定 。 鼠标 设备 的 管理 　 　 鼠标 是 一种 常见 的 典型 字符 设备 ， 在 LINUX 系统 中 的 主 设备 号 为 。 实际上 ， 设备 文件 ／ dev ／ mouse 所 对应 的 是 个 逻辑 鼠标 ， 系统 会 自动 地 找到 真正 的 鼠标 ， 并 对 其 进行 操作 。 系统 每 一种 鼠标 的 驱动程序 只 支持 个 鼠标 ， 而 整个 系统 在 一段时间 仅 支持 个 鼠标 。 在 LINUX （ version ． ． ） 中 支持 的 鼠标 种类 如下 所示 ： 　 　 ＃ defineBUSMOUSE ＿ MINOR ／ ／ Logitechbusmouse 　 　 ＃ definePSMOUSE ＿ MINOR ／ ／ PS ／ mouse 　 　 ＃ defineMS ＿ BUSMOUSE ＿ MINOR ／ ／ Microsoftbus 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ／ ／ mouse 　 　 ＃ defineATIXL ＿ BUSMOUSE ＿ MINOR ／ ／ Atixlboard 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ／ ／ busmouse … ． 逻辑 鼠标 　 　 在 mouse 的 设备 驱动程序 ／ drivers ／ char ／ mouse ． c 中 只 出现 了 个 函数 ： 个 是 mouse ＿ open 作为 这个 逻辑 鼠标 唯一 的 文件 操作 接口 ； 另个 是 mouse ＿ init ， 作为 鼠标 的 初始 过程 出现 在 函数 chr ＿ dev ＿ init 中 。 mouse ＿ open 根据 参数 次 设备 号 判断 要 打开 哪 一类 鼠标 ， 然后 简单 地 把 指定 的 鼠标 文件 操作 接口 填入 该 逻辑设备 的 文件 结构 file － ＞ op ； 最后 当然 还 得 重新 调用 实际 鼠标 的 文件 操作 。 若 确切 地 知道 实际 的 鼠标 文件 是 哪个 例如 是 msbusmouse ， 那么 对 mouse 进行 操作 和 对 msbusmouse 进行 操作 的 效果 是 一致 的 。 函数 mouse ＿ init 分别 初始化 系统配置 好 的 各种 鼠标 设备 ， 这 是 在 编译 的 时候 确定 的 。 ． msbusmouse 的 驱动 　 　 ． 数据结构 设备 驱动程序 不可避免 地要 涉及 硬件 底层 ， 因此 应该 简单 了解 一些 底层 硬件 数据 。 　 　 ＃ defineMOUSE ＿ IRQ ／ ／ 中断向量 　 　 ＃ defineMS ＿ MSE ＿ DATA ＿ PORTxd ／ ／ I ／ O 数据 端口 　 　 ＃ defineMS ＿ MSE ＿ SIGNATURE ＿ PORTxe ／ ／ 信号 端口 　 　 ＃ defineMS ＿ MSE ＿ CONTROL ＿ PORTxc ／ ／ 控制 端口 　 　 ＃ defineMS ＿ MSE ＿ CONFIG ＿ PORTxf 　 　 　 　 　 　 　 　 　 　 　 　 　 ／ ／ 配置 端口 ， seemsuseless 　 　 对 这些 I ／ O 端口 进行 操作 的 过程 是 inb 和 outb 。 所有 鼠标 中断 号 都 是 ， 这 就 使 系统 一般 只能 支持 台 鼠标 设备 。 鼠标 驱动程序 中有 一块 静态数据 区 用来 保存 当前 鼠标 事件 信息 ， 其 结构 定义 于 文件 ／ include ／ linux ／ busmouse ． h ， 如下 所示 ： 　 　 structmouse ＿ status ｛ ／ ／ 当前 鼠标 状态 　 　 unsignedcharbuttons ； ／ ／ 鼠标 按钮 状态 　 　 　 unsignedcharlatch ＿ buttons ； 　 　 　 intdx ； ／ ／ 当前 坐标 　 　 　 intdy ； 　 　 　 intpresent ； ／ ／ 鼠标 存在 状态 　 　 　 intready ； ／ ／ 数据 是否 有效 　 　 　 intactive ； ／ ／ meansbusystructwait ＿ queuewait ； ／ ／ 关于 鼠标 的 等待 队列 　 ｝ ； 　 staticstructmouse ＿ statusmouse ； 　 　 ． 鼠标 设备 工作 原理 　 　 　 首先 介绍 鼠标 是 如何 初始化 的 。 过程 mouse ＿ init 调用 了 这种 Microsoftbus 鼠标 的 初始化 过程 ： unsignedlongms ＿ bus ＿ mouse ＿ init （ unsignedlongkmem ＿ start ） 。 它 开始 初始化 鼠标 状态 mouse 中 的 域 ， 清 ； 然后 检测 当前 的 鼠标 安装 状态 ， 通过 若干次 从 信号 端口 MS ＿ MSE ＿ SIGNATURE ＿ PORT 读数据 ， 观察 状态 是否 稳定 ， 从而 判断 鼠标 是否 安装 。 最后 程序 禁止 鼠标 的 中断 。 从 这里 可以 看到 ， 鼠标 设备 的 检测 由 驱动程序 完成 ， 如果 在 系统启动 的 时候 鼠标 没有 安装 ， 那么 即使 在 运行 过程 中 再 安装 也 无济于事 。 系统 仍然 不会 承认 ， 若 要 满足要求 可 对 驱动程序 稍 做 改动 。 　 　 下面 分析 这个 鼠标 的 文件 操作 接口 。 驱动程序 并非 要 实现 所有 的 文件 接口 ， 具体 设备 有 各自 的 工作 特点 ， 如 鼠标 主要 读入 数据流 。 　 　 structfile ＿ operationsms ＿ bus ＿ mouse ＿ fops ＝ ｛ 　 　 　 　 NULL ， ／ mouse ＿ seek ， 字符 设备 是 顺序 文件 ／ 　 　 　 　 　 read ＿ mouse ， ／ ／ readbutton ， xandycoordinates ． 　 　 　 　 　 write ＿ mouse ， ／ ／ 事实上 ， 调用 本 函数 将 返回 错误信息 　 　 　 　 　 NULL ， ／ mouse ＿ readdir ／ 　 　 　 　 　 mouse ＿ select ， ／ mouse ＿ select ／ 　 　 　 　 　 NULL ， ／ mouse ＿ ioct 　 　 　 　 NULL ， ／ mouse ＿ mmap ／ 　 　 　 　 　 open ＿ mouse ， 　 　 　 　 　 release ＿ mouse ， 　 　 　 ； 　 　 　 （ ） staticintopen ＿ mousestructinodeinode ， structfilefile ） 　 　 函数 首先 判断 鼠标 是否 存在 或者 是否 有 其它 应用 正在 使用 ， 如果 没有 ， 就 标识 占用 鼠标 ， 同时 清 数据 区 。 然后 程序 向 系统 申请号 中断向量 reuqest ＿ irq ， 登记 自己 的 中断 处理程序 ms ＿ mouse ＿ interruput 。 如果 已经 有 其它 鼠标 申请 了 这个 中断 ， 就 失败 。 最后 是 往 控制 端口 发 命令 启动 鼠标 设备 并开 中断 。 　 　 （ ） staticvoidrelease ＿ mousestructinodeinode ， structfilefile 　 　 相对 来讲 释放 过程 要 简单 得 多 ， 它 仅仅 关 鼠标 中断 ， 设置 设备 空闲 标志 并 释放 中断向量 。 　 　 （ ） staticintread ＿ mouse （ structinodeinode ， structfilefile ， charbuffer ， intcount ） 这是 鼠标 主要 的 功能 函数 。 如果 当前 存在 个 合法 的 鼠标 事件 ， 它 就 将 状态 数据 区 mouse 中 的 按钮 和 坐标 状态 数据 共 字节 写入 到 用户 数据 区 buffer 中 ， 并 更新 状态 mouse 。 　 　 （ ） staticintmouse ＿ select （ structinodeinode ， structfilefile ， intsel ＿ type ， select ＿ tablewait ） 　 　 如果 当前 没有 鼠标 事件 ， 就 把 wait 插入 到 mouse 的 等待 队列 中 ， 等 出现 事件 时 由 中断 处理程序 唤醒 。 这个 功能 一般 与 read ＿ mouse 结合 使用 。 　 　 LINUX 系统 中 鼠标 工作 在 中断 方式 下 ， 这个 鼠标 的 中断 处理程序 是 ： 　 　 staticvoidms ＿ mouse ＿ interrupt （ intirq ， structpt ＿ regsregs ） ； 　 　 系统 在 接收 到 硬 中断 后 自动 调用 它 。 它 的 主要 功能 是从 数据 端口 读入 当前 按钮 和 坐标 数据 ， 并 把 数据 填入 状态 数据 区 mouse ， 最后 中断 处理程序 还要 唤醒 等待 队列 中 的 进程 。 值得注意 的 是 ， 鼠标 读 操作 没有 阻塞 过程 ， 阻塞 等待 的 是 select 操作 。 不同 的 鼠标 有 自己 不同 的 设备 驱动程序 ， 但 基本 工作 原理 和 流程 相似 ， 差异 只 存在 于 硬件 操作 。 行打 设备 的 管理 　 　 行式打印机 是 UNIX 系统 的 一种 特别 的 打印 设备 ， 它 要 比 鼠标 复杂 ， 有 自己 的 缓冲区 ， 同时 系统 一般 能够 支持 多台 打印机 。 在 LINUX 系统 中 ， 本文 说明 了 总共 能 支持 台 打印机 。 行式打印机 可以 分别 工作 在 中断 和 polling 种 方式 下 ， 这种 方式 可以 相互 切换 。 ． 打印机 数据结构 　 　 行打 在 LINUX 系统 中 的 主 设备 号 为 LP ＿ MAJOR ＝ ， 它 的 中断向量 根据 不同 的 打印机 分别 配置 。 　 　 　 注 ： 　 　 （ ） lp ＿ struct 是 行 打 的 主要 结构 ， 支持 台 设备 ； 　 　 （ ） base 是 行 打 设备 的 I ／ O 基 地址 ； 　 　 （ ） irq 是 中断向量 ， 当 它 为 时 ， 打印机 工作 在 轮询 方式 ； 　 　 （ ） flag 表示 了 打印机 的 当前 状态 ； 　 　 （ ） chars 每个 字符 的 时限 ， 以 总线 周期 计算 ； 　 　 （ ） time 记录 了 当 打印机 缓冲区 填满 时 ， 驱动程序 的 等待时间 ； 　 　 （ ） lp ＿ wait ＿ q 是 打印机 的 等待 作业 队列 ； 　 　 （ ） lp ＿ buffer 是 打印 缓冲区 。 ． 打印机 驱动程序 　 　 打印机 驱动程序 的 基本 框架 与 鼠标 差不多 ， 所以 将 省略 介绍 相似 的 部分 。 行打 的 初始化 过程 ： 　 　 longlp ＿ initlongkmcm ＿ start ； 　 　 lp ＿ init 要 在 系统 字符 设备 表中 登记 行打 ： register ＿ chrdevLP ＿ MAJOR ， ″ lp ″ ， ＆ lp ＿ fops ， lp ＿ fops 是 行 打 的 文件 操作 接口 ， ′ lp ′ 是 设备 名 。 然后 程序 分别 检测 个 打印机 端口 ， 如果 存在 打印机 ， 就 在 相应 的 打印机 结构 中作 初始化 ， 标志 打印机 状态 并 通过 调用 lp ＿ reset 向 打印机 发送 初始 命令 。 从 程序 看 ， 一般 开始 时 打印机 工作 在 轮询 方式 下 ， 并且 决定 了 打印机 的 存在 状态 。 这里 还 出现 了 关于 I ／ O 资源 申请 的 问题 ， 打印机 必须 向 系统 申请 相应 的 I ／ O 地址 空间 ， 如果 要 申请 的 I ／ O 空间 已经 被 占用 了 ， 此 打印机 的 初始 过程 就 失败 。 关于 资源 的 程序定义 在 文件 ／ kernel ／ resource ． c 中 。 　 　 行打 的 主要 文件 接口 数据 定义 ： 　 　 驱动程序 根据 i 节点 确定 具体 的 打印机 ， 即 通过 MINOR （ inode － ＞ i ＿ rdev ） 确定 ， 一般 的 驱动程序 都 使用 这种 方法 分辨 不同 的 设备 。 接着 程序 进行 一些 合法性 判断 ， 如 是否 存在 空闲 、 是否 缺纸 等等 。 前面 曾经 提到 行打 能够 分别 支持 中断 和 polling 工作 方式 ， 在 中断 方式 下 ， 还 需 申请 打印机 缓冲区 和 相应 的 中断 号 ， 并 设置 中断 处理程序 lp ＿ interrupt ， 最后 设置 忙 标志 。 　 　 （ ） staticvoidlp ＿ release （ structinodeinode ， structfilefile ） 　 　 这个 过程 仅仅 逆 open 过程 ， 释放 缓冲区 和 中断 号 ， 设置 空闲 标志 。 如果 是 polling 方式 则 仅 需 设置 空闲 标志 。 　 　 （ ） staticintlp ＿ writestructinodeinode ， structfilefile ， constcharbuf ， intcount ） 　 　 根据 工作 方式 分别 进行 不同 的 写 操作 ： intlp ＿ write ＿ interruptunsignedintminor ， constcharbuf ， intount 和 intlp ＿ write ＿ polledunsignedintminor ， constcharbuf ， intcount 。 它们 的 基本功能 相同 ， 即 把 buf 中 的 字符 写入 设备 文件 ， 其中 在 中断 方式 下 首先 把 buf 中 的 内容 放入 打印机 缓冲区 中 ， 然后 再 个字符 个字符 地 打印 ， 二种 方式 主要 的 不同 是 对 异常情况 的 处理 。 polling 方式 调用 schedule 函数 进入 睡眠 等待 ， 由 系统调度 进程 唤醒 ； 而 中断 方式 则 调用 interruptable ＿ sleep ＿ on 函数 在 该 打印机 的 等待 队列 中 插入 ， 等到 打印机 ready 时由该 打印机 中断 唤醒 。 总的来说 ， 中断 方式 的 效率 更高 ， 更 灵活 一些 。 　 （ ） staticintlp ＿ ioctl （ structinodeinode ， structfilefile ， unsignedintcmd ， unsignedlongarg ） 　 　 ioctl 是 个 特殊 的 文件 接口 ， 它 的 函数 入口 地址 是 sys ＿ ioctl ， 定义 于 文件 fs ／ ioctl ． c 中 。 它 主要 用来 对 特殊 文件 的 底层 参数 进行 操作 。 如果 对象 是 普通 文件 ， 主要 对 文件 结构 中 的 f ＿ flags 参数 进行 操作 ， 如 FI ／ OCLEX ， FI ／ ONCLEX 和 FI ／ ONBI ／ O 等 ， 分别 读取 或 设置 阻塞 属性 ， 进行 bmap 操作 。 如果 对象 是 设备 文件 就 调用 设备 驱动程序 的 ioctl 接口 。 当然 并 不是 所有 的 设备 文件 都 需要 这个 接口 。 在 打印机 中 ， 该 功能 函数 可以 读取 和 设置 lp ＿ struct 结构 中 的 参数 。 如果 是 超级 用户 还 能 重新 设置 该 打印机 的 中断向量 号 ， 中断向量 号 为 即 意味着 工作 在 polling 方式 下 。 　 　 当 工作 在 中断 方式 下 的 时候 ， 中断 处理程序 lp ＿ interrupt 根据 irq 找到 相应 的 打印机 ， 并 唤醒 该 打印机 上 睡眠 的 进程 。 每台 打印机 的 中断 处理程序 都 相同 ， 而 polling 方式 则 不 需要 这个 过程 。 其实 从 程序 看 ， 二种 工作 方式 比较 类似 ， 轮询 方式 也 用 schedule 进行 进程 切换 ， 只不过 中断 方式 更 有 目标 ， 挑选 该 事件队列 中 的 等待 进程 进行 调度 。 打印机 的 缓冲区 分配 在 核心 空间 中 ， 中断 方式 下 用来 暂存 用户 打印 数据 。 而 轮询 方式 下 打印机 并 没有 使用 这个 缓冲区 ， 它 直接 从 用户 数据 区 读取 。 结束语 　 　 上面 介绍 了 二种 简单 典型 的 字符 设备 驱动程序 ， 它们 各有特点 。 通过 对 二者 相互 结合 的 补充 说明 ， 阐述 了 有关 字符 设备 的 概念 。 其中 涉及 到 了 硬件 中断 和 轮询 机制 、 设备 文件 与 设备 驱动程序 的 接口 以及 对 输入输出 设备 的 控制 和 关于 设备 的 安装 等等 问题 ， 并 对 这些 问题 进行 了 较为 深入 的 分析 与 研究 。 作为 个 开放性 的 操作系统 ， LINUX 将会 有 越来越 广泛 的 应用 前景 。 叶绿 （ 杭州 应用 工程技术 学院 信电系 ） 参考文献 ， 金连甫 ． UNIX 系统 代码 分析 ． 杭州 ： 浙江大学 出版社 ， ， 胡希明 ． UNIX 结构 分析 ． 杭州 ： 浙江大学 出版社 ， 收稿 日期 ： － －
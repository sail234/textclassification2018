计算机 研究 与 发展 JOURNALOFCOMPUTERRESEARCHANDDEVELOPMENT 年 第卷 第期 VolNo 通用 的 高性能 算术 编码器 闫宇松 　 　 　 石 青云 摘 　 要 　 文中 基于 成熟 的 QM 算术 编码器 ， 提出 了 对称 二叉树 的 编码方式 STQM 和 最优 二叉树 的 编码方式 OTQM ． STQM 与 OTQM 均 是 大 符号 集熵 编码器 它们 不仅 保持 了 QM 编码器 的 超过 的 编码 效率 ， 也 保持 了 它 高速 运算 的 特性 其中 OTQM 可以 动态 的 调整 码 树结构 ， 使得 编码 速度 达到 理论 最优 值 STQM 由于 可 并行性 和 逻辑 线路 设计 简单 等 特点 ， 使 之 适合 于 做 动态 序列 图像 的 基于 专用 硬件 设计 的 熵 编码 模块 关键词 　 QM 编码器 ， STQM ， OTQM ， 数据压缩 ， 自 适应 模型 中图法 分类号 　 TPUNIVERSALHIGHPERFORMANCEARITHMETICENCODERYANYuSongandSHIQingYunNationalLaboratoryofMachinePerceptionPekingUniversityBeijingAbstract 　 InthispapersymmetrybinarytreecoderSTQMandoptimalbinarytreecoderOTQMareproposedbasedontheQMcoderSTQMandOTQMaremultiplicationfreearithmeticcoderswithhighperformanceformultisymbolalphabetwhichnotonlykeeptheencodingefficiencyofQMcoderbutalsokeepitshighspeedOTQMcanadjustitsbinarytreestructuredynamicallyThisadvantageenablestheencodertoreachitsmaximumspeedSTQMcanbeimplementedbyspecialhardwareasaparallelcodersothatitisveryusefulforvideocodingKeywords 　 QMcoder ， STQM ， OTQM ， datacompression ， adaptivemodel 　 引 　 　 言 　 　 QM 算术 编码 是 一种 成熟 的 压缩算法 它于 年代 初 被 用于 著名 的 静止图像 压缩 标准 JPEG 和 JBIG 中 ［ ］ 它 被 选用 的 原因 是 它 具有 超过 的 编码 效率 ， 因而 能 达到 比 霍夫曼 编码 更好 的 压缩 水平 同时 由于 它 将 编码器 所 必须 的 乘法 操作 用 查表 和 间隔 寄存器 的 近似 来 替代 ， 所以 它 又 是 一种 无 乘法 运算 的 编码方法 对于 编码 符号 的 概率 更新 ， QM 编码器 是 利用 状态机 位置 的 转换 来 实现 的 ， 这种 方法 避免 了 CACM ［ ］ 所 必须 的 除法 运算 ， 同时 保持 了 算术 编码 的 自 适应 特性 所有 这些 都 使 QM 编码器 成为 一种 比较 好 的 编码 选择 但是 由于 QM 编码器 对 状态机 的 更新 机制 ， 使 它 只能 反映 两个 符号 的 概率 变化 ， 要 想 将 其 推广 至多 符号 集合 ， 必须 引入 二叉树 结构 在 JPEG 标准 中 所 采用 的 是 类似 于 非对称 二叉树 结构 ， 这种 结构 是 由 DCT 变换 后 系数 的 特殊 分布 所 决定 的 ， 因而 不 具有 通用性 本文 所 提出 的 对称 二叉树 编码方法 STQM 和 最优 二叉树 的 编码方式 OTQM ， 使得 QM 编码器 具有 通用 、 高速 、 高效率 、 自 适应 、 结构 简单 、 可 并行 、 支持 大字符集 等 诸多 优点 　 　 本文 将 在 第节 对 QM 编码器 做 简单 介绍 ． 在 第节 给出 STQM 编码器 的 构造方法 ， 第节 对 这种 方法 进行 理论 证明 ， 第节 给出 OTQM 编码器 的 构造 理论 ， 第节 给出 实验 结果 　 QM 编码器 简介 　 　 QM 编码器 起源于 IBM 公司 的 Q 编码器 ， 它 是 由 LangdonRissanen 等 人 的 早期 工作 发展 而来 的 ． 和 其它 的 算术 编码方法 一样 ， QM 编码器 从 原理 上 可 清晰 地 分为 二进制 编码 和 统计 模型 两个 部分 ． 　 　 QM 编码器 本质 上 是 一种 二进制 编码方法 ， 这 意味着 就 单一 上下文 而言 ， 它 只能 对 和 两个 符号 进行 编码 ． 在 编码 过程 中 ， QM 编码器 利用 重新 归一化 使 间隔 寄存器 A 保持 在 ～ 之间 ， 同时 对 编码 寄存器 C 作 相应 运算 产生 输出 码流 ． 由于 A 满足 ： ＜ A ≤ ， 与 比较 接近 ， 因而 可 将 需要 用 乘法 精确 计算 的 概率 间隔 细分 A × Qe 用 Qe 来 直接 近似 ， 免去 了 乘法 运算 ， 提高 了 速度 　 　 在 统计 模型 部分 ， QM 编码器 最有 特色 的 是 状态机 的 概率 估值 技术 ． 每 一个 输入 符号 流都 有 其 对应 的 符号 概率 ， QM 编码器 能够 利用 状态机 对 这种 概率 进行 动态 跟踪 与 估计 ． 实际 的 算法 中 ， 状态机 是 用 一个 状态 估值 表来 表示 的 ， 它 包括 状态 的 索引 ， 概率 的 估值 Qe 以及 状态 的 转移 方向 ． 初始 编码 时 ， 符号 流 被 置 为 一个 初始状态 ． 它 所 对应 的 概率 估值 Qe 反映 了 符号 的 初始 分布 ． 随着 编码 过程 的 不断 继续 ， 符号 流 的 概率分布 也 在 不断 的 变化 ． 每当 编码器 重新 归一化 时 ， 符号 流 的 状态 都 会 按照 状态 估值 表 的 状态 转移 方向 改变 到 下 一个 状态 ． 新 状态 所 对应 的 Qe 值 正好 是 对 当前 符号 概率 的 更新 估计 ． 状态 估值 表 的 特殊 设计 保证 了 这种 估值 的 准确性 ， Pennebaker 和 Mitchell 在 文献 ［ ］ 中 对此 做 了 详细 的 阐述 由于 符号 流 的 状态 反映 了 符号 的 概率 ， 因此 每 一个 符号 流 只要 维护 一个 状态 索引 值 ， 就 能 确定 当前 是 什么 状态 ， 进而 得到 概率 的 估计 ， 完成 算术 编码 ． 　 　 QM 编码器 还是 一种 自 适应 算术 编码 ． 由于 符号 流 状态 的 变化 是 随着 符号 的 输入 而 自动 调整 的 ， 因此 QM 编码器 能够 把握 符号 流 的 局部 分布 特性 ， 无需 对 符号 的 整体 概率 做 事先 统计 ， 具有 很强 的 适应能力 ． 同时 状态 转移 方法 还 使 它 避免 了 一般 自 适应 算术 编码 对 概率 估计 所 需要 的 除法 运算 ， 进一步提高 了 运算 速度 　 　 在 算术 编码 中 ， 我们 通常 为 每 一个 符号 流 分配 一个 特定 的 上下文 序号 S ． 不同 的 上下文 S 对应 着 不同 的 符号 流 ， 也 对应 着 不同 的 符号 概率 ． 如果 编码器 能够 同时 对 不同 的 符号 流 采用 各自 的 符号 概率 进行 编码 ， 那么 这种 编码 就 称为 混合 上下文 编码 ， 否则 就 称为 单一 上下文 编码 ． QM 编码器 的 状态机 一共 有个 状态 ， 这一 设计 使 它 无论 对 单一 上下文 还是 混合 上下文 都 能 保证 概率 估值 的 准确性 　 　 使用 QM 编码器 需要 调用 以下 几个 外部 函数 ： 　 　 编码器 ： 　 　 　 Initenc 　 　 　 　 　 初始化 编码器 　 　 　 CodeS 　 　 　 　 　 对 上下文 序号 S 编码 判决 　 　 　 CodeS 　 　 　 　 　 对 上下文 序号 S 编码 判决 　 　 　 Flush 　 　 　 　 　 　 终止 编码 　 　 解码器 ： 　 　 　 Initdec 　 　 　 　 　 初始化 解码器 　 　 　 DecodeS 　 　 　 　 　 对 上下文 序号 S 解码 二进制 判决 　 　 编码 时 ， 首先 调用 Initenc ， 它 的 作用 是 对 编码器 进行 初始化 ． 紧接着 对 上下文 序号 为 S 的 二值 符号 流 进行 编码 ， 如果 输入 符号 为 ， 就 调用 CodeS ， 如果 输入 符号 为 ， 就 调用 CodeS 编码 结束 时 ， 调用 Flush 对 编码 寄存器 置空 　 　 解码 时 ， 使用 Initdec 对 解码器 进行 初始化 接着 不断 调用 DecodeS 对 上下文 序号 S 进行 解码 ， 得到 由 和 组成 的 二进制 符号 流 　 　 在 编解码 过程 中 ， 上下文 S 的 作用 是 标志 不同 的 符号 流 ． QM 编码器 允许 混合 上下文 编码 ， 也就是说 它 可以 对 几路 符号 流 同时 编码 ， 而 每 一路 符号 流都用 各自 的 状态 索引 值来 估计 概率 ． 这一 特点 使得 我们 可以 进行 树型 QM 编码器 的 构造 ． 事实上 ， 下文 我们 所 构造 的 编码 树 的 每 一个 叉 节点 就 对应 着 一个 上下文 ， 整个 树型 编码器 就 相当于 一个 混合 上下文 的 QM 编码器 ． 　 STQM 编码器 的 构造 　 　 由于 QM 编码器 原理 上 只 对 二值 符号 集 进行 编码 ， 要 想 使 其 对 大 符号 集 进行 编码 ， 并且 满足 熵 编码 的 性质 ， 必须 采用 二叉树 的 结构 下面 我们 将 讨论 二叉树 结构 与 QM 编码器 是 如何 结合 的 　 　 设 输入 符号串 k 的 符号 集为 S ， 其中 Sxx … xN ， 而 xii … N 表示 k 中 可能 出现 的 N 种 符号 我们 定义 N 为 符号 集 S 的 长度 ， 记为 S 对于 二值 符号 集 显然 有 xx 如果 N 比较 大 ， 我们 就 称 S 为 大 符号 集 　 　 假设 符号 集 S 可以 分成 S 与 S 两个 部分 ， 并且 满足 ： SS ∪ S 且 那么 对于 符号串 k 中 的 任何 一个 符号 x ， 应有 其中 pxxix ∈ S 为 符号串 k 中 符号 xi 的 概率 ． 反映 在 编码方法 上 就是 ： 　 　 我们 首先 对 x ∈ S 还是 x ∈ S 进行 编码 　 　 当 x ∈ S 或 x ∈ S 已知 时 ， 再 针对 符号 子集 S 或 S 进行 xxi 的 编码 ． 　 　 对于 ， 单个 符号 x 的 归属 显然 是 一种 二值 判定 ， 可以 用 或 来 表示 ． 将 整个 符号 流 k 的 每 一个 符号 的 归属 都 用 或 来 表示 ， 就 得到 一个 二值 判定 符号 流 ． 我们 可以 使用 QM 编码器 对 该 符号 流 进行 二值 编码 ． 编码 时 ， 我们 用 一个 上下文 序号 来 表示 这个 二值 判定 符号 流 ， 并用 一个 状态值 来 反映 符号 流 概率 ． 显然 ， 二值 符号 流 的 概率分布 正是 式 中 的 px ∈ Sx ∈ S 与 px ∈ Sx ∈ S ， 它 可以 在 编码 过程 中 用 符号 流 状态 所 对应 的 概率 估值 来 近似 ． 　 　 对于 ， 其实 它 等价 于 符号 子集 上 的 算术 编码 ， 编码 所 使用 的 概率 是 式 中 的 pxxix ∈ S 或 pxxix ∈ S ． 显然 ， 这是 一种 多值 编码 ， 但 我们 可以 继续 将 符号 子集 S 或 S 分解成 更 小 的 子集 ， 对 每 一次 的 分解 我们 都 同 一样 进行 二值 编码 ． 由于 符号 子集 每 分解 一次 ， 长度 都 要 减少 ， 因此 这一 过程 可以 重复 进行 直到 符号 子集 的 长度 等于 为止 ． 　 　 相应 的 解码 方法 可以 实现 为 ： 　 　 先对 x ∈ S 还是 x ∈ S 进行 解码 ； 　 　 当 x ∈ S 或 x ∈ S 已知 时 ， 再 针对 解得 的 符号 子集 S 或 S 进行 x 的 解码 ． 这一 过程 重复 进行 直到 符号 子集 的 长度 等于 为止 ， 这时 子集 所 包含 的 唯一 符号 xi 即为 解码 所求 ． 　 　 下面 我们 以 长度 为 的 符号 集为例 ， 简述 QM 编码器 的 二叉树 方法 ： 　 　 如图所示 ， 这是 一个个 符号 的 二叉树 结构 ． 每 一个 叶 节点 代表 一个 从 到 的 符号 ， 而 每 一个 叉 节点 代表 一个 符号 集 分割 ， 或者 称为 二值 判定 ． 对叉 节点 我们 使用 QM 编码器 进行 二值 编码 ， 即将 二值 判定 中向 左 的 分支 用来 编码 ， 向 右 的 分支 用来 编码 ． 这样 ， 对 一个 符号 的 算术 编码 就 可以 用 二叉树 上 连续 的 几个 叉 节点 的 QM 二值 编码 来 表示 ． 比如 我们 要 对 符号 进行 编码 ， 首先 在 根 节点 … 处 ， 符号 集 S … 分解成 两个 符号 子集 S … 和 S … ， 由于 ∈ S … ， 而 S … 属于 二值 判定 中向 左 的 分支 ， 所以 在 该 节点 处 使用 来 编码 ． 同理 ， 在 叉 节点 … 处 ， 我们 用来 编码 右 分支 S … 最后 ， 在 叉 节点 … 处 ， 用来 编码 右 分支 ， 这时 达到 叶 节点 ， 符号 集 S 只 包含 一个 符号 ， 编码 结束 ． 解码 时 ， 我们 首先 在 根 节点 处用 QM 解码器 解 出 ， 符号 集由 S … 变为 S … ， 接着 ， 在 叉 节点 … 处 ， 我们 解 出 ， 符号 集 变为 S … ， 最后 在 叉 节点 … 处解出 ， 使 我们 最终 得到 符号 集 S ， 符号 是 S 中 的 唯一 符号 ， 因此 即 是 解码 所得 图 　 符号 集 长度 为 的 二叉树 结构 　 　 容易 看出 ， 图中 每 一个 叉 节点 所 对应 的 两个 子 节点 具有 相同 数量 的 符号 数 我们 称 这种 节点 树为 对称 型 二叉树 显然 ， 并 不是 所有 的 编码 树 都 必须 使用 对称 型 二叉树 ， 使用 什么 形式 的 二叉树 应该 具体 问题 具体分析 比如 在 JPEG 标准 中 ， 它 所 构造 的 编解码 树 就是 非对称 的 这 是 由于 经过 DCT 变换 和 量化 以后 ， 变换 系数 的 振幅 分布 基本 集中 在 点 附近 ， 并且 随着 振幅 的 增大 ， 概率 迅速 变小 由于 小 振幅 系数 相对 较 多 ， 因此 在 编码 树 设计 时 ， JPEG 标准 让 数值 较 小 的 叶 节点 位于 靠近 根 节点 的 地方 ， 这样 编码 一个 小 振幅 符号 所 经过 的 叉 节点 次数 就 非常低 ， 从而 加快 了 编码 速度 正是 由于 这个 原因 ， 这种 特殊 的 编码 树 被 设计 成 非对称 型 的 但是 对于 一般 问题 ， 我们 在 编码 之前 ， 并不知道 数据 的 分布 情况 也 就 无法 确定 哪 一个 叶 节点 应 在 靠近 根 节点 的 位置 上 针对 这种 情况 ， 我们 将 通用 编码器 的 二叉树 设计 成 具有 相对 对称 的 结构 ， 它 的 每 一个 节点 上 的 符号 集 分解 满足 ： 其中 代表 对 数据 取整 这种 对称 结构 的 编码器 ， 即 STQM ， 适用 于 任何 形式 的 数据压缩 ， 包括 文档 、 图像 、 视频 等 　 　 下面 是 STQM 的 算法 流程 　 　 编码器 ： 　 　 InitEnc 　 　 　 　 初始化 编码器 ． 　 　 FormTreeN 　 　 　 按照 符号 集 分解 式 为 输入 符号 流 形成 STQM 编码 树 ． N 为 符号 集 长度 ． 不同 的 符号 流应 使用 不同 的 编码 树 ， 并用 编码 树 上下文 TS 对 其 标志 ． 　 　 CodeTSSymbol 对 输入 符号 Symbol 顺着 编码 树 从 根 节点 一直 编到 叶 节点 ． 在 每 一个 分叉 节点 上 使用 QM 编码器 的 二值 编码 函数 CodeS 与 CodeS ， 其中 S 代表 分叉 节点 的 上下文 ． TS 为 Symbol 所属 符号 流 的 编码 树 上下文 ． 　 　 Flush 终止 编码 ． 　 　 解码器 ： 　 　 InitDec 初始化 解码器 ． 　 　 FormTreeN 形成 STQM 编码 树 ． 并用 编码 树 上下文 TS 对 其 标志 ． 　 　 DecodeTS 针对 上下文 TS 所 对应 的 编码 树 从 根 节点 一直 解码 到 叶 节点 ． 　 　 显而易见 STQM 可以 对 混合 上下文 进行 熵 编码 ． 不同 的 符号 流通 过 编码 树 上下文 TS 加以 区分 ． 每 一个 符号 流 的 字符集 长度 可以 是 任意 大小 ． 统计 模式 用 对应 的 编码 树来 表示 ． 至于 STQM 是否 满足 大 符号 集码 流 熵 编码 的 性质 ， 我们 将 在 下 一节 中 给予 证明 　 STQM 编码器 的 理论 证明 　 　 上 一节 中 ， 我们 利用 符号 集 分割 的 方法 ， 给出 了 树型 QM 编码器 的 构造 但是 这种 构造 是否 满足 熵 编码 的 原则 ？ 下面 我们 将 给予 证明 　 　 设 符号串 k 的 符号 集为 S ， 对任 一个 符号 xi ∈ S ， 它 在 k 中 的 出现 概率 为 pxxix ∈ S ． 那么 按照 熵 编码 的 原理 ， 对于 符号串 k 进行 的 变长 编码 ， 其 最小 平均 码长 是 它 的 熵 并且 这种 最佳 编码 只有 在 xi 所 对应 的 码长 为 logpxxix ∈ S 才能 达到 ． 　 　 然而 树型 QM 编码器 ， 对于 每 一个 符号 xi 的 编码 是 通过 对 几层 二叉 节点 依次 进行 QM 编码 所 获得 的 因此 ， 我们 只有 证明 树型 QM 编码器 在 这 几层 节点 上 的 编码 码长 之 和 仍旧 是 logpxxix ∈ S ， 才能 说明 树型 的 QM 编码器 是 真正 的 熵 编码器 下面 我们 将 对此 给予 证明 　 　 由 上节 的 式 ， 我们 应当 很 容易 得到 ： 　 　 式 左面 的 logpxxix ∈ S 就是 熵 编码 在 符号 是 xi 、 符号 集为 S 时所应 分配 的 码长 ． 而式 的 右面 px ∈ Sx ∈ S 与 px ∈ Sx ∈ S 所 表示 的 正是 符号 集 S 分解成 的 两个 子集 S 与 S 的 概率 ， 显然 他们 满足 ： px ∈ Sx ∈ Spx ∈ Sx ∈ S 因此 ， 如果 我们 假设 QM 编码器 是 一个 理想 的 算术 编码器 实际上 ， 任何 算术 编码器 总会 有 一些 冗余 ， 那么 在 这个 节点 上 QM 二值 编码器 为 x ∈ S 与 x ∈ S 两个 事件 所 分配 的 码长 分别 为 logpx ∈ Sx ∈ S 和 logpx ∈ Sx ∈ S 而 剩下 的 logpxxix ∈ S 与 logpxxix ∈ S 可以 按照 同样 的 方法 继续 分解 下去 ， 最终 写成 所有 后续 节点 的 QM 编码 的 码长 和 ， 直到 叶 节点 为止 因而 证明 了 树型 的 QM 编码器 是 真正 的 大 符号 集熵 编码器 　 　 还是 以图 为例 ， 显然 有 　 　 这 表明 对于 符号 进行 熵 编码 所 需要 的 码长 ， 正好 等于 树型 QM 编码器 在 S … ， S … 和 S … 三个 节点 所 使用 的 码长 之 和 ， 符合 熵 编码 的 要求 　 OTQM 编码器 的 构造 理论 　 　 本 节 我们 将 研究 最优 树型 编码器 OTQM 的 构造 原理 和 方法 从 前面 的 讨论 可知 ， JPEG 的 非对称 二叉树 结构 是 根据 DCT 变换 而 设计 的 一种 速度 最优 的 编码 策略 ， 但是 它 只 适合 于 DCT 系数 的 特殊 分布 特点 ， 并 不 具有 普适性 STQM 对 通常 的 编码数据 都 可以 进行 有效 的 编码 ， 它 的 编码 速度 也 是 比较 快 的 ， 但 它 并 不能 针对 数据 本身 的 分布 情况 达到 最快 为了 使 不同 分布 的 数据 都 能 达到 速度 极限 ， 我们 必须 使 二叉树 的 结构 可以 在 编码 过程 中 动态 地 改变 这种 可 动态 调整 的 树型 结构 不会 降低 压缩 效率 ， 能够 达到最佳 编码 速度 ， 对 不同 数据类型 具有 普适性 　 　 首先 从 理论 上 研究 OTQM 的 二叉树 构造 原理 为了 分析 编码 时间 ， 我们 假设 在 每 一个 节点 上 ， 任何 一次 二值 编码 所用 的 时间 都 是 固定 的 ， 并 将 其 归一化 为 那么 ， 任何 一个 符号 的 编码 时间 就 可以 由 它 在 编码 过程 中 所 经历 的 树 节点 个数 来 确定 　 　 对于 符号 集为 xx … xN 的 符号 流 ， 相应 的 概率分布 为 pp … pN ， 各个 符号 编码 时所 经历 的 节点 个数 为 nn … nN ， 那么 整个 符号 流 的 平均 编码 时间 就 可以 表示 为 我们 研究 的 目的 是 如何 设计 最优 二叉树 结构 使 T 值 最小 　 　 容易 证明 以下 定理 ： 对于 任意 两组 数据 ： pp … pN 与 qq … qN ， 其中 ＜ pi ＜ ， ＜ qi ＜ ， 它们 分别 满足 ∑ pi 和 ∑ qi ， 那么 必有 等 号 成立 的 条件 为 piqii … N 　 　 对于 我们 将 每个 ni 表示 成 logni 以下 的 对数 都 默认 为 以为 底 ， 由于 二叉树 的 构造 满足 ， 因此 通过 式 可知 ： 并且 等 号 成立 的 条件 也 就是 T 取 最小值 的 条件 为 pinii … N 所以 为了 使 编码 时间 最短 ， 每 一个 符号 所 应 经过 的 节点 个数 为 nilogpii … N 这 也 就是 最优 编码 树所应 遵循 的 设计 原则 下面 我们 从 实际 出发 来 设计 OTQM 的 二叉树 　 　 从 理论 上 来说 ， nilogpii … N 是 每 一个 符号 所 应 经过 的 最佳 节点 个数 ． 但是 节点 的 个数 应该 是 一个 整数 ， 不 可能 是 一个 分数 ， 因此 我们 只能 设计 一个 近似于 最优 的 编码方案 ． 　 　 首先 需要 对 符号 进行 排序 在 建立 二叉树 的 时候 ， 我们 已经 得到 了 符号 集 的 概率分布 pp … pN ， 就 可以 按照 每个 符号 的 概率 从大到 小 进行 排序 ， 经过 排序 后 的 符号 集为 xs ［ ］ xs ［ ］ … xs ［ N ］ ， 相应 的 符号 概率 为 ps ［ ］ ps ［ ］ … ps ［ N ］ ， 并且 满足 　 　 排序 后 我们 应 进行 集 分割 先 搜索 整数 j ， 使得 最小 ， 其中 ≤ j ＜ N 然后 将 集合 xs ［ ］ xs ［ ］ … xs ［ N ］ 分解 为 xs ［ ］ xs ［ ］ … xs ［ j ］ 和 xs ［ j ］ xs ［ j ］ … xs ［ N ］ 两个 子集合 不断 的 将 子集合 按照 同样 的 方法 分解 ， 直到 集合 长度 等于 为止 最后 按照 集合 的 分解 过程 建立 二叉树 ， 这个 二叉树 就是 速度 最优 的 OTQM 编码 树 ． 　 　 可以 验证 ， 当 符号 概率 都 是 的 负 整数 幂 的 情况 下 ， 这种 设计 方法 可以 达到 理论 最优 值 当 符号 概率 不是 的 负 整数 幂 的 时候 ， 此 方法 是 理论值 的 最佳 近似 而且 我们 能够 看到 ， 针对 于 DCT 符号 流 的 统计 特点 ， OTQM 编码 树 的 设计 结果 与 JPEG 编码 树 的 设计 保持一致 　 　 在 具体 的 编码 过程 中 ， 由于 树型 QM 编码器 是 自 适应 的 编码方法 ， 我们 可以 边 编码 边 进行 统计 ， 并 通过 统计 结果 动态 地 调整 最佳 OTQM 码树 的 结构 ， 以 适应 数据 的 统计 特点 对于 非 平稳 数据 ， 它 还 能够 自 适应 地 适应 数据 的 局部 统计 特点 ， 达到最佳 效果 　 　 当然 OTQM 编码 中码 树 的 动态 调整 也 要 耗费 一定 的 时间 ， 但是 我们 并不需要 每编 一个 符号 就 调整 一回 码树 ， 我们 可以 在编 过 相对 较长 的 一段 数据 以后 ， 再 调整 一次 码 树结构 ， 比如 ， 每 处理 个 符号 后 进行 一次 码树 重构 ， 这种 方法 使得 调整 本身 所用 的 时间 可以 忽略不计 另一方面 ， 码树 的 调整 在 编码 端 和 解码 端 应该 保持 同步 ， 只有 这样 才能 保证数据 在 解码 端的 正确 解码 ． 　 　 对于 专用 硬件 设计 而言 ， 动态 调整 的 逻辑设计 似乎 比较复杂 我们 感觉 如果 能够 事先 知道 符号 流 的 概率分布 ， 并且 数据 相对 平稳 ， 可以 将 编码器 设计 成 固定 的 OTQM 码树 如果 数据分布 不 平稳 ， 符号 概率 不 可知 ， 是 选用 OTQM 还是 STQM 应 综合 考虑 如果 使用 软件 实现 ， OTQM 编码 是 一种 较 好 选择 ． 　 STQM 编码器 的 实验 结果 　 　 QM 编码器 之所以 被 使用 是因为 它 只 需要 加减 与 移位 运算 ， 完全避免 了 费时 的 乘法 与 除法 ， 因而 比 CACM 算术 编码器 具有 更 高 的 速度 同时 ， 它 的 编码 效率 能够 保持 在 以上 ， 这 也 是 一般 的 霍夫曼 编码 所 难以达到 的 　 　 相应 的 ， STQM 编码器 在 每 一个 二叉 点 的 编码 上 ， 只 需要 增加 一个 减法 运算 ， 同样 避免 了 乘除 法 ， 因此 在 一定 程度 上 保持 了 QM 算术 编码 的 高速 特性 ， 又 由于 它 在 每 一个 节点 上 进行 的 都 是 QM 编码 ， 因而 整体 的 编码 效率 也 能 超过 　 　 STQM 编码器 同样 保持 了 QM 编码器 自 适应 统计 的 特点 ， 这 使得 编码器 可以 随着 数据 不同 部分 的 统计 特点 的 变化 而 变化 ． 这种 自 适应 的 特点 往往 使得 QM 编码器 突破 熵 的 限制 ， 而 熵 是非 自 适应 熵 编码 的 编码 极限 ． 　 　 下面 的 表是 本文 的 对称 树型 QM 编码器 的 实验 结果 ， 与其 相 比较 的 是 自 适应 CACM 编码器 ． 实验 数据 取自 一个 长度 为 字节 的 普通 DOC 文件 ． 方法 是 对 该 文件 的 每个 数据 取 余数 ， 从而 得到 具有 相应 大小 的 字母表 的 实验 数据文件 ． 表 　 压缩 结果 符号 集 尺寸 符号串 长度 熵 bits 非自 适应 编码 极限 bytesSTQMbytesCACMbytes 　 　 从表 的 实验 结果 可以 看到 ， STQM 编码器 的 编码 效率 远远 突破 了 非自 适应 算术 编码 的 极限 ． 这 表明 了 该 试验 数据 具有 非 平稳 的 特征 ． 同时 ， STQM 编码器 的 编码 效率 一般 都 超过 了 CACM ， 表明 了 它 具有 比 CACM 更好 的 自 适应能力 ． 　 　 图 表明 在 小 字符集 的 情况 下 ， 本文 的 对称 树型 编码器 STQM 比 CACM 快 很多 ． 实际上 ， 在 字符集 的 大小 为 的 时候 ， STQM 甚至 比 CACM 快倍 以上 ． 而 当 字符集 大小 超过 的 时候 ， STQM 与 CACM 的 速度 渐渐 地 接近 ． 这 主要 是因为 STQM 编码 所 需要 经过 的 节点 数 随着 字符集 尺寸 的 增加 而 加大 ， 因而 导致 速度 会 渐渐 地 变慢 ． 本 程序 是 用 C语言 写成 ， 实验 结果 在 Pentium 上 运行 获得 ． 如果 排除 文件 输入 与 输出 的 影响 ， 速度 会 进一步 地 提高 ． 图 　 STQM 与 CACM 在 Pentium 微机 上 的 编码 速度 　 　 值得 提到 的 是 文献 ［ ］ 中 的 算术 编码 也 是 一种 无 乘法 编码器 ， 本文 的 STQM 编码器 在 速度 上 比 该文 的 方法 略 好 一些 ． 同时 ， 本 方法 似乎 也 不太受 字符集 尺寸 的 影响 ， 对系统 的 资源 要求 不高 ， 适于 高阶 统计 模型 的 应用 ． 另外 本文 做 比较 用 的 CACM 的 平均 编码 速度 可以 达到 Ksymbolss ， 而 文献 ［ ］ 中 的 CACM 平均速度 只有 Ksymbolss ， 如此 大 的 速度 差距 可能 是 由于 程序 优化 不够 造成 的 ． 　 　 由于 对称 树型 QM 编码器 只用 到 了 整型 的 加减法 与 移位 运算 ， 因而 给 专用 硬件 设计 带来 了 极大 的 方便 ． 同时 由于 硬件 的 可 并行性 ， 使 它 可以 成倍 的 提高 速度 ， 因此 它 也 是 一种 基于 硬件 的 视频信号 熵 编码 的 较 好 的 选择 ． 但 同时 也 应 看到 ， 在 专用 硬件 实现 中 ， QM 编码器 需要 维持 一个 表格 存储器 ， 该 存储器 也 会 占据 一定 的 芯片 面积 ， 即 总 的 成本 孰 优孰劣 尚无 定论 ． 而 在 现代 微处理器 或 DSP 处理器 中 ， 乘法 的 速度 似乎 也 并不比 加法 慢 ， 这 进一步 拉近 了 CACM 和 STQM 的 距离 ． 因此 如何 选择 ， 还应 具体 问题 具体分析 ． 本 课题 得到 国家自然科学基金 重点项目 项目编号 、 航天 领域 基金项目 和 “ 九七 三 ” 基金项目 项目编号 G 的 资助 ． 作者简介 ： 闫宇松 ， 男 ， 年月生 ， 博士 研究生 ， 主要 研究 领域 为 模式识别 与 图像处理 、 计 　 　 　 　 　 算机 视觉 ． 　 　 　 　 　 石 青云 ， 女 ， 年月生 ， 教授 ， 中科院 院士 ， 主要 研究 领域 为 模式识别 与 图像 处 　 　 　 　 　 理 、 计算机 视觉 ． 作者 单位 ： 北京大学 视觉 与 听觉 信息处理 国家 重点 实验室 　 北京 　 参考文献 　 　 WilliamBPennebakerJoanLMitchellJPEGStillImageDataCompressionStandard ． NewYorkVanNostrandReinhold 　 　 ClearyJGWittenIHNealRMArithmeticcodingfordatacompressionIBMJournalofResearchandDevelopmentCommunoftheACM ～ 　 　 PennebakerWBMitchellJLProbabilityestimationfortheQcoderIBMJournalofResearchandDevelopment ～ 　 　 薛晓辉 ， 高文小 字母表 的 高性能 算术 编码 计算机 学报 ～ 　 　 XueXiaohuiGaoWenHighperformancearithmeticcodingforsmallalphabetsChineseJournalofComputers ～ 原稿 收到 日期 ： ； 修改稿 收到 日期 ：
软件 学报 JOURNALOFSOFTWARE 年 第期 No 一个 并行计算 支持 环境 的 设计 与 实现 陶 　 杰 　 鞠九滨 　 　 摘要 　 介绍 了 一个 并行计算 的 支撑 环境 PCSE （ parallelcomputationsupportingenvironment ） 通过 引入 FORK 与 JOIN 原语 ， 使得 无论是 使用 过程 程序设计 语言 ， 还是 使用 逻辑 程序设计 语言 编写 的 用户 源程序 都 能 在 本 系统 上 并行执行 ， 从而 为 用户 进行 高速 计算 提供 了 一个 很 好 的 软件 基础 目前 ， PCSE 支持 FORTRANC 以及 PROLOG 应用程序 的 并行执行 　 　 关键词 　 并行计算 ， 分布式 程序设计 ， 网络 工作站 　 　 中图法 分类号 　 TPDesignandImplementationofaParallelComputationSupportingEnvironmentTAOJieJUJiubin 　 　 Abstract 　 AparallelcomputationsupportingenvironmentnamedPCSEparallelcomputationsupportingenvironmentisdescribedinthispaperByintroducingfromtwoprocessoperationprimitives — — FORKandJOINanyprogramwhetherwritteninprocedureprogramminglanguageorlogicprogramminglanguagecanbeexecutedinparallelPCSEprovidesanexcellentsoftwareinterfacefortheuserstocarryoutonhighspeedcalculationAtpresentPCSEsupportsFORTRANCandPROLOGapplicationsexecutedinparallel 　 　 Keywords 　 Parallelcomputingdistributedprogrammingnetworkedworkstations 　 　 计算机 的 一个 重要 的 应用领域 是 科学计算 天气预报 、 人造卫星 、 飞机 和 轮船 的 外形 设计 以及 物质 结构 分析 等 复杂 的 运算 都 离不开 计算机 然而 ， 科学计算 又 是 非常 费时 的 许多 问题 即使 在 大型机 、 巨型机 上 求解 也 需 花费 几天 甚至 几十天 的 时间 ； 若 是 在 微机 上 计算 ， 耗时 会 更长 目前 ， 大型机 、 巨型机 由于 价格昂贵 ， 还 不能 普遍 应用 ， 人们 更 多 的 是 依靠 微机 （ 尤其 是 工作站 ） 进行 科学计算 UNIX 工作站 已用 得 非常 普遍 ， 很多 用户 拥有 一批 网络连接 的 工作站 ， 但 这些 工作站 大部分 时间 是 空闲 的 因此 ， 人们 提出 了 使用 网络 空闲 工作站 进行 并行计算 的 方法 然而 ， 目前 人们 所 研制 的 并行 系统 都 是 针对 某 一种 或 一类 程序设计 语言 ， 还 没有 一个 统一 的 、 适合 于 各种 语言 （ 包括 过程 程序设计 语言 和 逻辑 程序设计 语言 ） 的 并行 系统 科学计算 使用 的 语言 种类 繁多 ， 有 必要 设计 一个 统一 的 计算 模型 本文 所 描述 的 支撑 环境 PCSEparallelcomputationsupportingenvironment 即 是 为此 目的 而 研制 的 通过 提供 两条 功能强大 的 进程 操作 原语 FORK 和 JOIN ， 使得 无论是 用 FORTRANC 还是 用 PROLOG 语言 书写 的 程序 都 能够 在 网络 工作站 群上 并行执行 ， 从而 提高 了 计算速度 　 FORK 和 JOIN 的 语义 　 　 包含 并行性 的 程序 在 网络 环境 下 并行执行 时 ， 需要 进行 并行任务 的 派生 与 汇合 并行任务 的 派生 就是 使 一个 任务 在 执行 的 同时 ， 派 生出 可 与 它 并行执行 的 其他 任务 ， 分配 给 不同 的 处理机 完成 这些 任务 的 执行 时间 可能 是 不同 的 ， 需要 等 它们 全部 完成 后 将 结果 汇合 起来 才能 进行 后续 任务 后续 任务 可以 是 单一 的 也 可以 是 新 的 并行任务 如果 是 新 的 并行任务 ， 又 要 进行 派生 与 汇合 ， 如此 下去 ， 直至 整个 程序 结束 　 　 FORK 语句 的 形式 是 FORKl 其中 l 是 新 进程 的 标识符 在 FORTRAN 程序 中 l 是 一个 语句 标号 ； 在 C 程序 中 ， l 是 一个 特定 的 标记 ； 在 PROLOG 程序 中 ， l 是 一个 谓词 执行 一个 FORKl 语句 时 ， 派 生出 标识符 为 l 的 新 进程 具体地说 ， 就是 准备 好 启动 和 执行 该 进程 所 必需 的 有关 信息 ， 将 空闲 的 处理机 分配 给 该 进程 如果 没有 可用 的 空闲 处理机 ， 则 让 该 进程 进入 排队 栈 等待 FORK 派生 的 计算 还 可以 再 派生 ， 因此 FORK 可 嵌套 ， 以便 充分利用 处理机 资源 ， 使 各 处理机 都 处于 忙碌 状态 特别 是 对于 PROLOG 程序 ， 同一 子句 中 能 并行 （ 本 系统 只 实现 了 AND 并行 ） 的 子目标 不 多 ， 但 程序 中 递归 现象 却 很 常见 因此 ， 对于 PROLOG 程序 ， 必须 允许 FORK 嵌套 ， 这样 才能 获得 较 高 的 性能 　 　 与 FORK 语句 相配合 ， JOIN 语句 的 形式 是 JOINn ， 其中 n 为 已 派 生出 的 并发 进程 的 个数 JOIN 语句 附有 一个 计数器 ， 其 初始值 为 每当 一个 被 派生 的 进程 得到 结果 后 ， 计数器 的 值加 ， 并 与 n 比较 若 计数器 的 值 小于 n ， 表明 此 进程 不是 并发 进程 中 的 最后 一个 ， 则 将 该 进程 占用 的 处理机 释放出来 ， 以 执行 正在 排队 栈中 等待 的 其他 任务 ， 如果 排队 栈 已空 ， 则 让 该 处理机 空闲 如果 计数器 的 值 等于 n ， 则 表明 所有 并发 进程 都 已 得到 结果 ， 此时 ， 将 结果 汇合 起来 ， 继续执行 后续 任务 　 　 FORK 和 JOIN 两个 原语 需要 由 用户 加入 其 原程序 中 ， 但 这 并 不会 给 用户 增加 太大 的 负担 下面 左边 一列 是 矩阵 乘 的 FORTRAN 原程序 和斐 波纳契 数 求解 的 PROLOG 原程序 ， 右边 一列 是 加入 FORK 和 JOIN 后 的 并行程序 　 　 　 　 　 　 　 　 DOJ 　 　 　 　 　 　 　 　 　 　 　 　 　 DOJ 　 　 　 　 　 　 　 DOI 　 　 　 　 　 　 　 　 　 　 　 　 　 FORK 　 　 　 　 　 　 　 　 CIJ 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 J 　 　 　 　 　 　 　 　 DOK 　 　 　 　 　 　 　 　 　 　 　 　 DOI 　 　 　 　 　 　 　 CIJCIJAIKBKJ 　 　 　 　 　 CIJ 　 　 　 　 　 　 　 CONTINUE 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 DOK 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 CIJCIJAIKBKJ 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 CONTINUE 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 JOIN 　 　 　 　 　 fib 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 fib 　 　 　 　 　 fib 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 fib 　 　 　 　 　 fibNMNisNNisN 　 　 　 　 fibNMNisNNisN 　 　 　 　 　 　 　 　 　 　 fibNMfibNM 　 　 　 　 　 　 　 　 FORKfibNM 　 　 　 　 　 　 　 　 　 　 MisMM 　 　 　 　 　 　 　 　 　 　 　 　 　 　 fibNMJOIN 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 MisMM 　 　 上述 FORTRAN 并行程序 意味着 有个 进程 并行执行 ， 每个 进程 求解 C 矩阵 的 一列 在 这里 ， 每个 进程 执行 的 程序 是 一样 的 ， 即到 之间 的 语句 ， 但 它们 的 结果 并不一定 在 同一 时刻 得出 当 所有 进程 都 得出 结果 后 ， 要 在 主 处理机 （ 用户 提交 任务 的 处理机 ） 上 对 结果 进行 汇合 ， 然后 再 进行 后面 的 任务 上述 PROLOG 并行程序 意味着 fibNM 将 远程 执行 ， fibNM 将 本地 执行 ， 而且 在 执行 fibNM 和 fibNM 时 ， 可能 还会 继续 派生 ， 如此 最大 程度 地 开发 并行性 　 系统 实现 预 编译 　 　 用户 提交 的 并行程序 必须 经过 预 编译 的 过程 ， 以 产生 可 并行 的 子 任务 ， 从而 在 网络 工作站 上 并行执行 预 编译 时 每当 扫描 到 一个 FORK 语句 ， 就 首先 对 与其 配对 的 JOIN 间 的 语句 进行 粒度 检查 由于 系统 中 存在 着 额外 开销 ， 一些 小 任务 不 适合 远程 执行 ， 因此 对 并行任务 必须 进行 粒度 控制 文献 ［ ］ 所 描述 的 用 FORK 和 JOIN 语义 实现 的 分布式 Prolog 系统 ， 就是 因为 没有 进行 粒度 控制 ， 才 导致 加速 比不高 对于 过程 程序设计 语言 ， 用户 派生 的 任务 中 一般 都 含有 循环 语句 ， 因此 ， 我们 通过 循环 次数 和 循环 体内 语句 条数 控制 粒度 如果 粒度 低于 预先 给定 的 数值 ， 那么 ， 任务 中 即使 有 FORK 语句 ， 也 不 执行 FORK 操作 而 对于 逻辑 程序设计 语言 ， 用户 要 派生 的 任务 往往 都 是 递归 程序 ， 因此 ， 我们 通过 递归 深度 来 控制 粒度 （ 详见 文献 ［ ］ ） 　 　 粒度 检查 合格 后 ， 即 粒度 足够 大时 ， 就 对 FORK 与 JOIN 间 的 语句 形成 一个 并行 子 任务 对于 FORTRAN 和 C 等 过程 程序设计 语言 ， 子 任务 中 不仅 要 包含 FORK 标识符 与 JOIN 间 （ 不 包括 JOIN ） 的 所有 语句 及其 中 的 所有 子 过程 （ 相当于 C语言 中 的 函数 ， 下同 ） ， 还要 包括 FORK 前 的 所有 全局变量 全局变量 作用 于 所有 过程 ， 为 多个 过程 所 共享 当 将 原程序 分解 为 多个 可 并行 子 任务 时 ， 为 确保 生成 的 每个 模块 都 能 独立 编译 和 正确 执行 ， 必须 将 原程序 的 全局变量 作为 每个 子 任务 的 全局变量 已经 赋值 的 全局变量 还 需 代入 已 得到 的 值 ［ ］ 此外 ， 还要 在子 任务 中 加入 过程 定义 语句 ， 使 每个 子 任务 以 过程 形式 出现 而 对于 PROLOG 这样 的 逻辑 程序设计 语言 子 任务 中要 包含 整个 原程序 ， 派 生出 的 谓词 作为 提问 的 形式 出现 出于 简单 性 原因 ， 子 任务 间 不 允许 有 数据 依赖 ， 以 减少 机间 的 通信 进程 结构 　 　 在 PCSE 中 ， 我们 把 能够 派 生出 子 任务 的 进程 称做 顾客 进程 ， 不能 派 生出 子 任务 的 进程 称做 服务 进程 由于 派生 的 任务 要 有 粒度 控制 ， 因此 必须 对 顾客 进程 中 的 FORK 原语 做 粒度 检查 ， 如果 粒度 不够 FORK 将 不 被 执行 子 任务 也 不能 派生 所以 一个 顾客 进程 可能 会 变成 一个 服务 进程 在 用户 提交 任务 的 主机 上 运行 一个 主 进程 和 一个 中央 进程 主 进程 是 一个 顾客 进程 它 接受 用户 提交 的 任务 中央 进程 负责 任务分配 和 资源管理 当 FORK 被 执行 时 它 向 中央 进程 请求 要 远程 执行 一个 进程 中央 进程 将 为 其 选择 一个 空闲 处理机 如果 没有 空闲 处理机 ， 中央 进程 则 将 该 请求 送入 任务 队列 中 排队 中央 进程 内 维持 着 一个 任务 队列 、 一个 空闲 处理机 表 、 一个 进程 阻塞 表 和 一个 顾客 进程 表 任务 队列 存放 等待 执行 的 并行任务 ； 空闲 处理机 表 记录 可用 的 空闲 处理机 其 初始值 由 用户 指定 ； 进程 阻塞 表中 记录 被 JOIN 原语 阻塞 的 进程 ； 顾客 进程 表中 记录 所有 未 完 的 顾客 进程 的 进程 号 、 所在 处理机 的 名字 、 已 收到 结果 的 个数 以及 结果 的 存放 地 由于 PCSE 实现 了 嵌套 的 进程 派生 ， 即 一个 顾客 进程 可能 再 派 生出 另 一个 或 多个 顾客 进程 ， 因此 ， 为了 分清 进程 间 的 父子关系 PCSE 赋予 每个 进程 一个 全局 唯一 的 任务 号 ， 用 数字 表示 主 进程 接受 的 用户 任务 作为 一级 任务 ， 任务 号 为 ； 由 它 派生 的 任务 作为 二级 任务 任务 号 为 等 二级 任务 派生 的 任务 作为 三级 任务 任务 号 为 三位数 ， 即 ， 依此类推 串行 任务 保持 其原 任务 号 不变 去掉 一个 任务 号 的 最末 一位 ， 即可 知道 其父 任务 是 谁 了 　 　 此外 ， 每台 处理机 上 还 运行 一个 调度员 ， 它 负责 收集 所在 处理机 上 的 CPU 状态 ， 一旦 发现 CPU 空闲 ， 即刻 向 中央 进程 报告 ， 中央 进程 将 向 其 派送 任务 队列 中 的 首 任务 ； 如果 任务 队列 已空 ， 中央 进程 则 相应 修改 其 空闲 处理机 表 　 　 每台 主机 上 最 多 运行 个 顾客 进程 由于 顾客 进程 可能 中途 受阻 ， 为了 让 其他 进程 占用 空闲 的 CPU 资源 ， 中央 进程 还会 在 其 所在 的 处理机 上 启动 新 的 顾客 进程 然而 ， 顾客 进程 随时 可能 被 唤醒 ， 从而 导致 多个 进程 争用 CPU ， 使 系统 性能 变坏 所以 ， PCSE 对 进程 数 规定 了 上限 进程 通信 　 　 PCSE 允许 嵌套 派生 ， 即 一个 FORKJOIN 对 之间 还 可能 存在 FORKJOIN 对 因此 ， 一个 顾客 进程 创建 后 ， 还 不能 马上 执行 其后 接受 的 任务 ， 而 必须 检查 其中 的 FORKJOIN 语句 具体 过程 如下 （ 设 顾客 进程 为 P ） ： 　 　 如果 任务 中 没有 FORK 和 JOIN 对 ， P 将 变为 服务 进程 ， 其上 任务 经 编译 、 链接 形成 目标 码后 作为 串行 任务 本地 执行 　 　 如果 遇到 FORK 原语 ， P 先 将 此 FORK 之前 未 执行 的 语句 形成 串行 任务 本地 执行 ， 然后 对 FORK 进行 粒度 检查 若 粒度 不够 ， 则 将 此 FORKJOIN 对 去除 后 ， P 继续 对 后续 语句 进行 预 编译 否则 ， 生成 一个 并行 子 任务 ， 向 中央 进程 发送 处理机 请求 信号 中央 进程 首先 将 P 加入 顾客 进程 表中 ， 然后 为 其 寻找 空闲 机 如果 找到 ， 中央 进程 向 P 回送 任务 号 和 空闲 处理机 的 名字 同时 在 空闲 处理机 上 启动 一个 新 的 顾客 进程 ， P 将子 任务 送给 新 的 顾客 进程 如果 未找到 ， 中央 进程 则 向 P 回送 忙碌 信号 子 任务 被 送往 任务 队列 同 一级 的 FORK 全部 处理 完后 P 继续 作为 顾客 进程 执行 自己 保留 的 并行任务 中 的 最后 一个 　 　 服务 进程 得到 结果 后 ， 进程 结束 如果 是 号 任务 ， 则 结果 送给 用户 ； 否则 ， 结果 送给 中央 进程 中央 进程 修改 顾客 进程 表并 检查 相应 顾客 进程 的 并行 子 任务 结果 是否 到 齐 如果 到 齐且 此 顾客 进程 又 在 阻塞 表中 ， 中央 进程 则 向 其 发送 唤醒 信息 ， 将 其 激活 ， 同时 删除 顾客 进程 表 和 进程 阻塞 表中 的 对应 项 　 　 顾客 进程 执行 完 自己 保留 的 并行任务 后 ， 将 遇到 JOIN 原语 此时 顾客 进程 向 中央 进程 发送 结果 请求 信息 如果 同级 并行任务 的 结果 全部 得出 ， 则 顾客 进程 通过 JOIN ， 继续 对 后续 任务 进行 预 编译 ； 否则 ， 进入 阻塞状态 直到 中央 进程 将 其 激活 每个 顾客 进程 最终 都 会 变成 服务 进程 而 得到 结果 实例 测试 　 　 我们 使用 了 个 例子 来 测试 我们 所 实现 的 并行计算 支撑 环境 PCSE 的 性能 实验 环境 是 Mbps 以太网 连接 的 台 SUN 工作站 初始状态 为 每个 处理机 上 运行 个 调度员 ， 主机 上 还 运行 个主 进程 和 个 中央 进程 主 进程 在 等待 用户 任务 　 　 前 两个 例子 是 用 PROLOG 语言 编写 的 斐 波纳契 数 求解 程序 与 梵塔 问题 处理程序 这 两个 例子 都 包含 递归 关系 且 并行 粒度 极高 ， 所以 系统 性能 良好 第 和 第个 例子 是 用 FORTRAN 编写 的 重磁 资料 转换 程序 GMPS 和 Vlasov 方程 求解 程序 VLAS 这 两个 程序 来自 实际 应用 GMPS 利用 位场 频率 域 处理 原理 实现 重磁 异常 处理 整个 处理过程 包括 原始数据 的 扩充 、 二维 正 傅立叶 变换 、 频率 域 位场 异常 转换 处理 和 二维 反 傅立叶 变换 其中 二维 正 、 反 傅立叶 变换 都 可 进行 并行 化 处理 频率 域 位场 转换 处理 也 可 部分 并行 VLAS 使用 蒙特卡洛 试验 粒子 方法 求解 Vlasov 方程 程序 的 核心 部分 是 密度 计算 ， 这部分 也 是 最 费时 的 我们 将 该 部分 划分 为 多个 独立 的 子 部分 并 在 PCSE 上 进行 了 并行计算 最后 一个 例子 是 用 C语言 编写 的 矩阵 乘 计算 程序 MULT 矩阵 规模 为 选择 此例 的 目的 是 观察 系统 开销 对系统 性能 的 影响 采用 并行计算 后 ， 本 系统 引入 了 一些 额外 的 开销 其中 最大 的 开销 是 在 各 处理机 上 启动 顾客 进程 所 需 的 时间 ， 该 时间 值 大约 为 s 其次 是 预 编译 时间 ， 该 时间 随 程序 长度 的 不同 而 不同 在 以上 个 例子 中 最长 的 是 GMPS 的 s 此外 子 任务 、 结果 、 控制 信号 在 网络 上 的 传递 以及 结果 的 重定向 等 操作 也 需 花费 一定 的 时间 ， 不过 ， 这些 时间 并 不长 ， 在 某些 情况 下 可 忽略不计 由于 MULT 的 执行 时间 短 ， 额外 开销 占 的 比例 较大 ， 因此 系统 性能 较差 表 给出 了 实验 结果 其中 ， 加速 比 被 定义 为 单机 运行 时间 与 多机 运行 时间 的 比值 表 不同 系统 规模 下 各 测试程序 的 加速 比 加速 比 处理机 个数 测试程序 FIBHANOIGMPSVLASMULT 结论 　 　 实验 结果表明 ， 我们 所 实现 的 并行计算 支撑 系统 是 可行 的 在 没有 增加 用户 太 大 负担 的 情况 下 ， 使 用户 的 应用程序 在 并行计算 中 赢得 了 速度 但 系统 仍 有 一些 不足之处 预 编译 部分 还 需 优化 ， 以 缩短 其 开销 FORK 和 JOIN 语义 还 需 扩大 ， 以使 更 多 种类 的 程序 如 PASCALLISP 等 能够 在 PCSE 上 运行 本文 研究 得到 国家自然科学基金 资助 作者 介绍 ： 陶杰 女 ， 年生 ， 副教授 ， 主要 研究 领域 为 分布 计算 系统 　 　 　 　 　 鞠九滨 年生 ， 教授 ， 博士生 导师 ， 主要 研究 领域 为 分布 计算 系统 ， 计算机网络 本文 通讯联系 人陶杰 ， 长春 ， 吉林大学 计算机科学 系 作者 单位 ： 陶 　 杰 　 鞠九滨 　 吉林大学 计算机科学 系 　 长春 　 参考文献 　 ［ ］ CarltonMRoyRVAdistributedPrologsystemwithandparallelismIEEESoftware ～ 　 ［ ］ TaoJieJuJiubinExecutingPrologprogramsinparallelonnetworkworkstationChineseJournalofAdvancedSoftwareResearch ～ 　 ［ ］ TianLaishengHuangLianshuTaoJieTheimplementationofDCinalooselycoupleddistributedenvironmentChineseJournalofAdvancedSoftwareResearch ～ 本文 收到 原稿 ， 收到 修改稿
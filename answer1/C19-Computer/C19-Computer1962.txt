微型机 与 应用 MICROCOMPUTERITSAPPLICATIONS 年 第卷 第期 VolNoFoxProforWindows 环境 下 与 单片机 串行 通信 的 实现 周卫平 　 周斌 　 　 摘 　 要 ： 在 FoxProforWindows 环境 下 ， PC机 与 单片机 之间 进行 串行 通信 时 的 硬件 接口 设计 及 软件 实现 方法 。 　 　 关键词 ： 串行 通信 　 单片机 　 FoxProforWindows 　 应用程序 编程 接口 　 　 单片机 因 其 自身 的 优点 ， 在 嵌入式 过程 控制 、 自动化 仪器仪表 、 数据 采集 和 处理 、 计算机系统 外设 等 方面 已 得到 广泛应用 。 利用 FoxProforWindows 提供 的 API 库 FOXTOOLSFLL 访问 Windows 的 特殊 功能 ， 可以 在 FoxProforWindows 语言 环境 下 直接 实现 和 其它 计算机 的 通信 。 　 硬件 接口 电路 　 　 接口 电路 结构 如图 。 PC机 和 单片机 间 是 一对一 连接 ， 采用 RS — C 全双工 串行 通信 方式 。 与 PC机 串行口 连接 的 是 芯 D 型 插座 ， 其 所有 引脚 的 定义 及 对应 的 信号 电 平均 按照 RS — C 标准规定 连接 和 设计 。 本 设计 中 只 使用 其中 的 根 信号线 ： 发送数据 TXD ， 接收数据 RXD 和 信号 地 GND 。 图 　 PC机 与 单片机 之间 串行接口 硬件 结构图 　 　 RS — C 标准接口 的 输入输出 信号 电平 为 EIA 电平 ： 即 对于 输入 信号 ， 逻辑 “ ” 为 ～ V 通常 用 V ， 逻辑 “ ” 为 ～ V 通常 用 V 。 对于 输出 信号 ， 逻辑 “ ” 为 ～ V 通常 用 V ， 逻辑 “ ” 为 ～ V 通常 用 V 。 由于 一般 单片机 应用 电路 的 输入输出 信号 电平 为 CMOS 或 TTL 电平 ， 因此 ， 为了 实现 RS — C 方式 下 PC机 与 单片机 之间 输入输出 信号 电平 的 匹配 ， 在 RS — C 接口 和 单片 微处理机 的 串行口 之间 ， 用 MAX 来 实现 EIA 电平 与 CMOSTTL 电平 之间 的 相互 转换 。 MAX 是 V 单 电源 供电 ， 内部 使用 升压 电路 和 极性 转换 电路 获得 EIA 正负 逻辑 电平 ， 省略 了 V 和 V 组 电源 。 　 串行 通信 的 软件 实现 方法 　 　 PC机 和 单片机 之间 要 实现 串行 通信 ， 除要 遵守 RS — C 串行 通信协议 外 ， 还 必须 具有 各自 的 通信 应用软件 。 虽 不同 的 单片机 系统 ， 使用 不同 的 汇编语言 编制 其 应用程序 ， 但 通信软件 的 设计 思路 是 一样 的 ： 即 PC机 为 主动 方式 ， 单片机 根据 PC机 发来 的 命令 ， 判断 是 要求 发送 还是 接收数据 。 若 是 发送 命令 ， 则 准备 好 所 需 数据 和 校验码 ， 分别 填入 串行 缓冲器 发送给 PC机 ， 然后 读取 PC机 送来 的 返回 码 ， 若 是 错误码 ， 则 需 重新 发送数据 。 若 是 接收 命令 ， 则 将 PC机 发送到 串行 缓冲器 中 的 数据 取出 后 存放 到 一 固定 存储 区内 。 若 接收数据 有 错 ， 则 发一 错误码 给 PC机 ， 然后 重复 刚才 的 接收 过程 。 这里 需注意 单片机 和 PC机 校验 数据 的 方法 要 一致 。 下面 详细 介绍 PC机 上 通信软件 的 实现 方法 。 　 　 FoxProforWindows 应用程序 要 实现 与 单片机 应用程序 之间 的 数据 传递 ， 必须 利用 其 API 库函数 注册 并 运行 WindowsDLL 通信 函数 来 访问 串行口 。 FLLFoxLinkLibrary 文件 是 API 使用 的 外部 连接 库 的 形式 ， 它 实际上 也 是 个 WindowsDLLDynamicLinkLibrary 文件 ， 允许 FoxProforWindows 与 用 CC 或 汇编语言 编写 的 程序接口 。 用户 也 可 将 自己 编写 的 一些 功能 函数 放入 自定义 的 FLL 库中 。 FOXTOOLSFLL 是 由 FoxProforWindows 提供 的 API 库 。 安装 FoxProforWindows 时 已 将 其 放入 ＼ FOXPROW 子目录 中 。 FOXTOOLSFLL 提供 了 对 不同 的 Windows 函数 的 访问 。 在 编写 FoxProforWindows 通信 程序 时 ， 首先 用 以下 命令 装入 该库 ： 　 　 SETLIBRARYTOSYS “ FOXTOOLSFLL ” ADDITIVE 其中 ， SYS 返回 FoxProforWindows 启动 目录 的 名称 ， 加入 ADDTIVE 可 保证 任何 以前 装入 的 库 有效 。 　 　 用 下面 的 命令 可 取消 FOXTOOLSFLL 库 ： 　 　 RELEASELIBRARYSYS “ FOXTOOLSFLL ” 　 　 装入 FOXTOOLSFLL 库后 ， 就 可以 开始 使用 该库 中 的 Regfn 函数 来 注册 要 访问 的 Windows 通信 函数 。 Regfn 函数 允许 用户 调用 WindowsDLL 中 的 函数 。 DLL 允许 输入 下列 数据类型 ： 整型 I 、 长 整数 L 、 浮点 F 、 双 精度 D 、 字符串 C ， 也 允许 返回 上述 数据类型 。 注册 个 WindowsDLL 函数 和 它 的 参数 的 函数 格式 为 ： 　 　 myfunRegfnWinfunctionArgtypesRtntype 其中 Winfunction 是 要 访问 的 WindowsDLL 函数 名 。 Argtypes 是 必须 传递 给 它 的 各 参数 类型 代码 ， 例如 要 传递 给 函数 的 参数 类型 为 整型 、 整型 、 浮点 型 、 字符 型 时 ， 则 Argtypes 为 “ IIFC ” ； 可 使用 引用 方式 或 数值 方式 来 传递 参数 ， 当 使用 引用 传递 参数 时 ， 参数 类型 前要 放 标志 ， 该 参数 被 作为 指向 缓冲区 的 指针 。 Rtntype 是 该 DLL 函数 返回值 的 数据类型 。 如果 注册 成功 ， Regfn 函数 返回 个 数字型 值 给 myfun ； 如果 注册 失败 ， 则 返回 。 　 　 在 用 Regfn 注册 WindowsDLL 通信 函数 成功 后 ， 接下来 的 工作 是 用 Callfn 函数调用 它 ， 以 执行 这个 已 注册 的 函数 。 调用 格式 如下 ： 　 　 myretCallfnmyfunpmpm … 其中 myfun 就是 已 注册 函数 的 数值 句柄 ， pm 、 pm 等 是 要 传递 给 WindowsDLL 函数 的 各 参数值 ， 参数 个数 随 访问 的 DLL 函数 而变 。 各 参数 次序 和 类型 必须 严格 按照 DLL 函数 规定 的 要求 传递 ， 否则 将 引起 调用 失败 。 如果 Callfn 调用 成功 ， 变量 myret 的 内容 就是 WindowsDLL 函数 的 返回值 ， 它 带有 Rtntype 参数 指定 的 数据类型 。 　 应用 实例 　 　 这个 实例 的 目的 是 利用 上面 介绍 的 方法 ， 注册 通信 中要 访问 的 WindowsDLL 库中 的 函数 ， 然后 根据 实现 通信 的 各 步骤 ， 执行 这些 注册 函数 。 要 实现 FoxProforWindows 环境 下 的 串行 通信 ， 必须 包括 以下 步骤 ： 打开 要 访问 的 串行 端口 ； 对 串行口 初始化 ； 根据 通信 要求 发送 或 接收数据 ； 关闭 串行 端口 。 下面 是 用 FoxProforWindows 语言 编制 的 请求 单片机 发送数据 的 串行 通信 子程序 Subcompag ： PROCEDURESubcomPRIVATELpmodeLpreadnummrlMCOMDIMENSIONacr 装入 FOXTOOLSFLL 库 文件 SETLIBRARYTOSYS “ FOXTOOLSFLLADDITIVE 初始化 通信协议 ： 通信 端口 为 COM ， 波特率 为 ， 没用 奇偶校验 方式 ， 位 数据位 ， 位 停止 位 。 Commmode “ COM “ “ N “ “ LpmodeREPLICATECHR 初始化 设备 控制 块 DCB 结构 为 LpreadREPLICATECHR 初始化 接收 队 列为 空 ， 长度 B 注册 WindowsDLL 通信 函数 buildcommDCBRegfn “ BuildCommDCB “ CC “ IopencommRegfn “ OpenComm “ CII “ IsetcommstateRegfn “ SetCommState “ C “ IreadcommRegfn “ ReadComm “ ICI “ IwritecommRegfn “ WriteComm “ ICI “ IclosecommRegfn “ CloseComm “ I “ IclearcommRegfn “ GetCommError “ IC “ I 初始化 COM 通信 端口 Callfnbuildcommdcbcommmodelpmode 建立 Windows 可 接受 的 通信 方式 COMCallfnopencomm “ COM 打开 COM 通信 口 IFCOM 　 WAITWINDOW “ 打开 通信 口 失败 ， 退出 后重 引导 timeout 　 CallfnclosecommCOM 　 　 关闭 COM 口 　 returnENDIFMCallfnsetcommstatelpmode 　 　 设置 通信 方式 　 IFM 　 　 　 WAITWINDOW “ 设置 通信 方式 失败 ， 退出 后重 引导 timeout 　 　 　 CallfnclosecommCOM 　 　 　 return 　 ENDIF 对 通信 口 进行 读写操作 　 　 morderCHR 　 　 发 请求 取 数据 命令 　 　 MCallfnwritecommCOMmorderLENmorder 　 　 　 IFM 　 　 　 WAITWINDOW “ 请求 失败 ， 退出 后重 引导 timeout 　 　 　 CallfnclearcommCOMNULL 通信 失败 ， 清除 端口 　 　 　 CallfnclosecommCOM 　 　 释放 缓冲区 　 　 　 　 return 　 　 ENDIF 　 num 　 MCallfnreadcommCOMlpreadnum 读 num 个 字节 入 缓冲区 　 　 IFM 　 　 　 WAITWINDOW “ 读数据 失败 ， 退出 后重 引导 timeout 　 　 　 CallfnclearcommCOMNULL 　 　 　 CallfnclosecommCOM 　 　 　 return 　 　 ENDIF 显示 接收 到 的 数据 　 　 FORitonumdijintimsiotempsubstrlpreadiacriASCSUBSTRlpreadijdsayacriFONTFIXEDSYS 　 　 ENDFOR 通信 结束 CallfnclosecommCOMRELEASELIBRARYSYSFOXTOOLSFLLWAITWINDOW 通信 已 结束 NOWAITRETURN 关于 WindowsDLL 通信 函数 及其 参数 的 具体 意义 ， 请参阅 有关 WindowsAPI 手册 。 作者 单位 ： 南京市 东南大学 热能 所 收稿 日期 ：
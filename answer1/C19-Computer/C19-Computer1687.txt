软件 学报 JOURNALOFSOFTWARE 　 Vol 　 No 　 P 一种 支持 多重 循环 软件 流水 的 寄存器 结构 容红波 　 汤志忠 摘要 　 寄存器 结构 及其 分配 是 软件 流水 算法 的 关键 之一 为 支持 多重 循环 的 软件 流水 该文 提出 一种 新颖 的 寄存器 结构 ： 半 共享 跳跃式 流水 寄存器 堆 它 可以 有效 地 解决 多重 循环 软件 流水 下 的 特殊 问题 即 ： 同 层次 和 跨 层次 的 寄存器 重命名 问题 以及 断流 问题 ； 有效 地 消除 外层 循环 的 体间 读写 相关 提高 程序 的 指令 级 并行度 它 有种 分配 方式 可 供 灵活 使用 ： 单个 寄存器 、 流水 寄存器 和 寄存器 组 方式 流水 寄存器 方式 对 生存期 确定 的 、 局限于 一个 循环 层次 的 寄存器 重命名 问题 提供 简单 而 有效 的 支持 寄存器 组 分配 方式 解决 了 多重 循环 软件 流水 时 变量 生存期 不 确定 的 情况 跳跃 操作 为 解决 断流 问题 提供 了 快速 数据 传送 工程 实践 表明 这种 寄存器 堆 结构 及其 分配 方式 是 十分 有效 的 关键词 　 指令 级 并行 寄存器 堆 流水 寄存器 数据 相关 ， 软件 流水 中图法 分类号 　 TPANovelRegisterFileStructureSupportingforSoftwarePipeliningofNestedLoopsRONGHongbo 　 TANGZhizhongDepartmentofComputerScienceandTechnologyTsinghuaUniversityBeijing 　 Abstract 　 ThestructureandallocationoftheregisterfileisakeyfactoraffectingtheperformanceofsoftwarepipeliningTosupportsoftwarepipeliningofnestedloopsanovelregisterfilepartlysharedleapingpipelineregisterfileispresentedanditsallocationisdiscussedTheregisterfileeffectivelyaddressesthespecialproblemsinsoftwarepipeliningnestedloopsieintraandinterlevelregisterrenaminganditerationdiscontinuityThreeallocationstylesaredesignedforflexibleapplicationsinglepipelineandgrouperegisterstylesPipelineregisterseffectivelysupportsintralevelregisterrenamingwithdeterministiclifetimeAvariablewhichgenerallyhasdeterministiclifetimemayhavenondeterministiclifetimeinsoftwarepipeliningnestedloopsGroupregistersaddresssuchaproblemTomakeapausediterationcontinueexecutionagainaleapingoperationprovidesquickdatatransmissionbetweenregistersTheengineeringpracticehasprovedtheefficiencyofthestructureanditsallocationmethodKeywords 　 InstructionLevelparallelismregisterfilepipelineregisterdatadependencesoftwarepipelining 　 　 指令 级 并行 ILP （ instructionlevelparallelism ） 是 当前 国际 上 的 研究 热点 VLIW 体系结构 下 的 软件 流水 问题 吸收 了 学者 们 的 许多 精力 从 资源管理 的 角度看 一个 软件 流水 算法 要 解决 两个 问题 ： （ ） 在 某 时刻 将 功能 部件 分配 给 操作 ； （ ） 在 某 时刻 将 寄存器 分配 给 变量 通常 算法 对 功能 部件 不 作 特殊要求 但 对 寄存器 结构 一般 要 专门 设计 以便 互相配合 从而 最 有效 地 实现 算法 寄存器 结构 及其 分配 直接 影响 到 整个 机器 的 性能 因此 这是 软件 流水 算法 的 关键 之一 　 　 目前 国际 上 有 多种 软件 流水 算法 ［ ～ ］ 主要 是 针对 单重 循环 的 对 多重 循环 一般 只 对 最 内层 循环 进行 流水 对 外层 循环 串行 执行 ILSP （ interlacedinnerandouterloopsoftwarepipelining ） 算法 ［ ］ 采用 内 外层 循环 交替 执行 方式 比较 成功 地 解决 了 多重 循环 的 软件 流水 问题 本文 探讨 其 寄存器 结构 　 　 ILSP 算法 提出 了 一种 新颖 的 寄存器 结构 ： 半 共享 跳跃式 流水 寄存器 堆 它 可以 高效 地 实现 功能 部件 （ functionunit ， 简称 FU ） 之间 的 通信 在 算法 消除 循环 程序 的 所有 体内 数据 相关 、 所有 内层 循环体 间 数据 相关 的 基础 上 由 寄存器 分配 消除 外层 循环 的 体间 读写 相关 在 操作 调度 中 只要 遵守 外层 的 体间 写 读 相关 即可 从而 大幅度提高 程序 的 指令 级 并行度 　 　 由于 寄存器 的 分配 与 算法 密切关系 下面 首先 回顾 一下 ILSP 算法 然后 讨论 其中 的 寄存器 分配 问题 ILSP 算法 的 简单 回顾 　 　 统计数字 表明 对于 典型 的 工程 和 科学计算 程序 大部分 时间 都 消耗 在 内层 循环 上 ［ ］ 因此 当前 的 各种 软件 流水 算法 都 致力于 对 最 内层 循环 进行 流水 但是 我们 发现 这样 做 并非 总是 合理 的 　 　 图中 的 有 向 线段 表示 写读 相关 若 从 最 内层 的 J 循环 进行 流水 则 循环 启动 间距 II （ initiationinterval ， 简称 II ） 为 每 两个 周期 执行 一个 J 循环 （ 如图 （ b ） 所示 ） 若 从 最 外层 的 I 循环 进行 流水 则 II 为 每 一个 周期 执行 一个 J 循环 不仅 II 小 而且 J 循环 执行 周期 也 短 （ 如图 （ c ） 所示 ） Fig 　 Comparisonbetweenalgorithms 图 　 算法 比较 　 　 注意 到 ILSP 是从 最 外层 的 I 循环 开始 进行 流水 的 但 依然 找到 了 J 循环 的 重复 模式 因此 我们 是 先 从 外层 循环 进行 流水 在 发现 内层 循环 的 重复 模式 后 转入 内层 循环 的 流水 ； 执行 完 内层 循环 后 再 转回 外层 继续 流水 反复 这个 外 → 内 → 外 的 过程 直到 整个 程序执行 完 　 　 因此 对 一个 多重 循环 不 一定 非要 从 最 内层 循环 开始 流水 不可 而是 可以 选择 一个 最佳 层次 开始 流水 产生 一个 内 外层 交错 流水 的 方案 选择 标准 将 另文 讨论 本文 假定 从 最 外层 开始 流水 凡是 “ 外层 ” 都 指 最 外层 数据 寄存器 结构 　 　 目前 主要 的 数据 寄存器 结构 有 以下 几种 　 　 （ ） 全局 共享 寄存器 堆 ［ ～ ］ 所有 寄存器 被 所有 功能 部件 及其 内存 共享 其 硬件 结构复杂 每个 寄存器 的 输入 、 输出 端口 很多 可扩展性 有限 但 它 对 编译 的 支持 比较 好 　 　 （ ） 局部 寄存器 堆 ［ ］ 各 FU 只能 访问 属于 本 FU 的 局部 寄存器 通过 互连网 或 共享存储器 来 通信 硬件 结构 最 简单 　 　 （ ） 寄存器 通道 ［ ］ 在 局部 寄存器 堆 的 基础 上 在 各 FU 的 局部 寄存器 之间 提供 少量 几条 数据通道 　 　 （ ） 流水 寄存器 堆 ［ ］ 每个 FU 的 所有 局部 寄存器 按 顺序 排成 一个 队列 称为 垂直 流水 各 FU 的 垂直 流水线 之间 建立 若干 通道 称为 水平 流水 整个 寄存器 堆 像 一个 矩阵 网格 水平 流水 主要 用于 FU 之间 的 通信 垂直 流水 用于 寄存器 重命名 　 　 （ ） 半 共享 寄存器 堆 ［ ］ 又 分为 写 共享 （ 写 全局 读 局部 ） 和 读 共享 （ 读 全局 写 局部 ） 两种 这是 全局 共享 寄存器 堆 和 局部 寄存器 堆 的 一个 折衷 读 共享 对 编译 的 支持 比较 好 但 硬件 相对 复杂 　 　 我们 综合 了 各种 结构 的 优点 提出 半 共享 跳跃式 流水 寄存器 堆 它 是 读 全局 写 局部 的 并且 各 FU 的 局部 寄存器 组织 成 流水 但是 增加 了 任意 两个 寄存器 之间 数据 传送 的 功能 　 　 如图所示 每个 功能 部件 FU 都 有 一条 属于 自己 的 局部 寄存器 流水线 所有 FU 的 寄存器 流水线 形成 整个 寄存器 堆 流水 方向 为 Ri → Ri → → Rinim 采用 流水 方式 组织 寄存器 可以 简单 、 自然 地 解决 不同 循环体 之间 的 寄存器 重命名 问题 并 有助于 生成 高效 代码 Fig 　 PartlySharedleapingpipelineregisterfile 图 　 半 共享 跳跃式 流水 寄存器 堆 　 　 半 共享 的 含义 是 各个 FU 可以 从 整个 寄存器 堆中 的 任何 一个 寄存器 读 但 只能 写入 属于 本 功能 部件 的 局部 寄存器 这样 可以 在 硬件 复杂度 较 小 的 情况 下 有效 地 支持 优化 编译 以及 各 FU 间 的 通信 　 　 跳跃 的 含义 是 寄存器 堆中 的 一个 寄存器 可以 向 另外 任何 一个 寄存器 直接 传送数据 这 就 打破 了 流水 寄存器 只能 在 所属 流水线 中 传送数据 的 惯例 这样 做 是 为了 解决 内 外层 循环 交错 执行 时 的 断流 问题 并 对 FU 间 的 数据 传送 提供 快速 支持 寄存器 分配 　 　 寄存器 分配 之后 根据 变量 （ 或 常数 ） 的 生存期 和 位置 的 不同 整个 堆 的 寄存器 被 分为 类 （ 或者说 该 寄存器 堆 有种 分配 方式 ） ： 　 　 （ ） 单个 寄存器 用于 存放 常数 和 生存期 小于 等于 循环 启动 间距 II 的 变量 常数 在 循环 执行 过程 中 不变 ； 生存期 小于 等于 II 的 变量 其 相应 寄存器 的 内容 不会 被 下 一个 循环体 的 内容 冲掉 因此 给 它们 分配 个 寄存器 即可 其 分配 方法 有 很多 ［ ］ 本文 不 作 讨论 　 　 （ ） 流水 寄存器 分配 给 生存期 大于 II ， 并且 局限于 个 循环 层次 的 变量 　 　 在 属于 某个 FU 的 一条 流水线 中为 该 变量 分配 两个 或 更 多个 前后 相连 的 寄存器 称为 流水 寄存器 流水 寄存器 属于 同一个 逻辑 变量 却 包含 有 多个 物理 寄存器 物理 寄存器 的 个数 就是 流水 寄存器 的 长度 　 　 设 流水 寄存器 为 Rij → Rij → → Rijll 是 其 长度 下面 定义 该 流水 寄存器 的 种 可用 操作 ① 写 操作 只能 向 第个 寄存器 Rij 写称 Rij 为 尾部 寄存器 ② 读 操作 可以 从 RijRijRijl 中 的 任何 一个 读 ③ 流水 操作 令 RijkRijkkll 也 就是 这个 队列 向前 流动 一个 节拍 队列 头 Rijl 的 内容 将 被 冲掉 　 　 （ ） 寄存器 组分 配给 生存期 超过 了 个 循环 层次 的 变量 　 　 即 那些 在 外层 循环 定义 在 内层 循环 引用 的 变量 ； 或者 在 内层 循环 定义 在 外层 循环 引用 的 变量 这是 多重 循环 流水 引出 的 特殊 问题 流水 寄存器 的 分配 　 　 在 通常 的 软件 流水 算法 下 最 内层 循环 是 并行 的 因此 要 消除 最 内层 循环 的 体间 读写 相关 但 在 ILSP 下 外层 循环 是 并行 的 导致 不同 外层 循环体 的 内层 循环 也 并行 因此 需要 消除 外层 循环 的 读写 相关 （ 包括 不同 外层 循环体 的 内层 循环 之间 的 相关 ） 流水 寄存器 的 分配 方式 实际上 是 通过 硬件 进行 寄存器 重命名 来 消除 这些 相关 流水 寄存器 只 分配 给 生存期 局限于 一个 循环 层次 的 变量 因此 下面 只以 单重 循环 为例 ， 所得 结果 对 从 外到 内 的 各重 循环 都 适用 　 相关 的 消除 　 　 对于 软件 流水 II 必须 大于 所有 变量 的 生存期 才能 保证 本 循环体 定义 的 变量值 不会 被 下 一 循环体 的 同一 变量 的 值 所 覆盖 　 　 变量 的 生存期 是 指 变量 的 最后 一次 引用 时刻 减去 它 的 定义 时刻 在 上 一条 指令 中 定义 紧接着 在 下 一条 指令 中 引用 的 变量 其 生存期 不足 一个 周期 认为 是 　 　 设图 （ a ） 中 所有 操作 的 执行 时间 为个 周期 由于 变量 TTT 的 生存期 分别 为 软件 流水 最好 的 结果 是 以 II 启动 变量 T 的 生存期 制约 了 II 　 　 为了 减小 II 如图 （ d ） 所示 在 源程序 中 插入 操作 s ′ T ′ ＝ T 则 数据 相关 图 变成 图 e 此时 所有 变量 TT ′ TT 的 生存期 为 （ 定义 后 立刻 作 最后 一次 引用 ） 所以 软件 流水 可以 II 启动 效率 提高 一倍 　 　 如果 为 T 和 T ′ 分配 的 是 某个 FU 局部 流水线 上 的 两个 相邻 寄存器 那么 操作 s ′ T ′ ＝ T 就是 流水 操作 对比 图 b 和 图 e 可以 看到 ， 从 s 到 s 的 体间 读写 相关 被 消除 了 　 流水 寄存器 的 长度 　 　 令 流水 寄存器 的 长度 为 l 则 l ［ 变量 的 生存期 II ］ （ ） 其中 II 是 指 在 只 考虑 体间 写 读 相关 的 情况 下 软件 流水 的 启动 间距 　 　 变量 的 生存期 通过 分析 源程序 中 的 写 读 相关 而 得到 假设 有 写 读 相关 OPi → OPjdd 为体 差 （ iterationdifferenceoriterationdistance ） 表示 X 号体 的 操作 OPi 对 某个 变量 A 赋值 Xd 号体 的 操作 OPj 对 A 引用 ， 则 这个 写读 相关 所 确定 的 A 的 生存期 为 tjdIItidelayOPi （ ） 其中 ti 和 tj 分别 表示 OPi 和 OPj 在 同一个 循环体 中 的 启动 时刻 delayOPi 是 指 OPi 的 执行 时间 列出 所有 与 变量 A 有关 的 写 读 相关 分别 算 出 生存期 取 最大者 即为 A 的 生存期 Fig 　 Eliminatingantidependency 图 　 消除 读写 相关 　 　 以图 中 的 变量 T 为例 在 只 考虑 体间 写 读 相关 的 情况 下 软件 流水 的 启动 间距 II 可以 为 由 源程序 （ 如图 （ a ） 所示 ） 中 的 写 读 相关 （ s → s ） （ s → s ） 根据 公式 得 T 的 生存期 分别 为取 最大者 则 T 的 生存期 为 即 T 被 定义 后 最 多 再 隔个 周期 就 会 被 消耗掉 由 公式 应给 T 分配 的 流水 寄存器 长度 为 ［ ］ 　 　 假设 Ti 表示 Ii 时 语句 s 对 T 的 赋值 且 流水 寄存器 为 Ryz → Ryz 则 当 I 时 将 T 写入 Ryz （ 如图 （ a ） 所示 ） I 时先 执行 流水 操作 将 T 送往 下 一个 寄存器 Ryz 再 将 T 写入 Ryz （ 如图 （ b ） 所示 ） 同样 地当 I 时先 执行 流水 操作 将 T 送往 下 一个 寄存器 Ryz 再 将 T 写入 Ryz 注意 ， 此时 T 的 生存期 已经 结束 所以 被 冲掉 了 （ 如图 （ c ） 所示 ） Fig 　 Theeffectofapipelineregister 图 　 　 流水 寄存器 的 作用 　 　 这样 在 变量 的 生存期 未 结束 以前 流水 寄存器 一直 保存 它 直至 其 生存期 结束 　 流水 寄存器 的 寻址 与 代码生成 　 　 一般 地 在 源程序 中 假设 关于 变量 A 有 写 读 相关 OPi → OPjd 且 流水 寄存器 的 尾部 寄存器 为 Ryz 则 OPi 访问 的 寄存器 为 Ryz ， OPj 访问 的 寄存器 为 Ryzk 其中 （ ） titj 是 OPiOPj 在 同一个 循环体 中 的 启动 时刻 ； delayOPi 是 OPi 的 执行 时间 　 　 在 生成 代码 时 每个 对 变量 进行 赋值 的 操作 之后 都 要 附加 流水 操作 　 　 例如 对于 图中 的 变量 T 由 源程序 （ 如图 （ a ） 所示 ） 中 的 写 读 相关 （ s → s ） 确定 s 中 的 T 应 访问 的 寄存器 为 Ryz ， 而 s 中 的 T 应 访问 的 寄存器 也 是 ； 由 （ s → s ） 确定 s 中 的 T 应 访问 的 寄存器 为 附加 流水 操作 后 的 等价 程序 如图 （ a ） 所示 生成 代码 如图 （ b ） 所示 对照 图 、 图和图 其 正确性 不难 分析 Fig 　 Pipelinedregisteraddressingandcodegeneation 图 　 　 流水 寄存 顺 的 寻址 与 代码生成 寄存器 组 的 分配 　 　 ILSP 是 一个 贪心 算法 只要 内层 循环 的 重复 模式 还 没有 出现 它 就 会 再启动 一个 外层 循环 这样 对于 跨 循环 变量 造成 了 两个 特殊 的 现象 即 变量 的 生存期 与 该 变量 属于 第几个 外层 循环体 有关 ； 变量 在 赋值 后 可能 长期 睡眠 　 　 如图所示 A 是 一个 跨 循环 变量 当 I 或时 A 的 生存期 为 也就是说 A 在 赋值 后 至多 再 过个 周期 就 会 被 最后 一次 引用 但 在 I 时 A 的 生存期 变得 不 确定 了 图 中用 圆圈 标出 了 I 时所 进行 的 操作 以 I 为 例外 层 循环 只 执行 了 操作 ss 之后 就 被迫 停止 因为 此时 发现 了 内层 循环 的 重复 模式 下面 将 转入 内层 循环 的 流水 ， 专门 执行 I 时 的 内层 循环 在 此 过程 中 I 时所 定义 的 那个 A 不 被 引用 处于 睡眠 状态 直到 I 的 内层 循环 中 任意 一个 不 满足 X ＞ Y 而 结束 时 才能 继续 I 时 的 其他 操作 这时 I 时所 定义 的 那个 A 才 苏醒过来 得到 引用 Fig 　 Nondeterministecsleepingperiodofavariable 图 　 变量 的 不定期 睡眠 　 　 由于 内层 是 一个 WHILE 循环 次数 不定 因此 难以确定 A 究竟 何时 苏醒 这样 I 时 A 的 生存期 是 不 确定 的 　 　 如果 为 A 分配 流水 寄存器 的话 按照 式 要 先 得到 A 的 生存期 但 这 是 可变 的 不能 确定 此时 无法 计算 流水 寄存器 的 长度 为 解决 这一 问题 需要 为 A 分配 寄存器 组 　 寄存器 组 的 分配 、 寻址 与 代码生成 　 　 在实践中 跨 循环 变量 的 数目 很少 因此 可 保守 地 假定 其 生存期 是 全局 的 并 为 其 分配 寄存器 组以 解决 上述 问题 　 　 设有 一个 跨 循环 变量 A 为 A 分配 一组 寄存器 RfizRfizRfiez 其中 e 是 寄存器 组 的 深度 它 也 是 同时 打开 的 外层 循环 的 个数 ； 单射 函数 fk 指出 第 k 号 循环 中 的 A 所 对应 的 寄存器 的 第个 下标 ； z 是 第个 下标 函数 f 保存 在 一张 硬件 表中 　 　 e 由下式 确定 ： （ ） 其中 外层 循环 长度 是 指 组成 外层 循环 的 所有 操作 的 个数 包括 内部 嵌套循环 的 操作 个数 （ 这 是因为 ， ILSP 算法 将 某 一层 循环 内部 的 所有 操作 都 看作 是 这 一层 的 操作 无论 是否 嵌套 有 其他 循环 ） 如图所示 外层 的 FOR 循环 共有 个 操作 ： sssss （ 包括 内部 WHILE 循环 的 个 操作 sss ） 因此 长度 为 则 即 寄存器 组 的 深度 为 或者说 同时 打开 了 个 外层 循环 　 　 寄存器 寻址 与 代码生成 十分 简单 ： 将 流水 结果 （ 如图 （ b ） 所示 ） 中 的 所有 变量 A 用 一个 统一 的 “ 假 ” 寄存器 名如 R 代替 即可 这个 寄存器 名 只有 一个 下标 所以 称为 “ 假 ” 寄存器 名 实际上 它 代表 Rfk 其中 k 是 循环体 号 由 一组 控制 寄存器 （ 称为 循环 控制 寄存器 组 ） 跟踪 保持 也就是说 每个 循环体 的 操作 都 隐含 知道 自己 究竟 属于 哪 个体 这样 虽然 所有 循环体 的 代码 是 相同 的 但是 经过 硬件 映射 后 当 I 时 A 分别 映射 到 了 不同 的 寄存器 RfRfRfRfRf 如果 定义 函数 f 为 ： fffff 则 A 分别 映射 到 了 RRRRR 　 　 这样 对于 图 （ b ） 不同 I 循环 中 的 A 映射 到 不同 的 寄存器 在 一次 I 循环 结束 前 它 将 保持 这一 映射 它 不 需要 考虑 变量 的 生存期 会 发生 不 确定 的 情况 而 完全 按 确定 的 情况 去 处理 因为 不同 循环体 的 A 不会 互相 覆盖 实际上 寄存器 组 方式 是 用 分配 一组 单个 寄存器 的 方法 来 实现 寄存器 重命名 的 但 它 为了 生成 统一 代码 使用 了 假 寄存器 名 和 映射 表 　 寄存器 组与 流水 寄存器 的 比较 　 　 寄存器 组和 流水 寄存器 在 逻辑 上 都 是 一个 寄存器 但 在 物理 上 却 包含 多个 寄存器 寄存器 组是 通用 方法 它 可以 代替 流水 寄存器 的 功能 但是 它 需要 硬件 表 保持 单射 函数 fk 以及 循环 控制 寄存器 组来 保持 循环体 号 这张 硬件 表 和 循环 控制 寄存器 组都 需要 动态 更新 　 　 流水 寄存器 可以 简单 、 自然 地 消除 体间 读写 相关 不 需要 其他 硬件 的 支持 但 它 仅限于 变量 的 生存期 确定 的 情况 　 关于 硬件 映射 表 和 ILSP 的 控制 　 　 ILSP 的 控制 机制 主要 包括 一个 循环 控制 寄存器 组 、 一个 系统 返回 堆栈 、 流水 控制器 、 外层 循环 的 装入 排空 控制器 和 内层 循环 的 断流 控制器 等 在 循环 运行 之前 由 编译 向 硬件 提供 这些 控制 信息 一旦 循环 进入 运行 则 硬件 会 利用 控制 信息 自动控制 循环 的 执行 并 同步 更新 自身 内容 因此 这样 不会 增加 循环 的 运行 时间 ， 或者说 开销 　 　 映射 表 如图所示 如果 VLIW 处理机 共有 n 个 功能 部件 那么 它 能 同时 执行 的 外层 循环 的 个 数最多 是 n 所以 映射 表 的 长度 定为 n 一般 地 n 取 已经 足够 了 从 假 寄存器 名到 真 寄存器 地址 的 映射 是 一个 简单 的 查表 过程 如图所示 Fig 　 Thehardwaremappingtableandtheloopcontrolregisterfile 图 　 硬件 映射 表 和 控制 寄存器 组 跳跃 操作 　 　 在 ILSP 算法 下 ， 特殊 的 “ 断流 ” 问题 要求 寄存器 堆中 的 任意 两个 寄存器 能 进行 数据 传送 而 不能 像 传统 的 流水 寄存器 堆 那样 仅 在 局部 流水线 中 传递数据 　 　 如图所示 个 外层 循环 I 的 内层 while 循环 在 同时 执行 设 I 时 的 那个 while 循环 因为 不 满足 X ＞ Y 而 停止 （ “ 断流 ” ） 那么 I 时 的 循环 已经 完成 此时 注意 到 I 的 那个 外层 循环 只 执行 了 s 和 s 其 内层 的 while 循环 尚未 执行 因此 应 将 它 的 内层 循环 补到 断流 的 功能 部件 上 继续执行 但是 由 s 所 定义 的 变量 A 位于 另 一个 功能 部件 的 局部 寄存器 中 这 给 将来 重新 定义 A 带来 了 困难 因为 我们 的 寄存器 堆 是 写 局部 的 所以 必须 将 A 从 那个 功能 部件 的 局部 寄存器 传到 断流 的 功能 部件 的 一个 局部 寄存器 中 这 就是 跳跃 操作 该 操作 发生 在 断流 时 　 　 跳跃 操作 支持 寄存器 间 的 快速 数据 传送 同时 它 还 对 循环 控制 寄存器 组 进行 调整 使 补到 断流 处 的 新 循环 体能 正常 运行 　 　 跳跃 操作 由 断流 控制器 控制 完成 过程 如下 ： 在 断流 发生 的 那个 时钟 周期 的 末尾 断流 控制器 发出 断流 信号 迫使 所有 FU 暂时 中断 运行 进入 等待 周期 ； 假设 数据 传送 是从 Ruv 到 Rxy 那么 断流 控制器 通知 FUx 首先 将 Ruv 的 值 读出 然后 再 写入 Rxy （ 注意 到 寄存器 堆 是 读 全局 写 局部 的 ） ； 调整 循环 控制 寄存器 组 的 参数 令 所有 FU 转入 正常 运行 状态 以上 过程 共 占用 两个 周期 实验 结果 　 　 我们 设计 完成 了 一个 指令 级 并行 体系结构 优化 编译器 和 体系结构 的 模拟系统 定义 寄存器 堆 的 大小 为 × （ 个 FU 每个 FU 有个 局部 寄存器 ） 分别 按 （ ） 全局 共享 寄存器 堆 （ 单个 寄存器 ） 分配 方式 运行 ILSP 算法 ； （ ） 同时 以 单个 寄存器 、 流水 寄存器 和 寄存器 组 分配 方式 运行 ILSP 算法 通过 实际 运行 一些 典型 的 多重 循环 得到 了 一些 重要 数据 节选 见表 Table 　 Partialexperimentalresults 表 　 部分 实验 结果 Program ① Totallooplevels ② Numberoftheoperationsintheouterloop ③ Numberoftheoperationsintheinnerloop ④ Cycles ′ ⑤ Cycles ″ CyclesSpeedup ⑥ Innerproduct ⑦ × Fibonaccisequence ⑧ × Matrixsum ⑨ × Matrixmulplification × Fandemonmatrix × Flower ～ 说明 ′ 按 全局 共享 寄存器 方式 运行 、 无 跳跃 操作 时 的 时钟 周期 数 Cyclesusingaglobalsharedregiserfileandwithouttheleapingoperation ″ 按种 寄存器 分配 方式 运行 、 有 跳跃 操作 时 的 时钟 周期 数 Cyclesusingthethreeregisterallocationstylesandwiththeleapingoperation 跳跃 操作 和 动态 更新 所 占 的 时钟 周期 数 Cyclesusedbyleapingoperationsanddynamicrefreshing ① 程序 名称 ② 循环 层数 ③ 外层 操作 个数 ④ 内层 操作 个数 ⑤ 时钟 周期 数 ⑥ 加速 比 ⑦ 向量 内积 ⑧ 裴波 那契 数列 ⑨ 矩阵 加法 ⑩ 矩阵 乘法 范 德蒙 矩阵 找 水仙花 数 　 　 从表中 可以 看出 采用 半 共享 跳跃式 流水 寄存器 堆 ILSP 算法 的 加速 比约 为 主要 原因 是 ： （ ） 用 硬件 方法 （ 流水 寄存器 和 寄存器 组 ） 消除 体间 读写 相关 避免 了 软件 对 寄存器 重命名 时 的 显式 数据 传送 以及 代码 不 统一 的 麻烦 从而 缩小 了 循环 启动 间距 和 代码 长度 ； （ ） 跳跃 操作 用 硬件 提供 断流 时 的 快速 数据 传送 以及 一系列 循环 控制 寄存器 的 更新 使 代码 无需 考虑 断流 问题 不仅 代码 紧凑 而且 断流 与 补流 之间 的 衔接 速度 很快 　 　 注 ： 每 执行 完 一次 外层 循环 就要 进行 一次 跳跃 操作 和 动态 更新 每次 占个 周期 因此 总 周期 数是 外层 循环 次数 的 倍 半 共享 跳跃式 流水 寄存器 堆 和 全局 共享 寄存器 堆 的 比较 　 　 半 共享 跳跃式 流水 寄存器 堆 是 对 全局 共享 寄存器 堆 的 简化 　 　 多个 功能 部件 的 并行 运行 使 寄存器 堆 的 组织 成为 一个 重要 问题 如果 采用 全局 共享 寄存器 堆堆 的 可扩展性 将 受到 极大 限制 因为 要 满足 每个 周期 每个 功能 部件 对 寄存器 堆 执行 的 两个 读 操作 和 一个 写 操作 读 端口 和 写 端口 的 数目 很多 译码 和 读写 速度 将会 受到 影响 　 　 但是 如果 将 全局 共享 的 寄存器 堆 划分 为 若干 相对 独立 的 部分 则 可扩展性 要 好得多 可以 有 许多 部分 但 每 部分 规模 都 较 小 进一步 将 每 部分 的 寄存器 串成 队列 可扩展性 就 进一步提高 了 因为 队列 无论 有 多长 相邻 两个 寄存器 间 的 传送速度 是 不受 影响 的 而 这 是 半 共享 跳跃式 流水 寄存器 堆 主要 的 数据 传送 方式 　 　 简言之 半 共享 跳跃式 流水 寄存器 堆 是 对 全局 共享 寄存器 堆 进行 划分 并 重新 组织 为 队列 在 编译 的 帮助 下 实现 数据 存取 局部 化 尽量减少 各 队列 之间 的 数据 传送 　 　 跳跃 操作 和 硬件 映射 表 确实 增加 了 硬件 复杂度 但是 这是 两种 简单 的 机制 复杂度 很 低 所以 比较而言 半 共享 跳跃式 流水 寄存器 堆 的 复杂度 要 比 全局 共享 寄存器 堆低 得 多 ， 而且 对 多重 循环 调度 的 支持 也 要 好 （ 见表 ） 结束语 　 　 内 外层 交错 流水 给 寄存器 分配 带来 了 特殊 的 问题 主要 是 同 层次 和 跨 层次 的 寄存器 重命名 问题 ， 以及 断流 问题 本文 对 这些 问题 进行 了 深入分析 提出 了 具有 普遍意义 的 寄存器 结构 和 分配 方法 从 工程 的 实际 结果 来看 这些 方法 是 十分 有效 的 本文 研究 得到 国家自然科学基金 No 资助 作者 容红波 年生 博士生 主要 研究 领域 为 计算机 并行 编译 体系结构 汤志忠 年生 教授 ， 博士生 导师 主要 研究 领域 为 计算机 并行算法 ， 并行 编译 技术 并行 体系结构 本文 通讯联系 人容 红波 北京 清华大学 计算机科学 与 技术 系 作者 单位 ： 容红波 清华大学 计算机科学 与 技术 系 　 北京 　 汤志忠 清华大学 计算机科学 与 技术 系 　 北京 　 参考文献 ， YuTTangZZZhangCHetalControlmechanismforsoftwarepipeliningonnestedloopInReginaSSedProceedingsoftheConferenceonAdvancesinParallelandDistributedComputingLosAlamitosIEEEComputerSocietyPress ～ ， LuoJunTangZhizhongZhangChihongetalAlgorithmtodataallocationinsoftwarepipeliningJournalofSoftware ～ 罗军 汤志忠张 赤红 等 软件 流水 中 的 一种 数据 分配 算法 软件 学报 ～ ， RauBRFisherJAInstructionlevelparallelprocessingHistoryoverviewandperspctiveJournalofSupercomputing ～ ， HwangKAdvancedComputerArchitectureParallelismSalabilityProgrammabilityNewYorkMcGrawHill ～ ， LamMSoftwarepipelininganefficientschedulingtechniqueforVLIWarchitecturesSIGPLANNotices ～ ， DuesterwaldEGuptaRSoffaMLRegisterpipelininganintegratedapproachtoregisterallocationforscalarandsubscriptedvariablesInKastensUPfahlerPedsProceedingsoftheCompilerConstructionthInternationalConferenceCCNewYorkSpringerVerlag ～ ， HoogerbruggeJCorporaalHRegisterfileportrequirementsoftransporttriggeredarchitecturesProfessionalEngineering ～ ， TangZhizhongWangLeiQianJiangSoftwarepipeliningonprogramwithcomplicatedloopsJournalofSoftware ～ 汤志忠 王雷 钱江 多重 循环 的 软件 流水 技术 软件 学报 ～ ， NewBurnCJHuangASShenJPetalBalancingfineandmediumgrainedparallelisminschedulingloopsfortheXIMDarchitectureArchitecturesandCompilationTechniquesforFineandMediumGrainParallelismANorthHollandElsevierSciencePublishers ～ ， SuBGWangJTangZZetalURPRasinglechipvliwarchitectureMicroprocessingandMicroprogramming ～ ， WenYuhongTheresearchanddesignofVLIWoptimizingcompilerbasedonGURPRglobalsoftwarepipeliningalgorithm ［ MSThesis ］ TsinghuaUniversity 温钰洪 基于 GURPR 全局 软件 流水 算法 的 VLIW 优化 编译器 的 研究 与 设计 ［ 硕士学位 论文 ］ 清华大学 本文 收到 原稿 收到 修改稿
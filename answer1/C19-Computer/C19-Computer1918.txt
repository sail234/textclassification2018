微型机 与 应用 MICROCOMPUTERITSAPPLICATIONS 　 Vol 　 No 　 PWindowsx 准 实时 通信 与 控制系统 设计 马 卫东 　 王志颖 摘要 ： 在 Windowsx 中 开发 设计 与 底层 硬件 有关 的 实时 、 准 实时 通信 与 控制 软件系统 的 方法 。 对 Windowsx 设备 驱动程序 VxD 编程 、 动态 连接 库 接口 、 Win 程序设计 、 任务调度 亦 进行 了 较为 深入 的 探讨 。 关键词 ： Windowsx 　 准 实时 通信 　 设备 驱动程序 　 事件 　 线程 　 任务调度 　 　 Windowsx 是 运行 在 及其 后继 产品 上 的 通用 桌面 计算机 图形用户界面 操作系统 。 它 支持 抢先 式 多任务 、 多线程 、 虚存 管理 、 局域网络 、 TCP ／ IP 协议 、 Internet 等 丰富 的 功能 ， 已 成为 应用 最 广泛 的 桌面操作系统 。 　 　 但 Windowsx 是 为 通用 桌面 计算机 设计 的 操作系统 ， 并 不是 为 实时 任务 设计 的 ， 因而 无法 通过 简便 的 程序设计 方法 直接 创建 实时 通信 与 控制 任务 。 由于 在 工业 、 交通 、 国防 等 许多 测控 部门 都 要求 进行 实时 任务 处理 ， 许多 原来 在 DOS 系统 开发 的 实时 任务 处理程序 亦 存在 如何 移植 到 WindowsX 平台 上来 或 重新 实现 的 问题 ， 本文 就 这些 问题 进行 了 探讨 。 Windowsx 操作系统 结构 简述 　 　 Windowsx 运行 在 x 保护模式 下 ， 其 操作系统 核心 代码 如 线程 调度 、 存储管理 、 设备 驱动 等 程序运行 在 拥有 特权 级 的 核心 态 Ring 级 ， 操作系统 的 其它 代码 如 GUI 程序 等 和 用户 进程 运行 在 用户 态 Ring 级 。 其 基本 结构 如图所示 。 图 Windowsx 操作系统 结构图 　 　 Windowsx 操作系统 能够 同时 运行 MS － DOS 程序 、 Win 程序 和 Win 程序 ， 彼此间 互不 干扰 ， 并发 执行 。 这里 建议 在 Windowsx 下 开发 应用程序 ， 首选 Win 程序 。 Windowsx 为 Win 应用程序 提供 了 位 高达 GB 的 全 线性 虚拟地址 空间 ， 这 对 一般 应用 来讲 提供 了 足够 大 的 可用内存 尽管 计算机 物理 内存 的 容量 在 一般 情况 下要 小得多 。 　 　 Windowsx 操作系统 由 其 核心 、 设备 驱动程序 和 大量 的 动态链接库 及 应用程序 组成 。 Windowsx 内核 与 设备 驱动程序 运行 在 保护模式 的 Ring 级 或 称为 核心 态 ， 而 一般 应用程序 与 动态链接库 运行 在 Ring 级 或 称为 用户 态 。 熟悉 保护模式 体系 的 人 都 知道 ， Ring 代码 不能 直接 调用 Ring 代码 。 Windowsx 给 Win 应用程序 调用 设备 驱动程序 提供 了 一个 标准 调用 ， 即用 设备 文件 句柄 和 硬件 设备 驱动程序 通信 。 设备 文件 句柄 通过 标准 WinAPI 调用 CreateFile ， 然后 可以 使用 ReadFile 与 WriteFile 从 设备 中 读写 内容 ， 使用 DeviceIoControl 控制 设备 驱动程序 的 具体操作 。 　 　 在 Windowsx 操作系统 中 与 硬件 设备 打交道 的 程序代码 必须 运行 在 核心 态 Ring 级 。 事实上 这些 代码 就是 Windowsx 中 的 设备 驱动程序 ， 运行 在 用户 态 Ring 级 的 代码 必须 通过 核心 态 Ring 级 代码 才能 访问 硬件 。 通常 即使 在 用户 态 Ring 级 执行 的 所谓 输入输出 指令 in ， out 等 实际上 也 隐含 调用 了 核心 态 Ring 级 代码 得以 执行 的 。 　 　 所以 ， 在 Windowsx 中 开发 设计 与 底层 硬件 有关 的 实时 通信 与 控制 软件系统 是 和 如何 构造 良好 性能 的 设备 驱动程序 息息相关 的 。 专用 的 实时 通信 与 控制 设备 驱动程序 当然 非常 高效 方便 ， 然而 其 编制 却是 非常 困难 复杂 的 。 事实上 ， 在 许多 测控 部门 并 不 要求 严格 的 实时控制 ， 而仅 需要 秒级 或 毫秒 级 的 响应 控制 时间 ， 这里 称之为 准 实时 通信 控制系统 。 对准 实时 通信 控制系统 有 一种 简便 有效 的 实现 途径 ， 即 构造 一个 标准 的 设备 驱动程序 VxD 及 一组 通信 控制 动态链接库 API ， 使得 对 设备 测控 代码 由 运行 在 用户 态 的 应用程序 完成 ， 保证 响应 时间 在 毫秒 级 。 准 实时 通信 与 控制 软件系统 设计 实现 原理 　 　 Windowsx 操作系统 是 以 线程 为 其 基本 调度 单位 ， 通常 以 ms 为 基本 时间 片 按 优先级 大小 对 线程 进行 调度 。 当 一个 进程 被 创建 的 同时 也 创建 了 个 主线 程 、 个 或 多个 从 线程 ， 每个 线程 必须 从 属于 一个 优先级 类 ， 并 指定 其 优先级 。 优先级 ～ 属于 IDLE ＿ PRIORITY ＿ CLASS 优先级 类 ， 为 IDLE 程序 如 屏幕 保护 进程 使用 ； 优先级 ～ 属于 NORMAL ＿ PRIORITY ＿ CLASS 优先级 类 ， 为 通常 应用程序 使用 ； 优先级 ～ 属于 HIGH ＿ PRIORITY ＿ CLASS 优先级 类 ， 为 内核 线程 使用 ； 优先级 ～ 属于 REALTIME ＿ PRIORITY ＿ CLASS 优先级 类 ， 为 实时 任务 使用 。 因此 ， 一个 优先级 中有 几个 级别 ， 包括 个 实时 级别 、 个 变量 级别 、 个 系统 级别 和 个 空闲 级别 。 　 　 Win 提供 了 若干种 同步 对象 如 临界 区 、 互斥 量 、 信号量 和 事件 ， 以便 让 线程 相互之间 能够 同步 。 通过 将 同步 对象 和 优先级 配合 使用 ， 可以 巧妙 地 设计 和 实现 多个 线程 的 并发 操作 ， 其中 有 一个 高 优先级 线程 时刻 准备 处理 外部 突发事件 ， 一旦 有 事件 到来 事件 由 底层 的 设备 驱动程序 激活 立刻 投入 运行 。 由于 Windowsx 支持 抢先 式 多任务 ， 拥有 较 高 优先级 的 线程 优先 投入 运行 ， 在 一个 分片 周围 内 ， 该 线程 即可 投入 运行 。 这样 就 实现 了 准 实时 通信 与 控制 ， 其 实现 原理 如图所示 。 图准 实时 通信 与 控制 实现 原理图 实现 途径 　 　 准 实时 通信 与 控制 的 实现 需要 解决 几个 关键问题 ， 如 线程 同步 调度 、 事件 同步 驱动 的 建立 、 应用层 与 核心 驱动程序 通信 、 设备 驱动程序 编制 、 如何 将 应用层 的 事件 对象 传递 给 设备 驱动程序 、 如何 在 设备 驱动程序 中 激活 事件 以便 使 等待 激励 事件 的 测控 线程 立刻 投入 运行 等等 。 在 WinSDK 与 WinDDK 中 可以 找到 相关 文档 解决 这些 难题 。 限于 篇幅 ， 下面 就 几个 关键问题 作些 讨论 。 事件 对象 与 线程 同步 　 　 一个 线程 使 自己 与 其它 线程 同步 的 方法 就是 使 自己 睡眠 。 在此之前 ， 它 必须 告诉 操作系统 一旦 有 什么 “ 特殊 事件 ” 发生 ， 它 必须 被 唤醒 以便 继续执行 。 操作系统 在 使 该 线程 睡眠 后 将 一直 监视 这一 “ 特殊 事件 ” 是否 发生 以及 何时 发生 ， 并 在 它 发生 时 唤醒 该 线程 并 使 线程 在 所有 就绪 状态 线程 中 按 优先级 调度 得以 继续执行 。 此时 ， 该 线程 就 使得 其 执行 与 事件 的 发生 取得 了 同步 。 在 Win 中 提供 了 几个 API 调用 以 实现 该 功能 ， 常用 的 有 如下 个 函数 ： 　 　 DWORD 　 WaitForSingleObjectHANDLEhHandle ， DWORDdwMilliseconds ； 　 　 DWORDWaitForMultipleObjectsDWORDnCount ， CONSTHANDLElpHandles ， BOOLfWaitAll ， DWORDdwMilliseconds ； 　 　 WaitForSingleObject 函数 的 第一个 参数 为 同步 对象 句柄 ； 第二个 参数 为 等待时间 ， 通常 为 INFINITE 。 这里 使用 事件 对象 作为 同步 对象 。 事件 一般 使用 CreateEvent 函数 创建 ， 可以 采用 全局 唯一 的 有名 事件 或 进程 内部 使用 的 无名 事件 ， 事件 一般 可用 SetEvent 等 函数 触发 。 设备 驱动程序 中 触发 Win 事件 　 　 在 设备 驱动程序 中 触发 Win 事件 要 考虑 许多 实现 细节 并 需要 采用 汇编语言 实现 。 限于 篇幅 ， 这里 简单 介绍 其 核心 调用 ： 　 　 VxDcall ＿ VWIN ＿ SetWinEvent 　 　 其 功能 是 设置 指定 的 事件 对象 为 发信号 状态 。 如果 它 是 一个 手动 复位 事件 ， 它 将 保持 在 发信号 状态 直到 它 被 明确 地 复位 且 当前 所有 因为 该 事件 而 阻塞 的 线程 全部 标为 非 阻塞 ； 如果 它 是 一个 自动 复位 事件 ， 则 有 一个 等待 线程 被 标为 非 阻塞状态 。 调用 时 使用 EAX 、 ECX 、 EDX 和 Flags 寄存器 。 如果 调用 成功 ， 则 在 EAX 寄存器 中 返回 非零值 ， 否则 为 失败 。 　 　 表示 VxD 事件 对象 的 句柄 存入 EAX 中 ， 个 VxD 句柄 是 个 由 Win 函数 OpenVxDHandle 创建 的 ring 句柄 详见 节 。 　 　 注意 ， 该 服务 仅 在 当前 虚拟机 是 系统 虚拟机 时才 能够 被 调用 。 Win 与 核心 对象 句柄 的 转换 　 　 在 Windowsx 提供 的 kerneldll 动态链接库 中 ， 有 一个 未公开 的 API 调用 即 OpenVxDHandle ， 它 的 作用 就是 将 在 Win 程序 中 使用 的 句柄 转换 为 核心 设备 能够 使用 的 句柄 。 于是 在 核心 运行 的 代码 与 Win 中 运行 的 代码 可以 操作 同一个 对象 。 该 函数 原型 如下 ： 　 　 DWORD ＿ cdeclOpenVxDHandle （ HANDLEhSource ） ； 　 　 用 如下 方法 可以 获取 该 API 调用 ： 　 　 typedefUINTCALLBACKLPFNDLLFUNCDWORD ； LPFNDLLFUNClpfnDllFunc ； ／ ／ Functionpointer 　 　 　 　 　 　 　 　 　 　 　 　 　 ／ ／ DWORDdwParam ； 　 DWORDuReturnVal ； 　 DWORD ＿ cdeclmyOpenVxDHandle （ HANDLEhSource 　 ｛ 　 　 HINSTANCEhDLL ； ／ ／ HandletoDLL 　 　 hDLL ＝ LoadLibrary （ ″ KernelDLL ″ ） ； 　 　 if （ hDLL ＝ NULL 　 　 ｛ 　 　 　 　 lpfnDllFunc ＝ LPFNDLLFUNCGetProcAd － dresshDLL ， ″ OpenVxDHandle ″ ； 　 　 if ！ lpfnDllFunc ／ ／ handletheerror 　 　 　 　 　 　 FreeLibraryhDLL ； 　 　 　 　 　 　 return ； 　 　 　 　 ｝ 　 　 else 　 　 　 　 ｛ ／ ／ callthefunction 　 　 　 　 uReturnVal ＝ lpfnDllFunchSource ； 　 　 　 　 ｝ 　 　 ｝ 　 　 设备 驱动程序 的 编制 　 　 编制 设备 驱动程序 主要 使用 WinDDK ， 当然 也 有 一些 第三方 厂家 提供 的 较为 便宜 的 集成化 开发工具 。 有关 设备 驱动程序 的 编制 需要 较 多 篇幅 来 介绍 ， 这里 就 不 细述 了 。 结束语 　 　 在 Windowsx 中 开发 设计 与 底层 硬件 有关 的 实时 、 准 实时 通信 与 控制 软件系统 是 一项 很 有意思 的 工作 。 在 编制 测控 软件 、 数据 同步 传输 软件 等 方面 的 应用 中 ， 该 设计 思想 使 我们 取得 了 事半功倍 的 效果 ， 本文 给出 的 设计 思路 具有 广泛 的 实用价值 。 马 卫东 （ 中国工程物理研究院 计算机 应用 研究所 　 ） 王志颖 （ 中国工程物理研究院 电子 工程 研究所 ） 收稿 日期 ：
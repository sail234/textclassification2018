计算机 研究 与 发展 JOURNALOFCOMPUTERRESEARCHANDDEVELOPMENT 年 　 第卷 　 第期 　 Vol 　 No 　 Prolog 抽象机 及 运行 模型 研究 萧 　 镇 　 韩国 新 　 龚育昌 　 赵振西 摘 　 要 ： 文中 从 实现 Prolog 集成 开发 环境 （ PrologPE ） 在 功能 和 效率 方面 的 要求 出发 ， 通过 对 Warren 抽象机 （ WAM 的 改进 与 扩充 ， 提出 了 一种 改进 的 Prolog 抽象机 PAM 及 相应 的 基于 ClientAgent 结构 的 运行 控制 机制 关键词 ： Prolog 抽象机 ， 静态 代码 与 动态 代码 ， ClientAgent 结构 ， Prolog “ 或 ” 语义 中图法 分类号 ： TP ； TPASTUDYOFPROLOGABSTRACTMACHINEANDRUNNINGMODELXIAOZhenHANGuoXinGONGYuChangandZHAOZhenXiDepartmentofComputerScienceandTechnologyUniversityofScienceandTechnologyofChinaHefeiAbstract 　 InthispaperanimprovedPrologabstractmachinePAMbasedonWarrenabstractmachineWAMispresentedtosuittheneedofanintegratedPrologprogrammingenvironmentPrologPEFurthermoretherunningmodelforPAMinclientagentstructureisdescribedindetailwhichcanflexiblycoordinatetheexecutionofstaticanddynamicPrologCodesandimprovetheefficiencyofthesystemKeywords 　 PrologabstractmachinestaticcodeanddynamiccodeclientagentstructureORsemanticofProlog 　 引 　 言 　 　 Prolog 抽象机 是 实现 Prolog 语言 的 虚拟 模型 Warren 所 提出 的 可 支持 编译 实现 的 Prolog 抽象机 WAM ［ ］ 具有 结构 简练 紧凑 、 易于 实现 并 采用 了 基本 优化 机制 等 优点 ， 已 被 QuintusProlog ， IBMProlog 等 许多 Prolog 系统 所 采用 然而 WAM 是 一个 基本 模型 ， 而且 只是 Prolog 逻辑 部分 的 执行 模型 ， 因此 当 实现 一个 功能强大 的 Prolog 系统 时 ， 在 非 逻辑 部分 功能 的 实现 、 更 完备 的 Prolog 语义 的 实现 以及 获得 更 高 的 执行 效率 等 方面 ， WAM 尚存 在 诸多 问题 现实 而 有效 的 解决方案 是 对 WAM 进行 改进 与 扩充 　 　 本文 所 讨论 的 Prolog 抽象机 PAM 及其 运行 环境 是 根据 一个 Prolog 集成 开发 环境 （ PrologPE ） 总体设计 所 提出 的 要求 而 设计 的 PrologPE 是 一个集 文件 管理器 、 工程 （ project ） 管理器 、 动态 编译器 解释器 动态 链接 器 、 源代码 窗口 调试器 、 外部 接口 、 界面 管理器 和 联机 手册 等 为 一体 的 Prolog 程序设计 环境 ［ ， ］ 为了 实现 模块化 功能 、 灵活 协调 动态 代码 （ 即可 由 代码 维护 谓词 修改 的 Prolog 代码 ） 和 静态 代码 的 执行 ， 以及 实现 真正 面向 源代码 的 调试器 （ 摒弃 调试 谓词 ） 、 强化 交互 能力 和 提高 综合 执行 效率 等 要求 PrologPE 对 PAM 及其 运行 控制 机制 提出 了 很 高 的 要求 针对 上述 具体 的 要求 ， 我们 在 已 做 工作 ［ ， ］ 的 基础 上 ， 对 WAM 的 三大 组成部分 （ 存储器 、 机器 状态 和 抽象 指令集 ） 都 做 了 进一步 的 改进 与 扩充 ， 并 设计 了 一种 基于 ClientAgent 结构 的 运行 控制 机制 年 多来 ， PrologPE 系统 运行 与 使用 的 情况 说明 ， PAM 及其 运行 模型 的 设计 是 十分 有效 的 　 　 本文 以下 各节 分别 着重 介绍 PAM 的 存储器 与 数据 对象 、 机器 状态 和 抽象 指令集 的 改进 部分 以及 基于 ClientAgent 结构 的 运行 环境 限于 篇幅 ， 不再 对 WAM 作 更 多 的 介绍 　 PAM 的 存储器 及 数据 对象 　 　 PAM 的 存储器 分为 数据 存储器 和 代码 存储器 两 部分 　 　 数据 存储器 又 分为 运行 时 环境 存储器 和 数据 资源 存储器 运行 时 环境 包括 全局 栈堆 、 局部 栈 和 踪迹 栈 这里 我们 放弃 了 对 合一 栈 的 显式 管理 ， 而 将 其 交给 宿主 语言 C ， 以 节省 显示 数据 存取 操作 的 开销 数据 资源 存储器 存储 Prolog 标志 数据 所 对应 的 数据 对象 ， 如 谓词 名 、 浮点 值 等 　 　 代码 存储器 分为 静态 代码 存储器 和 动态 代码 存储器 两 部分 静态 代码 存储器 存放 由 Prolog 中间代码 转换 生成 C语言 形式 的 静态 代码 ， 交给 操作系统 管理 ； 动态 代码 存储器 存放 Prolog 动态 子句 过程 的 中间代码 序列 及其 源代码 的 等价 表示 ， 这是 处理 静态 、 动态 代码 的 语义 一致性 和 协调 执行 所 需要 的 　 　 在 Prolog 运行 时刻 ， 存储器 中 存放 着 各种 操作 对象 的 描述符 ， 这些 操作 对象 包括 常量 原子 、 整数 、 浮点数 、 空表 、 变量 、 表 、 结构 、 代码 和 纯量 我们 根据 其 属性 将 这些 操作 对象 区分 为 数据 操作 对象 和 代码 操作 对象 　 　 　 　 对于 数据 操作 对象 ， 除纯量 为 其 自然 表示 外 ， 其余 均 统一 表示 为 字节 的 标志 字 ， 其 格式 为 ： 　 　 对于 常量 ， 用 标志 字 的 第位 （ 第一 、 二 字节 ） 表示 具体 数据 （ 整数 ） 或 数据 资源 表 索引 （ 原子 、 浮点数 ） ； 对于 结构 ， 除 具有 原子 常量 的 信息 外 ， 第二 字节 存放 结构 参数 的 个数 ； 对于 变量 和表 ， 数据 内容 域 中 存放 运行 时刻 环境 存储器 指针 　 　 对于 代码 操作 对象 ， 由于 存在 着 不同 存储 属性 的 静态 代码 （ SC ） 和 动态 代码 （ DC ） ， 涉及 到 运行 时刻 定义 的 描述符 ， 将 在 第节 中 介绍 　 PAM 的 机器 状态 　 　 为了 协调 SC 和 DC 的 执行 ， 扩充 Prolog 的 语义 （ 如 “ 或 ” 语义 ） 和 提高 执行 效率 ， PAM 对 WAM 的 机器 状态 作 了 适当 的 修改 和 扩充 首先 将 WAM 中 C 和 CP 的 定义 由 单纯 的 程序 计数器 改变 为 事件 描述符 （ 或 程序 描述符 ） ， 且 增设 当前 函数指针 F 和 后继 函数指针 CF （ 与 WAM 中 的 C 和 CP 对应 ） 此外 还 增设 了 合一 结果 寄存器 Fail 因此 ， PAM 完整 的 机器 状态 寄存器 组为 ： 　 　 A ： 参数 寄存器 　 　 TR ： 踪迹 栈顶 指针 　 　 NUMOFARGS ： 参数 个数 　 　 H ： 堆顶 指针 　 　 E ： 环境 帧 指针 　 　 B ： cut 寄存器 　 　 P ： 当前 程序 描述符 　 　 HB ： 堆 回溯 指针 　 　 CP ： 后继 程序 描述符 　 　 S ： 结构 指针 　 　 F ： 当前 函数指针 　 　 MODE ： 合一 状态 寄存器 　 　 CF ： 后继 函数指针 　 　 Fail ： 合一 （ 失败 ） 结果 寄存器 　 　 B ： 选择 点 指针 图 　 PAM 的 存储空间 与 机器 状态 　 　 图 表示 PAM 的 存储空间 与 机器 状态 参照 图 ， 我们 再 来 说明 一下 修改 C ， PC 含义 的 一个 理由 在 Prolog 程序 中 ， 最 大量 的 是 静态 代码 SC ， 提高 其 执行 效率 是 至关重要 的 SC 的 执行 过程 可 归结为 ① 由 事件 描述符 找到 谓词 过程 函数指针 ； ② 通过 函数指针 调用 过程 其中 ① 是 一个 相当 费时 的 环节 但 如果 系统 确切 知道 谓词 过程 的 属性 ， 函数指针 的 查找 是 可能 避免 的 下节 中将 对 事件 描述符 作 进一步 的 说明 　 PAM 的 抽象 指令集 　 　 对于 实现 Prolog 的 逻辑 语义 ， WAM 的 抽象 指令集 是 必要 的 ， 但 并 不是 充分 的 此外 ， 其中 unify 指令 在 实现 Prolog 的 功能 时 稍嫌 复杂 ， 影响 效率 ， 对于 非 逻辑 语义 ， WAM 中 找 不到 相关 的 支持 PAM 对 WAM 的 抽象 指令集 作 了 必要 的 改进 和 扩充 限于 篇幅 ， 下面 只 对 PAM 抽象 指令 集中 改进 与 扩充 的 部分 进行 原理 性 的 介绍 关于 PAM 抽象 指令集 的 全部 指令集 及其 详细描述 ， 请 参考文献 ［ ］ 中 的 附录 　 　 把 unify 指令 细分 为 Set 和 Unify 两种 指令 　 　 Set 相当于 写 模式 下 的 Unify 指令 这是 为了 省去 大量 模式 设置 和 测试 时间 以 提高效率 ， 同时 也 可 使 代码 含义 更 清晰 　 　 细分 Call 和 execute 指令 　 　 把 调用 的 Prolog 过程 区分 为 以下 几类 ： 　 　 DBIP ： 确定性 内部 谓词 过程 （ 不会 产生 选择 点 ） ； 　 　 NBIP ： 非 确定性 内部 谓词 过程 ； 　 　 STATIC ： 用户 定义 的 动态 代码 过程 ； 　 　 DLLNAME ： 需要 动态 链接 的 用户 定义 过程 　 　 以上 细化 对 Prolog 非 逻辑 部分 的 实现 和 提高效率 是 很 有效 的 　 　 引入 IO 指令 及 操作 原语 　 　 其中 包括 产生 输出 的 out 类 指令 和 完成 询问 的 QueryUser 原语 这是 PrologPE 增强 交互性 所 需要 的 　 　 增加 了 Math 类 指令 　 　 这是 PrologPE 增强 数值 处理 能力 必须 的 增加 了 Math 类 指令 可 避免 大量 过程 调用 ， 提高 运行 效率 　 　 扩充 控制 类 指令 　 　 PrologPE 的 原型 系统 运行 表明 ， 文献 ［ ］ 中 对 WAM 控制 类 指令 的 扩充 对 实现 PrologPE 的 功能 和 性能 是 不够 的 ， PrologPE 进一步 扩充 了 如下 控制 类 指令 ： 　 　 end 指令 ： 是 deallocate 和 Proceed 指令 的 结合体 ， 旨在 避免 不必要 的 数据 移动 ； 　 　 Continue 指令 和 success 指令 ： 是 在 同一 子句 过程 中 的 控制 转移 指令 增设 的 目的 在于 增强 控制 的 灵活性 ， 有效 减少 运行 栈 的 维护 工作 ； 　 　 testA 指令 ： 是 Prolog 与 外部 语言 （ 包括 SQL ） 协调 工作 的 接口 控制指令 　 　 支持 “ 或 ” 语义 实现 的 指令 　 　 在 逻辑 程序设计 中 “ 或 ” 语义 是 很 有用 的 在 Prolog 程序 中 ， 存在 着 以 “ ； ” 表示 的 “ 或 ” 求解 子目标 WAM 没有 提供 实现 “ 或 ” 语义 的 支持 ， 这 可能 也 是 在 已有 Prolog 系统 中未 实现 “ 或 ” 语义 的 因素 之一 为了 实现 “ 或 ” 语义 ， PAM 的 指令集 重新 定义 了 选择 指令 Try ， Retry 和 Trust ： 　 　 　 Tryn ： （ ） 产生 一个 选择 点 ； （ ） 按 如下 方式 定义 回溯 过程 描述符 ： 　 　 　 　 　 　 BP ∶ 　 P ； 　 　 　 　 　 　 BPGI ∶ 　 n ； 其中 n 为 子目标 索引 　 　 　 Retryn ： 对 当前 选择 点 的 回溯 过程 描述符 作 如下 修改 ： 　 　 　 　 　 　 BP ∶ 　 P ； 　 　 　 　 　 　 BPGI ∶ 　 n ； 　 　 　 Trust ： 抛弃 当前 选择 点 　 　 以上 条 指令 和 Successn 指令 相配合 ， 通过 适当 地 设置 后继 过程 指针 ， 便 可 简单 地 实现 “ 或 ” 语义 下节 在 介绍 了 运行 控制 之后 ， 将 举例说明 其 实现 过程 　 PAM 的 运行 控制 　 　 由于 PAM 中 存在 着 静态 代码 SC 和 动态 代码 DC ， 因此 需要 设计 一种 运行 控制 机制 ， 以 提供 一致 的 接口 来 保证 这 两种 代码 的 语义 一致性 和 协调 执行 　 基于 ClientAgent 结构 的 运行 控制 机制 　 　 Prolog 对 问题 的 求解 过程 是 对 问题 状态 空间 的 深度 优先 遍历 ， 实现 的 主要 机制 是 回溯 因此 ， 实现 回溯 是 解决 上述 接口 问题 的 首要 问题 一种 最 直接 的 想法 是 直接 利用 结构化程序 设计 语言 的 嵌套 、 递归 机制 ， 把 每个 谓词 实现 为 一个 过程 ， 目标 求解 则 转化 为 过程 调用 ， 因此 问题 空间 状态 节点 表现 为 各 过程 的 运行 环境 但是 ， 这种 方法 的 致命 弱点 是 所 生成 的 代码 流 没有 条理性 ， 极难 保证 其 正确性 同时 ， 运行 环境 的 保存 和 恢复 要 消耗 大量 的 内存空间 　 　 一种 可以 考虑 的 方案 是 把 Prolog 应用程序 实现 为 一个 无 结构 的 语句 序列 ， 利用 GOTO 语句 实现 程序 状态 的 转移 ， 以 实现 问题 空间 的 遍历 其 优点 是 很 容易 与 中间 语言 指令 对应 ， 特别 适合 于用 汇编 实现 ， KDProlog ［ ］ 就 采用 了 这种 方案 　 　 另 一种 可 考虑 的 方案 是 设置 全局 结构 变量 ， 保存 问题 的 求解 过程 ， 把 谓词 过程 完全 视为 状态 空间 结点 上 的 操作 其 优点 是 概念 清晰 ， 易于 处理 ， 不足之处 在于 完全 忽视 了 程序 状态 也 可以 表示 求解 遍历 状态 ， 运行 代码 需要 额外 的 数据 空间 及 数据 维护 操作 　 　 上述 两种 方案 只要 实现 充分 的 优化 ， 对于 纯 编译 或纯 解释 实现 ， 基本上 可以 实现 求解 机制 但 对于 解释 代码 与 编译 代码 共存 的 情况 ， 这 两种 方案 都 不能 解决 两种 代码 的 相互 调用 问题 因为 解释 代码 实际 是 “ 数据 ” ， 在 进程 运行 中 不能 作为 “ 代码 ” 被 一般 程序 访问 为此 ， PrologPE 采用 了 一种 基于 ClientAgent 结构 的 运行 控制 机制 ， 即 把 Prolog 的 执行 机制 作为 Agent ， 而 把 谓词 实现 作为 Client ， 以 消息 驱动 的 方式 工作 如图所示 这种 运行 控制 机制 充分利用 了 上述 第一种 方案 中 用 程序 状态 表示 求解 问题 空间 状态 的 优点 ， 又 以远 小于 上述 第二种 方案 所 需 的 空间 代价 （ 全部 通过 PAM 运行 时 的 栈 空间 ， 额外 空间 消耗 为 ） 实现 了 非常 强 的 模块 封装 结构 同时 ， 由于 把 谓词 过程 作为 事件 处理过程 ， 不 需要 有关 具体 抽象 指令 的 代码 空间 索引 ， 从而 在 较 高 的 层次 上 统一 了 SC 和 DC 的 编址 — — 即 摒弃 了 绝对 物理 编址 方式 ， 代之以 逻辑 上 的 事件 描述符 图 　 ClientAgent 结构 　 事件 描述符 　 　 在 WAM 中 ， P 和 PC 的 含义 特别 单一 ， 只是 把 要 执行 的 中间 指令 在 代码 区中 的 地址 索引 通知 执行机构 这种 简单 的 定义 对于 存在 两种 不同 存储 属性 的 代码 SC 和 DC 的 情况 已 不能 满足要求 为此 ， PAM 将 其 修改 为 作用 更强 的 事件 描述符 （ ED ） ， 使 其 既 能 从 不同 代码 中 索引 谓词 过程 ， 又 能 作为 谓词 过程 （ Client ） 的 驱动 事件 的 事件 描述 　 　 作为 谓词 过程 的 索引 ， ED 应能 区分 谓词 过程 的 属性 以及 谓词 过程 在 各自 代码 域 中 的 地址 索引 ； 同时 ， ED 应能 表达 谓词 过程 中子 句 的 信息 ； 进而言之 ， 子句 的 基本 单位 是 其 组成 目标 ， 子句 的 求解 过程 实际 是 求解 子句 各 组成 目标 的 过程 ， 因此 ， ED 还 应该 给出 有关 目标 的 说明 ， 并 将 索引 细化 到 各 组成 目标 　 　 作为 驱动 谓词 过程 的 事件 ， ED 应该 把 Prolog 执行 过程 中 的 控制 信息 通知 Client ， 其中 包括 ： 首次 尝试 还是 重新 满足 、 要求 处理 的 事件 类型 等 　 　 综合 上述 两 方面 的 要求 ， 结合 ClientAgent 结构 的 运行 控制 机制 ， 将 PAM 中 ED 的 具体 结构 确定 为 ： 其中 ： T 为 谓词 过程 类型 ； PI 为 谓词 过程 在 其 所属 代码 空间 中 的 索引 ； CI 为 子句 索引 ； GI 为 目标 索引 　 　 对于 T ， 可以 是 SC 或 DC 为了 提高效率 ， 把 系统 谓词 Buildings 也 定义 为 T 的 一种 类型 ； 对于 PI ， 根据 T 的 不同 类型 ， 以 不同 的 策略 得到 索引 值 ； CI 和 GI 在 索引 到 子句 和 目标 的 同时 ， 也 是 发给 Client 的 事件 ： “ CIANDGI ” 表示 该 谓词 过程 首次 被 调用 ， “ CI ≠ ANDGI ” 表示 对 该 谓词 过程 的 新 一次 尝试 同时 ， GI 也 是 要求 Client 处理 的 事件 　 Client 结构 与 Agent 结构 　 　 明确 了 ED 的 组成 之后 ， Client 的 结构 形式 就 清晰 了 首先 ， 根据 ED 中 的 索引 信息 找到 相应 的 目标 代码 ， 然后 根据 ED 的 类型 进行 不同 的 处理 （ 产生 选择 点 、 分配 环境 帧 、 修改 选择 点 等 ） 因此 ， 我们 把 Client 实现 为 基本块 结构 ， 把 谓词 过程 中 对 各 子目标 的 求解 都 实现 为 一组 中间 指令 序列 ： 　 　 ComputeparaA 　 　 ComputeparaA 　 　 … … 　 　 ComputeparaAn 　 　 CallexecutePn 　 　 并 通过 ED 的 索引 信息 在 各 基本块 之间 执行 控制 转移 对于 SC ， 最 直接 而 简单 的 方式 是 使用 Case 语句 ； 对于 DC ， 则 把 基本块 的 索引 信息 作为 谓词 过程 的 一部分 ， 以 指导 解释器 运行 　 　 通过 以上 讨论 ， 可知 Client 的 整体 结构 如下 ： 　 　 PROCEDUREMSGPROCESSMessageContence 　 　 　 BEGIN 　 　 　 　 SWITCHMessageContenceOF 　 　 　 　 CASEMsgType ； 　 　 　 　 　 　 Process ； 　 　 　 　 　 　 PutAnswerMessage ； 　 　 　 　 　 　 BREAK ； 　 　 　 　 CASEMsgType ； 　 　 　 　 　 　 Process ； 　 　 　 　 　 　 PutAnswerMessage ； 　 　 　 　 　 　 BREAK ； 　 　 　 ENDSWITCH 　 　 ENDPROCEDURE 　 　 作为 Client 的 调度 者 ， Agent 的 控制 流程 为 ： 　 　 　 Initialization 　 　 REPEAT 　 　 　 GETMessageFromClient ； 　 　 　 MessageProcess ； 　 　 　 SentMessageToClient ； 　 　 UNTILHaveQuitMessage 　 Client 结构 的 优化 　 　 Client 通过 Callexecute 指令 反馈 给 Agent 的 消息 可能 会 被 Agent 不加 处理 地 再次 发送给 该 Client （ 存在 递归 时 ） ； 此外 ， 对于 多子 句 过程 ， 回溯 点 可能 就是 本 过程 ， 这 也 意味着 Agent 在 满足 之前 对 该 过程 进行 反复 的 调用 对 以上 两种 情况 如 不 加以控制 ， 会 造成 大量 时间 浪费 为此 ， 我们 给 Client 的 最 外层 增加 了 获取 有关 消息 的 操作 ， 从而 用 迭代 高效 地 实现 Prolog 的 控制 　 SC 和 DC 相互 调用 的 控制 转换 　 　 SC 和 DC 之间 的 控制 转移 最终 要 经过 Callexecute 指令 ， 这 两 指令 接受 的 是 事件 描述符 ED ， 因此 它们 实际上 成为 由 Client 向 Agent 反馈 消息 的 途径 ： 把 下 一步 需 被 处理 的 事件 以 ED 形式 通知 Agent ， Agent 则 通过 ED 索引 得到 下 一步 所 需 的 Client ， 并 对 其 发送 消息 可见 ， 采用 ClientAgent 结构 来 处理 SC 和 DC 的 相互 调用 和 协调 执行 具有 概念 清晰 和 易于 实现 的 特点 　 “ 或 ” 语义 实现 示例 　 　 根据 以上 对 PAM 及 运行 控制 的 描述 ， 我们 以 子句 abc ； de ； f ； gh 为例 ， 说明 “ 或 ” 目标 的 实现 方法 该 子句 的 编译 代码 为 ： 　 　 Clienta 　 　 　 　 SWITCHPGI 　 　 　 CASEallocate ； callClientb ； BREAK ； 　 　 　 CASETry ； success ； executeClientc ； BREAK ； 　 　 　 CASERetry ； success ； executeClientd ； BREAK ； 　 　 　 CASERetry ； callCliente ； BREAK ； 　 　 　 CASEsuccess ； executeClientf ； BREAK ； 　 　 　 CASETrust ； success ； executeClientg ； BREAK ； 　 　 　 CASEcallClienth ； BREAK ； 　 　 　 CASEend ； BREAK ； 　 　 　 DEFAULTPAMFailTRUE ； BREAK ； 　 　 　 　 　 　 　 以上 代码 中 ， 从 CASE 到 CASE 涉及 到 “ 或 ” 目标 的 实现 c ， d ， g 是 单块 “ 或 ” 目标 ， 而 e ， f 是 多块 “ 或 ” 目标 在 “ 或 ” 目标 的 首块 是 选择 指令 （ Try ， Retry ， Trust ） ， 而 在 “ 或 ” 目标 的 末 块 都 用 一条 success 指令 来 设置 成功 选择 点 因此 ， 每个 “ 或 ” 目标 都 有 自己 的 “ 失败 出口 ” （ 由 选择 点 定义 ） 和 “ 成功 出口 ” 当 “ 或 ” 目标 失败 时 ， 会 从 选择 点中 找到 下 一个 可 尝试 的 “ 或 ” 目标 ； 而 当 “ 或 ” 目标 成功 时 ， 会 根据 success 指令 设置 的 后继 过程 CP 转移 到 “ 或 ” 目标 成功 点 使用 execute 指令 是 为了 保证 success 指令 设置 的 CP 不会 被 “ 或 ” 目标 所 破坏 　 结束语 　 　 本文 根据 Prolog 集成 开发 环境 PrologPE 实现 更 强大 功能 的 需求 ， 通过 对 WAM 的 改进 与 扩充 ， 设计 了 一种 功能 更 完备 的 Prolog 抽象机 PAM ， 进而 提出 了 一种 基于 ClientAgent 结构 的 运行 控制 机制 ， 该 机制 能 灵活 地 协调 共存 的 静态 代码 和 动态 代码 的 执行 ， 而且 能 对 Prolog 功能 （ 如 “ 或 ” 语义 ） 的 扩充 提供 有效 的 支持 PrologPE 运行 使用 年 以来 的 实践 说明 ， PAM 和 上述 运行 控制 机制 是 十分 有效 的 本 课题 得到 中国科学院 重点 科技 攻关项目 基金 资助 作者简介 ： 萧镇 ， 男 ， 年生 ， 博士 研究生 ， 主要 研究 领域 为 软件工程 环境 　 　 　 　 　 韩国 新 ， 男 ， 年生 ， 硕士 ， 工程师 ， 主要 研究 领域 为 软件技术 　 　 　 　 　 龚育昌 ， 男 ， 年生 ， 教授 ， 主要 研究 领域 为 软件工程 环境 、 数据库 技术 　 　 　 　 　 赵振西 ， 男 ， 年生 ， 教授 ， 博士生 导师 ， 主要 研究 领域 为 软件工程 环境 、 信息 集成 技术 作者 单位 ： 中国 科学技术 大学 计算机 科学技术 系 　 合肥 　 参考文献 　 WarrenHDAnabstractprologinstructionsetTechnicalNoteSRIInternationalMenloParkCA 　 萧镇 ， 韩国 新 Prolog 集成 开发 环境 PrologPE 技术 报告 中国 科学技术 大学 信息处理 实验室 　 　 XiaoZhenHanGuoxinAguidetoPrologPEIntegratedprologdevelopmentenvironmentinChineseInformationProcessingLabUSTCHefeiTechRep 　 萧镇 ， 韩国 新 PrologPE 用户手册 中国 科学技术 大学 信息处理 实验室 ， 　 　 XiaoZhenHanGuoxinPrologPEUserManualinChineseAnhuiInformationProcessingLabUSTCTechRep 　 赵振西柯 向东 郭剑昆 有效 的 Prolog 编译 实现 方法 计算机 学报 ， ～ 　 　 ZhaoZhenxiKeXiangdongGuoJiankunEffectivemethodsforcompiledPrologChineseJournalofComputersinChinese ～ 　 王子 骏 一种 新型 的 Prolog 中间 语言 及其 运行 环境 ［ 硕士论文 ］ 中国 科学技术 大学 ， 合肥 ， 　 　 WangZijunAnewinterlinguaandruntimeenvironmentforPROLOG ［ MasterDdissertation ］ inChineseUSTCHefei 原稿 收到 日期 ： ； 修改稿 收到 日期 ：
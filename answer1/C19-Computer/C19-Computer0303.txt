软件 学报 JOURNALOFSOFTWARE 年 第卷 第期 　 NoVol 基于 垂直 数据分布 的 关联 规则 高效 发现 算法 欧阳 为民 　 蔡 庆生 　 　 摘要 　 文章 分析 了 在 KDD 研究 中 现有 的 关联 规则 发现 算法 关于 频繁 项目 集 的 生成 与 测试方法 提出 了 一种 新 的 基于 垂直 数据分布 的 关联 规则 发现 算法 该 算法 无需 复杂 的 Hash 数据结构 仅 需 对 整个 数据库 作 两次 遍历 从而 既 方便 了 实现 又 提高 了 效率 　 　 关键词 　 关联 规则 频繁 项目 集 等价 类 　 　 中图法 分类号 　 TPAnEfficientAlgorithmforDiscoveringAssociationRulesBasedonVerticalDataLayoutOUYANGWeimin 　 CAIQingshengComputingCenterAnhuiUniversityHefeiDepartmentofComputerScienceUniversityofScienceandTechnologyofChinaHefei 　 　 Abstract 　 InthispapertheauthorsanalyzethemethodstogenerateandtestfrequentitemsetsinexistingalgorithmsinKDDresearchandputforwardanewefficientalgorithmfordiscoveringassociationrulesbasedonverticaldatalayoutThisalgorithmhasnoneedofHashdatastructureandmakesonlytwodatabasesscansAsaresultthealgorithmnotonlyfacilitatestheimplementationbutalsoimprovestheefficiency 　 　 Keywords 　 Associationrulefrequentitemsetsequivalenceclass 　 　 关联 规则 是 RAgrawal 等 人 首先 提出 的 KDD 研究 的 一个 重要 课题 它 可作 如下 形式化 定义 ： 令 Iiiim 为 项目 集 D 为 事务 数据库 其中 每个 事务 T 是 一个 项目 子集 TI 并 另 有 一个 唯一 的 顾客 标识符 TID 我们 说 事务 T 包含 项目 集 X 如果 XT 关联 规则 是 形如 XY 的 逻辑 蕴含 式 其中 XT 且 X ∩ Y 如果 事务 数据库 中有 s 的 事务 包含 X ∪ Y 那么 我们 说 关联 规则 XY 的 支持 为 s ； 如果 事务 数据库 中 包含 X 的 事务 中有 c 的 事务 同时 也 包含 Y 那么 我们 说 关联 规则 XY 的 信任 为 c 　 　 文献 ～ 分别 提出 了 多种 关联 规则 发现 算法 其中 最 著名 的 是 RAgrawal 提出 的 Apriori 算法 大多数 算法 的 主要 缺点 是 要 对 数据库 作 多次 遍历 从而 导致 较大 的 IO 负载 而且 这些 算法 都 使用 了 Hash 数据结构 对 其 进行 维护 与 搜索 又 要 增加 额外 的 负载 Partition 算法 虽然 只 需 对 数据库 作 两次 遍历 但 随着 划分 块 数量 的 增加 局部 频繁 集 的 数量 也 将 相应 增加 DICdynamicitemsetcounting 算法 可以 在 一次 遍历 中 对 长度 不同 的 若干 项目 集 进行 计数 从而 提高 了 每次 遍历 的 效率 但 它 实现 起来 不 甚 方便 而且 仍然 需要 Hash 数据结构 我们 的 目标 是 ， 算法 既 要 高效 ， 实现 起来 又 要 方便 为此 我们 提出 了 等价 类 概念 并 将 数据库 的 数据分布 由 通常 的 水平 方式 改为 垂直 方式 从而 提出 基于 垂直 数据分布 的 关联 规则 发现 算法 　 　 本文 第节 提出 项目 集聚 类 技术 — — 等价 类 概念 第节 讨论 数据 的 分布 方式 第节 提出 基于 垂直 数据分布 的 关联 规则 高效 发现 算法 第节 是 实验 结果 最后 总结 全文 项目 集聚 类 　 　 考察 集合 ABCDE 其 所有 子集 构成 的 子集 空间 如图所示 注意 应 忽略 所有 空集 频繁 集以实 线框 表示 最大 频繁 集某 频繁 集是 最大 的 如果 它 不是 任何 其他 频繁 集 的 子集 以 粗实 线框 表示 非 频繁 集以 虚 线框 表示 某 频繁 集 的 子集 必 是 频繁 的 所有 的 频繁 集 形成 一个 边界 如图 中 的 粗线 所示 边界 之下 是 频繁 集 边界 之上 是非 频繁 集 显然 最佳 的 关联 规则 发现 算法 应 仅仅 生成 并 测试 频繁 集而 避免 任何 非 频繁 集 的 生成 并 测试 这就是说 算法 应 能 有效 地 确定 频繁 集 边界 的 结构 幸运 的 是 由 最大 频繁 集 导出 的 子集 空间 正好 与 边界 结构 相对 一致 这些 子 空间 也 如图所示 图 　 项目 集聚 类 　 　 一般 地 我们 是 无法 预知 最大 频繁 集 的 但是 我们 可以 设法 得到 尽可能 小 的 、 包含 最大 频繁 集 的 超集 为此 我们 引入 等价 类 概念 来 对 项目 集 进行 聚类 考察 Apriori 算法 中 的 候选 生成 方法 第 k 次 遍历 所 需 的 候选 集 Ck 是 通过 链接 频繁 k 项目 集 Lk 而 得到 的 于是 我们 有 Ckxpppkqk 对 所有 pq ∈ Lkpkqk 为 方便 计 一般 要求 项目 集中 各 项目 之间 保持 某种 偏序 关系 这里 ， 我们 采用 通常 的 字母 序 于是 pkqkxi 表示 项目 集 x 的 第 i 个 项目 xij 表示 项目 集 x 中 的 从 第 i 个 到 第 j 个 项目 由图 可知 LABACADBCBDCDCEDE 那么 有 CABCABDACDBCDCDE 我们 按照 前 k 个 项目 称为 k 前缀 是否 相同 来 对 Lk 进行 等价 类 划分 即 具有 相同 k 前缀 的 项目 集 属于 同一个 等价 类 记作 　 　 　 　 　 　 　 　 　 　 Paaxk ∈ Lakxk 于是 候选 k 项目 集 可以 通过 链接 同一 等价 类中 的 所有 的 元素 对 然后 再 以类 标识符 作为 各 链接 结果 的 前缀 这种 方法 来 生成 对 上述 例子 中 的 L 我们 得到 如下 等价 类 ： PAABCDPBBCDPCCDEPDDE 由 等价 类 A ， B 和 C 链接 生成 的 集合 分别 为 ABCABDACDBCDCDE 这个 集合 彼此 独立 由于 仅 有 个 元素 的 等价 类 不能 产生 新 的 候选 因而 可以 不再 进一步 加以 考虑 　 　 注意 在 实际 实现 时 等价 类 的 生成 可以 在 候选 生成 的 同时 进行 构造 其 方法 如下 ： 　 　 InputCkxxxn 其中 各 项目 集 按 字典 序 排列 Cki 表示 候选 集 Ck 中 的 第 i 个 项目 集 Ck 表示 候选 集 Ck 中所 包含 的 项目 集 的 个数 ； 　 　 OutputLk 的 等价 类 ； 　 　 Begin 　 　 　 　 foritoCkdo 　 　 　 　 　 Cki 等价 类 Cki 初始化 为 空集 　 　 　 　 　 forjitoCkdo 　 　 　 　 　 　 CCkiCkiCkikCkjk 候选 链接 详见 第节 　 　 　 　 　 　 ifCsupport ≥ minsupthenCkiCki ∪ C 　 　 　 　 　 　 　 　 　 　 　 　 　 End 　 　 上述 算法 中 的 候选 生成 方法 与 Apriori 算法 中 的 候选 生成 方法 相比 至少 有三大 优点 首先 前者 不 需要 作 任何 比较 运算 直接 进行 拼接 即可 ； 而 后者 却 需要 判断 p 和 q 的 前 k 个 项目 是否 相同 显然 前者 更为 方便 、 快捷 其次 前者 在 候选 生成 后 没有 修剪 步骤 而 后者 是 有 的 这样一来 是否 会 由于 前者 的 候选 大于 后者 的 候选 数 因而 需要 对 更 多 的 候选 进行 支持 计数 从而 导致 效率 下降 呢 ？ 回答 是 否定 的 事实上 两者 的 候选 数是 相等 的 只不过 后者 经过 修剪 步骤 后 候选 数 可能 有所 减少 更 重要 的 是 根据 下 一节 提出 的 基于 垂直 数据分布 策略 的 候选 链接 方法 某个 候选 一经 生成 其 支持 数 就 立即 可知 可以 直接判断 其 是否是 频繁 的 因此 没有 必要 在 候选 生成 后 再 进行 修剪 第个 优点 是 引入 等价 类 概念 后 我们 可以 独立 地 在 各个 等价 类中 分别 进行 频繁 项目 集 的 发现 因而 便于 算法 的 并行 化 　 　 在 算法 的 任何 中间 步骤 当 确定 了 频繁 集 Lkk ≥ 以后 我们 就 可以 从 Lk 生成 潜在 的 最大 频繁 集 注意 对于 k 我们 以 整个 项目 集 作为 潜在 最大 频繁 集 然而 对于 k ≥ 我们 便 可以 得到 较 精确 的 关于 项目 之间 关系 的 知识 k 值越 大聚类 越 精确 每个 等价 类 就是 一个 潜在 的 最大 频繁 集 例如 从 等价 类 A 和 C 我们 最终 可以 分别 得到 真正 的 最大 频繁 集 ABCD 和 CDE 　 数据分布 　 　 KDD 系统 的 处理过程 由 若干 步骤 组成 最初 一步 是 通过 属性 集 聚焦 或 数据 抽样 来 建立 与 发现 任务 相关 的 目标 数据 集 为了 便于 数据 归约 和 映射 数据库 的 建立 一般 还 需要 某些 技术 来 进行 数据 变换 、 不必要 信息 的 删除 和 缺损 数据 missingdata 的 补充 接下来 用户 必须 确定 数据 发掘 任务 ， 选择 合适 的 算法 然后 是 对 已 发现 的 模式 或 知识 进行 评价 、 解释 等 数据 预处理 阶段 的 一个 重要 问题 是 数据 集中 数据 的 表达 与 分布 方式 这里 我们 简要 讨论 数据分布 的 两种 分布 方式 ： 水平 分布 与 垂直 分布 水平 数据分布 　 　 水平 数据分布 是 一种 常见 的 方式 在 这里 数据 集由 一系列 事务 构成 每个 事务 有 一个 事务 标识符 TID 以及 相应 事务所 包含 的 项目 表列 即 项目 集 使用 这种 格式 计算 负载 主要 集中 在 支持 计数 上 对于 平均 含有 L 个 项目 的 事务 在 第 k 次 循环 期间 我们 必须 生成 并 测试 该 事务 的 所有 k 元素 子集 看其 是否 包含 在 候选 集 Ck 中 为了 快速 地 进行 子集 检索 一般 都 采用 复杂 的 Hash 数据结构 来 存储 各个 候选 因而 必须 对 Hash 数据结构 进行 维护 与 搜索 从而 又 增加 了 额外 的 计算 负载 而且 数据 的 水平 分布 迫使 每次 循环 均 需 遍历 整个 数据库 或 每个 局部 划分 　 垂直 分布 　 　 数据 的 垂直 分布 是 指 数据 集由 一系列 项目 构成 每 一个 项目 均 带有 其 相应 的 TID 表列 即 包含 该项 目的 所有 事务 的 标识符 表且 按 字典 序 的 升序 排列 垂直 分布 不 存在 水平 分布 的 问题 其 原因 主要 是 ： 　 　 因为 TID 表列 以 升序 存储 所以 候选 k 项目 集 的 生成 与 支持 可以 通过 简单 地 链接 任意 两个 k 子集 得到 不 需要 复杂 的 Hash 数据结构 无需 对 整个 数据库 进行 遍历 我们 不必 生成 某一 事务 的 所有 k 子集 也 不 需要 对 Hash 数据结构 进行 维护 与 搜索 图 　 数据分布 　 　 TID 表列 包含 了 所有 的 关于 某 项目 集 的 相关 信息 垂直 分布 因此 具有 可 本地化 计算 的 优点 频繁 项目 集 的 计算 可以 在 每 一个 聚类 中 独立 进行 例如 考察 图该 图 对比 了 水平 分布 与 垂直 分布 两种 情况 为 简单 计 我们 在 图 中 对 空值 元素 也 作 了 表示 A 和 C 的 TID 表列 分别 为 AtidsCtids 于是 这 两张 Tid 表列 的 链接 仅 需 对 其 同时 作 一次 遍历 即可 得到 AC 的 TID 表列 ACtids 我们 只要 在 TID 表列 中 简单 地 清点 元素 个数 就 可以 立即 确定 相应 项目 集 的 支持 实际上 在 上述 链接 生成 过程 中 就 可以 进行 支持 计数 不必 事后 进行 从而 可以 省去 对 ACtids 的 一次 遍历 如果 满足 最低 支持 便 将 其 加入 频繁 项目 集 L 之中 　 　 基于 上述 描述 我们 有 如下 TID 表列 的 链接 算法 ： 　 　 Algorithmjoinoftwocandidates 　 　 InputtwocandidateLitemsetsXandYandtheirctidlistXtidsandYtids 　 　 OutputnewcandidateLitemsetCanditstidlist 　 　 Begin 　 　 　 　 CXXXLYL 　 　 　 Csupport 　 　 　 ijk 　 　 　 whilei ≤ Xandj ≤ Ydo 　 　 　 　 ifXtidsiYtidsjthen 　 　 　 　 　 kCsupport 　 　 　 　 　 CtidskXtidsi 　 　 　 　 　 　 　 　 　 elseifXtidsiYtidsjtheni 　 　 　 　 　 　 　 elsej 　 　 　 　 　 　 End 　 　 通过 利用 最低 支持 可以 更快 地 执行 TID 表列 之间 的 链接 例如 我们 假定 最低 支持 为 正在 链接 的 两个 项目 集是 AB 和 AC 其 支持 分别 为 和 一旦 发现 在 AB 中 出现 了 次 失配 我们 就 可以 中止 链接 因为 ABC 的 支持 最大 不 可能 超过 而 现在 已有 项 失配 这样 其 支持 肯定 低于 采用 这种 优化 方式 我们 可以 高效 地 进行 链接 运算 　 　 然而 正如 水平 分布 存在 不足 一样 垂直 分布 也 是 有 缺点 的 对于 小 项目 集 的 检查 垂直 分布 的 代价 要 高于 水平 分布 的 代价 这 是因为 小 项目 集 的 TID 表列 没有 对 项目 间 的 关系 提供 多少 有用 的 信息 特别 是 在 项目 集中 其 TID 表列 就 根本 没有 这样 的 信息 为此 我们 在 频繁 项目 集 和 频繁 项目 集 的 计算 时 仍 采用 水平 数据分布 方式 而 在 频繁 项目 集 的 计算 时 构造 出 每个 频繁 项目 的 TID 表列 然后 对 所有 频繁 k 项目 集 k ≥ 的 计算 均 根据 有关 项目 集 的 TID 表列 进行 即 转而 采用 垂直 数据分布 方式 这样 我们 仅 需 对 整个 数据库 遍历 两次 基于 垂直 数据分布 的 关联 规则 发现 算法 描述 　 　 本 节 首先 给出 一个 例子 来 说明 根据上述 各节 的 概念 与 方法 发现 最大 频繁 集 的 过程 然后 给出 相应 的 算法 描述 　 　 例 根据 如图所示 的 数据库 来 发现 最大 频繁 集 AnswerSet 　 　 假定 用户 最低 支持 为置 AnswerSet 为空 首先 我们 基于 水平 数据分布 方式 来 发现 频繁 项目 集 F 和 频繁 项目 集 F 以 所有 项目 构成 候选 项目 集 C 我们 有 CABCDEF 遍历 数据库 一次 计算 各个 候选 的 支持 取 支持 不 低于 的 所有 候选 构成 频繁 项目 集 FABCEF 接着 按照 上 节 所述 的 同时 构造 等价 类 的 候选 生成 方法 根据 F 来 生成 候选 项目 序列 集 C 于是 有 ABCEFBCEFCEFEF 即 CABACAEAF ∪ BCBEBF ∪ CECF ∪ EF 　 　 再次 遍历 数据库 计算 各个 候选 的 支持 并 构造 各个 候选 的 TID 表列 从 上述 各个 等价 类中 删除 支持 低于 的 元素 得到 ACBCEFCEFEF 从而 有 频繁 项目 集 FACBCBEBFCECF 　 　 然后 采用 垂直 数据分布 方式 即 根据 有关 项目 集 的 TID 表列 来 发现 所有 频繁 k 项目 集 k ≥ 的 计算 依次 根据 各个 等价 类 分别 进行 频繁 k 项目 集 k ≥ 的 发现 　 　 因为 等价 类 AC 仅 有 一个 元素 所以 无法 得到 更长 的 频繁 项目 因而 不必 进一步 考察 因此 AnswerSetAnswerSet ∪ AC 　 　 考察 等价 类 BCEF 链接 其中 的 所有 元素 对 得到 候选 项目 集中 的 各个 等价 类 和 其中 各个 候选 的 TID 表列 BCEFBCEtidsBCFtidsBEFBEFtids 　 　 考察 等价 类 BCEF 因其 各个 候选 的 支持 均 不 低于 故 继续 链接 其 元素 对 得到 一个 候选 项目 集中 的 等价 类 BCEFBCEFtids 由于 该 等价 类中 只有 个 元素 所以 在 其中 不会 得到 更长 的 频繁 项目 因而 不再 对 其 进一步 加以 考察 因此 BCEF 为 一个 最大 频繁 项目 集 AnswerSetAnswerSet ∪ BCEF 　 　 由于 等价 类 BEF 中 只有 一个 元素 所以 不会 产生 更长 的 频繁 项目 序列 因而 不再 对 其 进一步 考察 但是 由于 BEF 包含 在 BCEF 中 所以 不 认为 是 最大 频繁 项目 集 　 　 考察 等价 类 CEF 链接 其 元素 对 得到 一个 候选 项目 集中 的 等价 类 及其 TID 表列 ： CEFCEFtids 由于 该 等价 类中 只有 一个 元素 所以 不再 对 其 进一步 考察 由于 BCE 包含 在 BCEF 中 所以 不 认为 它 是 最大 频繁 项目 集 　 　 同理 考察 等价 类 EF 该类 也 没有 产生 新 的 最大 频繁 项目 集 　 　 至此 所有 等价 类 考察 完毕 最大 频繁 项目 集 的 发现 过程 便告 结束 基于 上述 描述 我们 给出 如下 最大 频繁 项目 集 发现 算法 FID ： 　 　 Algorithm 最大 频繁 项目 集 发现 算法 FID 　 　 InputDB 为 定义 在 RIIIm 之上 的 某 关系数据库 其中 属性 Ii 的 值域 为 ； 　 　 　 　 　 minsup 为 最低 支持 度 ； 　 　 Output 满足 最低 支持 度 的 最大 频繁 项目 集 AnswerSet 　 　 Begin 　 　 　 　 CallitemsinDBwhicharelexicographicallysorted 　 　 　 　 foreachtupletinDBdo 　 　 　 　 　 CtgetsubsetCtallcandidatescontainedint 　 　 　 　 　 foreachcandidatec ∈ Ctdocsupport 　 　 　 　 　 　 　 　 　 foritoCdo 　 　 　 　 　 C 　 　 　 　 　 forjitoCdo 　 　 　 　 　 　 　 CCiCiCikCjk 　 　 　 　 　 　 CC ∪ C 　 　 　 　 　 　 　 　 　 　 　 　 foreachtupletinRdo 　 　 　 　 CtgetsubsetCtallcandidatescontainedint 　 　 　 　 foreachcandidatec ∈ Ctdocsupportctidlistctidlist ∪ ttid 　 　 　 　 　 　 Lcc ∈ Ccsupport ≥ minsup 　 　 SGetequivalenceclassesL 按照 等价 类 的 概念 进行 生成 　 　 foreachequivalceclassEinSdo 　 　 　 　 ResultSetResultSet ∪ BottomUpE 　 　 AnswerSetMaximumitemsetsinResultSet 　 　 ReturnAnswerSet 　 　 End 　 　 GetequivalenceclassesL 　 　 　 　 　 SEL 　 　 　 xLgetthefirstelementofthefirstfrequentitemsetinL 　 　 　 foritoLdo 　 　 　 　 ifxLithenEE ∪ Li 　 　 　 　 elseSS ∪ EELixLi 　 　 　 ReturnS 　 　 BottomUpFkFkIIIm 　 　 ifFkthen 　 　 　 ResultSetResultSet ∪ getelementofFk 　 　 　 ReturnResultSet 　 　 　 　 　 foritomdo 　 　 　 　 　 Fk 　 　 　 　 　 forjitomdo 　 　 　 　 　 　 CJoinIiIj 参见 节 的 Join 算法 　 　 　 　 　 　 ifCsupport ≥ minsupthenFkFk ∪ C 　 　 　 　 　 　 　 　 　 　 ifFk ≠ thenResultSetResultSet ∪ BottomUpFk 　 　 　 　 ReturnResultSet 　 　 　 实验 结果 　 　 我们 用 VisualFoxpro 在 内存 为 M 的 微机 上 实现 了 Apriori 算法 和 FID 算法 采用 合成 数据 进行 了 算法 比较 测试 测试 数据库 含有 个 属性 每个 属性 有个 原始 值 首先 测试 算法 的 扩放性 我们 将 测试 数据库 的 元组 数从 开始 逐次 递增 到 最低 支持 设 为 两种 算法 的 扩放 性能 数据 曲线 如图所示 可见 两种 算法 的 扩放 性能 均 较 好 FID 算法 计算 量 相对 较 少 因而 执行 时间 短 一些 　 　 接着 我们 比较 算法 在 不同 最低 支持 下 的 性能 变化 此时 测试 数据库 固定 为元 组分 如下 次 变化 最低 支持 即 SSSS 和 S 测试 结果 如图所示 可以 看出 当 支持 下降时 执行 时间 上升 原因 是 过滤 条件 减弱 了 另外 我们 还 可以 看出 FID 算法 的 执行 时间 比 Apriori 算法 要少 　 　 图 　 　 　 　 　 　 　 　 　 　 　 　 　 　 图 　 　 从 理论 分析 和 实验 结果 可知 FID 算法 的 效率 要 优于 Apriori 算法 　 结论 与 进一步 工作 　 　 我们 对 现有 的 关联 规则 发现 算法 加以 研究 提出 了 等价 类 概念 并 为 方便 链接 而 将 数据库 的 数据分布 由 通常 的 水平 方式 改为 垂直 方式 从而 提出 了 发现 频繁 集 的 高效 算法 FIDfrequentitemsetdiscovery 该 算法 实现 方便 无需 复杂 的 Hash 数据结构 对 整个 数据库 仅 需 遍历 两次 实验 结果表明 ， FID 算法 的 效率 要 优于 Apriori 算法 　 　 本文 所 研究 的 仅 是 单层次 的 关联 规则 如何 将 本文 所提 方法 应用 于 多层 关联 规则 multiplelevelassociationrules 和 定量 型 关联 规则 quantitativeassociationrules 的 发现 是 值得 进一步 研究 的 问题 　 　 本文 研究 得到 国家自然科学基金 和 国家教育部 博士点 基金 资助 作者 欧阳 为民 年生 博士 副教授 主要 研究 领域 为 KDD 机器 学习 人工智能 及其 应用 蔡 庆生 年生 教授 博士生 导师 主要 研究 领域 为 机器 学习 知识 发现 人工智能 　 　 本文 通讯联系 人 欧阳 为民 合肥 安徽大学 计算中心 　 　 作者 单位 ： 欧阳 为民 安徽大学 计算中心 　 合肥 　 ； 蔡 庆生 中国 科学技术 大学 计算机系 　 合肥 　 参考文献 　 　 AgrawalRImielinskiTSwamiAMiningassociationrulesbetweensetsofitemsinlargedatabasesInProceedingsofACMSIGMODInternationalConferenceonManagementofDataWashingtonDC ～ 　 　 AgrawalRSrikantRFastalgorithmforminingassociationrulesInProceedingsofInternationalConferenceonVeryLargeDatabasesSantiagoChile ～ 　 　 AgrawalRMannilaHSrikantRetalFastdiscoveryofassociationrulesInFayyadUetaledsAdvancesinKnowledgeDiscoveryandDataMiningNewYorkMITPress ～ 　 　 KlemettinenMMannilaHRonkainenPetalFindinginterestingrulesfromlargesetsofdiscoveredassociationrulesInProceedingsoftherdInternationalConferenceonInformationandKnowledgeManagement ～ 　 　 ParkJSChenMYuPSAneffectiveHashbasedalgorithmforminingassociationrulesInProceedingsofACMSIGMODInternationalConferenceonManagementofData ～ 　 　 BrinSMotwaniRUllmanJetalDynamicitemsetcountingandimplicationrulesformarketbasketdataInProceedingsofACMSIGMODConferenceonManagementofData 　 　 SavasereAOmiecinskiENavatheSAnefficientalgorithmforminingassociationrulesinlargedatabasesInProceedingsofInternationalConferenceonVeryLargeDatabasesZrichSwizerland ～ 收到 原稿 收到 修改稿
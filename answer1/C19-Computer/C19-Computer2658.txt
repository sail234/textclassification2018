软件 学报 JOURNALOFSOFTWARE 年 　 第卷 　 第期 　 Vol 　 No 　 对象 演算 Ⅱ 黄涛 　 钱军 　 王栩 摘要 　 文章 应用 Goguen 等 人 的 结论 证明 并 得到 了 几个 结构化 对象 演算 的 基本 定理 一方面 这些 定理 保证 了 该文 可 由 现有 对象 的 描述 构造 新 对象 的 描述 并且 可以 把 建立 在 现有 对象 上 的 定理 作为 整个 对象 描述 和 验证 的 引理 另一方面 文章 还 讨论 了 基于 封装 性 的 对象 精化 于是 得到 一个 结构化 的 对象 演算 系统 关键词 　 结构化 对象 演算 institution Ω 理论 对象 系统 对象 精化 中图法 分类号 　 TPObjectCalculus Ⅱ HUANGTaoQIANJunWANGXuLaboratoryofComputerScienceInstituteofSoftwareTheChineseAcademyofSciencesBeijingObjectTechnologyCenterInstituteofSoftwareTheChineseAcademyofSciencesBeijingAbstract 　 InthispapersomeimportanttheoriesofstructuredobjectcalculususingtheresultscontributedbyGoguenareprovedThesetheoriesensuretobuildupthedescriptionofnewobjectsfromthedescriptionoftheexistingobjectsandverifytheglobalsystemwiththeoriesdeducedfromexistingobjectsaslemmaInadditiontheobjectreificationonthebasisofobjectencapsulationisstudiedandastructuredobjectcalculusisachievedKeywords 　 Structuredobjectcalculusinstitution Ω theoryobjectsystemobjectreification 　 　 在 文献 ［ ］ 中 我们 讨论 了 有关 单个 对象 的 描述 和 演算 然而 对于 复杂 对象 其 描述 将会 很 复杂 如果 我们 能够 将 “ 大 ” 对象 的 描述 分成 一系列 “ 小 ” 对象 的 描述 然后 再 将 它们 组装 起来 这 将 会 给 我们 带来 极大 的 方便 由 已有 对象 构造 新 的 复杂 对象 正是 面向对象 的 重要 特征 之一 这 就 要求 我们 由 对象 描述 构造 新 的 复杂 对象 描述 为此 我们 将 复杂 对象 乃至 系统 的 描述 均 看做 对象 描述 为 使 前面 讨论 的 有关 单个 对象 的 演算 和 特性 推理 仍然 有效 这 就 要求 对象 演算 和 特性 推理 具有 模块化 特性 即 我们 可以 将 复杂 对象 或 对象 系统 分解 为 一些 较 小 的 成分 对象 分别 描述 和 推理 各 成分 对象 及其 特性 而且 可以 由 各 成分 对象 来 构造 和 推理 复杂 对象 的 特性 另外 还有 一些 特性 是 复杂 对象 所 固有 的 它们 体现 各 成分 对象 的 交互作用 这 就 要求 我们 能够 将 对象 描述 和 特性 推理 分解 　 对象 演算 结构化 　 　 因为 满足 关系 和 推导 是非 结构化 的 一长串 的 非 结构化 公理 很 容易 出错 且 较 难 理解 为此 Goguen 和 Burstall 于 年 提出 “ Institution ” 概念 ［ ］ 　 Institution 　 　 Institution 的 定义 基于 “ 标记 范畴 ” categorysignatures 对 标记 范畴 中 的 每 一 标记 Ω 对应 有 “ Ω 语句 公式 ” 集 、 “ Ω 模型 集 ” 以及 满足 关系 satisfactionrelation 对 Institution 唯一 的 语义 要求 是 ： 当 标记 改变 所 引入 的 关于 语句 公式 和 模型 的 变换 翻译 需 保持 满足 关系 ， 即 有 如下 的 定义 　 　 定义 Institution 包含 ： 　 　 标记 范畴 Sign ； 　 　 函子 ： Sen ： Sign → Set 对 任意 标记 Ω ∈ SignSen Ω 给出 所有 Ω 语句 公式 的 集合 ； 对 任意 标记 态射 σ Ω → Ω ′ 函数 Sen σ ： Sen Ω → Sen Ω ′ 将 Ω 语句 公式 变换 成 Ω ′ 语句 公式 ； 　 　 函子 Mod ： Sign → CatopCat 表示 范畴 的 范畴 即以 范畴 为 “ 对象 ” 范畴 间 的 函子 为 “ 态射 ” ； Catop 表示 Cat 的 逆 范畴 即 Catop 和 Cat 含有 相同 的 对象 且 前者 的 态射 是 后者 的 逆 对 任意 标记 Ω ∈ SignMod Ω 给出 Ω 模型 范畴 ； 对 任意 标记 态射 σ ： Ω → Ω ′ 函子 Mod σ ： Mod Ω ′ → Mod Ω 将 Ω ′ 模型 变换 成 Ω 模型 ； 　 　 满足 关系 Mod Ω × Sen Ω Mod Ω 表示 Mod Ω 中 的 “ 对象 ” 对 任意 标记 态射 σ ： Ω → Ω ′ f ∈ Sen Ω M ′ ∈ Mod Ω ′ 满足 ： M ′ Sen σ fMod σ M ′ f 　 　 Institution 保证 了 当 标记 改变 时 相应 的 语句 和 模型 将作 一致 改变 这种 一致性 是 通过 满足条件 表示 的 　 　 定义 对象 标记 态射 给定 两个 对象 标记 Ω SFAE 和 Ω ′ S ′ F ′ A ′ E ′ 记从 Ω 到 Ω ′ 的 对象 标记 态射 为 σ σ S σ F σ A σ E 其中 ： 　 　 σ S ： S → S ′ ； 　 　 σ F ： F → F ′ 满足 对 任意 函数 符号 f ∈ F 〈 s × × sn 〉 s 则 σ Ff ∈ F ′ 〈 σ Ss × × σ Ssn 〉 σ Ss ； 　 　 σ A ： A → A ′ 满足 对 任意 属性 符号 f ∈ A 〈 s × × sn 〉 s 则 σ Af ∈ A ′ 〈 σ Ss × × σ Ssn 〉 σ Ss ； 　 　 σ E ： E → E ′ 满足 对 任意 动作 符号 f ∈ E 〈 ssn 〉 则 σ Ef ∈ E ′ 〈 σ Ss σ Ssn 〉 　 　 如果 我们 将 动作 看成 一个 特定 的 广义 数据类型 对象 标记 Ω 和 Ω ′ 的 基 标记 动作 扩充 分别 为 Σ ESEFE 和 Σ E ′ SE ′ FE ′ ， 标记 态射 可定义 为 σ σ Σ E σ A 　 　 以 对象 标记 为 “ 对象 ” 对象 标记 态射 为 “ 态射 ” Ω SFAE 上 的 恒等 态射 identutymorphism 为 idSidFidAidE 复合 态射 compositionofmorphism 为 相应 成分 态射 映射 的 复合 则 所有 对象 标记 的 “ 集合 ” 构成 一个 范畴 OSig 对 OSig 范畴 中 的 一个 对象 标记 Ω SFAE 我们 分别 以 Sort Ω ， Func Ω ， Attr Ω 和 Act Ω 来 表示 SFA 和 E 　 　 作为 保 结构 的 映射 同态 描述 建立 了 两个 对象 之间 的 关系 通常 将 一个 对象 作为 另 一个 对象 的 成分 我们 可以 将 对象 标记 态射 扩充 到 项 和 公式 　 　 定义 令 X 是 以 S 标识 的 变量 簇即 X ｛ Xs ｜ s ∈ S ｝ 对 任意 σ ： Ω → Ω ′ 我们 定义 X 为 以 S ′ 标识 的 变量 簇 X ′ 满足 X ′ s ′ ∪ ｛ Xs ｜ σ ss ′ ｝ 　 　 定义 函子 Sen ： OSig → Set 定义 为 ： 　 　 对 任意 Ω ∈ OSigSen Ω F Ω X ； 　 　 对 任意 σ ： Ω → Ω ′ Sen σ 为 从 F Ω X 到 F Ω ′ X 的 映射 满足 ： 　 　 〈 〉 对 项保 运算 即 　 　 　 对 任意 x ∈ Xs 则 Sen σ xx ； 　 　 　 对 任意 f ∈ FE 〈 s × × sn 〉 sti ∈ T Ω Xsii ≤ i ≤ n 则 Sen σ fttn σ Σ EfSen σ tSen σ tn ； 　 　 　 对 任意 f ∈ A 〈 s × × sn 〉 sti ∈ T Ω Xsii ≤ i ≤ n 则 Sen σ fttn σ AfSen σ tSen σ tn ； 　 　 　 对 任意 a ∈ T Ω XEt ∈ T Ω Xs 则 Sen σ ［ a ］ t ［ Sen σ a ］ Sen σ t ； 　 　 　 对 任意 t ∈ T Ω Xs 则 Sen σ ［ Init ］ t ［ Init ］ Sen σ t ； 　 　 　 对 任意 t ∈ T Ω Xs 则 Sen σ XtXSen σ t ； 　 　 　 对 任意 t ∈ T Ω Xs 则 Sen σ XtXSen σ t 　 　 〈 〉 对 公式 保 结构 即 　 　 　 tt ∈ T Ω Xss ∈ SE 则 Sen σ ttSen σ tSen σ t ； 　 　 　 a ∈ T Ω XE 则 Sen σ enabledaenabledSen σ a ； 　 　 　 a ∈ T Ω XEp ∈ F Ω X 则 Sen σ ［ a ］ p ［ Sen σ a ］ Sen σ p ； 　 　 　 p ∈ F Ω X 则 Sen σ ［ Init ］ p ［ Init ］ Sen σ p ； 　 　 　 p ∈ F Ω X 则 Sen σ XpXSen σ p ； 　 　 　 pq ∈ F Ω X 则 Sen σ pUqSen σ pUSen σ q ； 　 　 　 p ∈ F Ω X 则 Sen σ XpXSen σ p ； 　 　 　 pq ∈ F Ω X 则 Sen σ pUqSen σ pUSen σ q ； 　 　 　 p ∈ F Ω X 则 Sen σ pSen σ p ∈ F Ω X ； 　 　 　 pq ∈ F Ω X 则 Sen σ p → qSen σ p → Sen σ q ； 　 　 　 p ∈ F Ω Xx ∈ Xs 则 Sen σ x ： spx ： σ Σ EsSen σ p 　 　 定义 Ω 同态 给定 一个 对象 标记 Ω SFAE 两个 Ω 语义 解释 结构 Ω 同态 是 一 映射 簇 满足 ： 　 　 对 任意 f ∈ FE 〈 s × × sn 〉 sai ∈ sii ≤ i ≤ n 有 　 　 对 任意 f ∈ A 〈 s × × sn 〉 sai ∈ sii ≤ i ≤ n ω ∈ 有 hsf ω aan ′ fhE ω （ hsahsnan ； 　 　 对 任意 ω ∈ e ∈ E 有 ω e ∈ hE ω hEe ∈ ′ 其中 hs 是 hs 在 “ 串 ” 的 自然 扩充 　 　 以 Ω 语义 解释 结构 为 “ 对象 ” Ω 同态 为 “ 态射 ” 恒等 态射 和 复合 态射同 映射 的 恒等 与 复合 则 所有 的 Ω 语义 解释 结构 的 “ 集合 ” 构成 一个 范畴 Int Ω 　 　 进一步 地 我们 可以 扩充 Ω 同态 得到 Trace 结构 同态 　 　 定义 Trace Ω 同态 给定 一个 对象 标记 Ω SFAE 两个 Ω Trace Ω 结构 v ω ′ ′ v ′ ω ′ 则 Trace Ω 同态 h 是 Ω 同态 h ： → ′ 且 ω ′ hE ω 　 　 对 任一 对象 标记 Ω 以 相应 Trace Ω 结构 为 “ 对象 ” Trace Ω 同态 为 “ 态射 ” 则 所有 相应 于 Ω 的 Trace Ω 结构 的 “ 集合 ” 构成 一个 范畴 Mod Ω 　 　 定义 σ 归约 函子 给定 两个 对象 标记 Ω SFAE 和 Ω ′ S ′ F ′ A ′ E ′ 一个 对象 标记 态射 σ ： Ω → Ω ′ 我们 称函子 ｜ σ ： Mod Ω ′ → Mod Ω 为 σ 归约 函子 σ reductfunctor 满足 　 　 〈 〉 对 任一 Trace Ω ′ 结构 ′ ′ v ′ w ′ ∈ Mod Ω ′ ′ 沿 σ 的 归约 ′ σ ′ σ v ′ σ ω 是 一个 Trace Ω 结构 其中 　 　 　 对 任意 s ∈ SEv ′ σ sv ′ σ s ； 　 　 　 对 任意 s ∈ SE ′ σ s ′ σ s ； 　 　 　 对 任意 f ∈ FE 〈 s × × sn 〉 s σ σ ； 　 　 　 对 任意 f ∈ A 〈 s × × sn 〉 s ′ σ f ′ σ f ； 　 　 　 ′ σ ′ 　 　 〈 〉 对 任意 h ′ ： ′ → ′ 其 σ 归约 h ′ σ ： ′ σ → ′ σ 是 Trace Ω ′ 同态 其中 对 任意 s ∈ SEh ′ σ sh ′ σ s 　 　 我们 可以 将 ModInt 扩充 为 对象 标记 范畴 OSig 上 的 函子 functor 　 　 定义 函子 Mod ： OSig → Catop 定义 为 ： 　 　 对 任意 Ω ∈ OSigMod Ω 是 Trace Ω 结构 的 范畴 ； 　 　 对 任意 σ ： Ω → Ω ′ Mod σ ： Mod Ω ′ ） → Mod Ω 是 σ 归约 函子 它 将 Trace Ω ′ 结构 翻译 为 Trace Ω 结构 　 　 我们 可以 将 Mod σ Sen σ 缩写 为 σ 　 　 引理 满足条件 分别 给定 对象 标记 态射 σ ： Ω → Ω ′ Trace Ω ′ 结构 ′ 公式 p ∈ F Ω X 有 　 　 限于 篇幅 证明 从略 详细 讨论 可 参见 文献 ［ ］ 由该 引理 我们 得到 如下 结论 　 　 定理 Trace 演算 是 一 Institution 　 Ω 理论 　 　 下面 我们 引入 Ω 理论 和 Ω 理论 范集 　 　 定义 给定 一个 对象 标记 Ω ， 　 　 一个 Ω 理论 范集 是 一个二元 组 Ω F 其中 FF Ω X 是 一个 Ω 公式 集 ； 　 　 Ω 公式 集 F 的 闭 包为 所有 可以 从 F 推导 出 的 Ω 公式 的 集合 记为 F · ； 　 　 Ω 理论 Ω F 是 Ω 理论 范集 满足 FF · 　 　 定义 给定 两 Ω 理论 T Ω FT ′ Ω F ′ 一个 从 T 到 T ′ 的 理论 态射 是 一个 对象 标记 态射 σ ： Ω → Ω ′ 满足 对 任意 p ∈ T σ p ∈ T ′ 　 　 以 理论 为 “ 对象 ” 理论 态射 为 “ 态射 ” 恒等 态射 和 复合 态射同 对象 标记 范畴 则 所有 理论 的 “ 集合 ” 构成 一 范畴 Th 对 范畴 Th 中 的 元素 T Ω F 我们 分别 以 OSigT 和 AxiomsT 表示 T 的 两个 部分 　 　 引理 给定 一个 对象 标记 态射 σ ： Ω → Ω ′ Ω 理论 范集 Ω F 和 Ω ′ 理论 范集 Ω ′ F ′ 则 σ ： Ω F · → Ω ′ F ′ · 是 一 理论 态射 当且 仅 当 σ FF ′ · 　 　 证明 略 　 　 该 引理 告诉 我们 ， 要 验证 σ 是否 为 一 理论 态射 ， 只要 证明 对 任意 p ∈ F σ p ， 可以 由 F ′ 推导 出 即可 　 　 为 使 对象 演算 ［ ］ 具有 Trace 演算 ［ ］ 的 性质 即 满足 Institution 的 要求 我们 可以 类似 地 定义 一些 范畴 、 态射 和 函子 将 语义 解释 结构 替换 为 对象 语义 解释 结构 将 Trace 结构 替换 为 Ψ 结构 但 仅 有 这些 是 不够 的 　 　 若 我们 考虑 到 对象 封装 性以 对象 语义 解释 结构 为 模型 则 上述 满足条件 不 成立 这 是因为 对 一个 对象 标记 态射 σ ： Ω → Ω ′ 对 某些 E ′ 中 动作 在 E 中 没有 原象 即 对 Ω 而言 这些 动作 的 相应 动作 被 看成 外部 非 有效 动作 这样 ， 对 一种 Ω ′ 对象 语义 解释 结构 其 相应 的 ′ σ 不 一定 是 Ω 对象 语义 解释 结构 所以 对象 演算 ［ ］ 并 不是 一个 Institution 因此 ， 我们 所 述及 的 对象 规范 描述 “ 保 结构 ” 还 需 一个 附加条件 ， 即 对 任意 Ω ′ 对象 语义 解释 结构 ′ ′ σ 应是 一种 Ω 对象 语义 解释 结构 根据 Goguent 和 Burstall ［ ］ 的 定义 ， 我们 可以 将 这 一 要求 看成 是 一种 “ 数据 约束 ” dataconstraints 　 　 同 语句 公式 一样 约束 对 所 允许 的 模型 加以 限制 另外 一个 从 Ω 到 Ω ′ 的 对象 标记 态射 决定 了 从 Ω 约束 到 Ω ′ 约束 的 变换 　 　 从 另 一 角度看 即 证明 理论 方法 一种 Ω 理论 Ω T 若 满足 封装 性则 需要 有 如下 形式 的 公式 作为 Ω 定理 ： ∨ g ∈ Exggxg ∨ ∧ f ∈ Axf ［ a ］ fxffxf 其中 xgxf 表示 gf 的 相应 变参集 我们 可以 用 Enc Ω 表示 该 公式 事实上 该 公式 表示 在 任一 时刻 或者 有 一个 在 Ω 中 定义 的 动作 发生 或者 所有 属性 不 改变 而 这 一点 正是 封装 性 的 要求 然而 σ Enc Ω 却 不 一定 是 Ω ′ 定理 相应 于 Ω ′ 的 有效 动作 对 Ω 而言 可能 是非 有效 动作 所以 要 得到 理论 态射 我们 还 需 证明 　 对象 系统 　 　 多个 对象 可以 复合 成 “ 更大 的 ” 对象 — — 聚合 对象 我们 也 可视 这些 聚合 对象 为 一个 系统 相应 于 抽象层次 上 的 一 系统 的 各 成分 对象 并 不是 相互 独立 的 它们 之间 可能 存在 各种各样 的 相互作用 常见 的 相互作用 是 对象 共享 即 多个 对象 共享 相同 的 成分 对象 此外 相互作用 还 可以 通过 动作 共享 多个 对象 通过 同一 动作 同步 和 属性 共享 根据 对象 封装 性 要求 若 两个 或 多个 对象 共享 同一 属性 则 它们 必须 共享 所有 可能 修改 该 属性 的 动作 事实上 动作 共享 和 属性 共享 亦可 看做 对象 共享 　 对象 系统 描述 　 　 仍 以 文献 ［ ］ 中 的 生产 消费 问题 为例 PRODUCER 和 BUFFER 共享 动作 put 这个 共享 可 通过 定义 如下 的 辅助 对象 INTERFACE 来 表示 　 　 objectSpecINTERFACEITEM 　 　 　 Sorts ： ITEM 　 　 　 Functions ： 　 　 　 Attributes ： 　 　 　 Actions ： 　 　 　 　 putITEM 　 　 　 Axioms ： 　 　 End 该 对象 可 看成 是 PRODUCER 和 BUFFER 的 部分 对象 也就是说 PRODUCER 和 BUFFER 通过 界面 INTERFACE 相互作用 PRODUCER 和 BUFFER 组成 的 系统 可 看成 是 包含 PRODUCER 和 BUFFER 及其 相互作用 的 最小 对象 该 对象 可 通过 计算 INTERFACEPRODUCER 和 BUFFER 的 余 极限 colimit 而 得到 这里 它 是 一个 外 推 pushoutn 个 对象 描述 的 余 极限 给出 了 包含 这 n 个 对象 及其 相互作用 的 最小 对象 余 极限 在 同构 意义 下 是 唯一 的 忘却 函子 Sign ： Th → OSig 反映 了 余 极限 现在 我们 给出 由 PRODUCERCONSUMER 和 BUFFER 构成 的 系统 SYSTEM 的 描述 首先 我们 给出 对象 标记 　 　 ObjectSignatureSYSTEMITEMBOOLINT 　 　 　 Sorts ： 　 　 　 Functions ： 　 　 　 Attributes ： 　 　 　 　 ProduceritemConsumeritem ： ITEM 　 　 　 　 ProducerwaitingConsumerwaiting ： BOOL 　 　 　 　 count ： INT 　 　 　 Actions ： 　 　 　 　 produceITEM 　 　 　 　 consumerITEM 　 　 　 　 putITEM 　 　 　 　 getITEM 　 　 　 End 为 方便 起 见 我们 假设 对象 之间 的 同步 是 基于 相同 的 动作 名 从而 使 由 多个 对象 组成 的 系统 的 描述 和 推理 与 仅 有 单个 对象 时 一样 即 我们 前面 提出 的 描述语言 和 演算 仍然 适用 这样 当 我们 由 多个 对象 描述 构造 由 这些 对象 组成 的 系统 的 描述 时需 进行 适当 的 动作 名 的 换名 　 　 SYSTEM 的 公理 集是 由 PRODUCERCONSUMER 和 BUFFER 的 程序 公理 经 适当 换名 而 得 另外 如下 所示 的 公理 集 还 隐含 了 个 保 封装 性 公理 这些 保 封装 性 公理 为 系统 整体 特性 推理 提供 了 基础 　 　 动作 producei 的 作用 效果 　 　 p ： ［ producei ］ Produceritemi 　 　 p ： ［ producei ］ Producerwaitingt 　 　 　 　 动作 consumei 的 作用 效果 　 　 cl ： ［ consumei ］ Consumerwaitingf 　 　 　 　 动作 puti 的 作用 效果 　 　 p ： ［ puti ］ Producerwaitingf 　 　 b ： ［ puti ］ BuffercountBuffercount 　 　 　 　 动作 geti 的 作用 效果 　 　 c ： ［ geti ］ Consumeritemi 　 　 c ： ［ geti ］ Consumerwaitingt 　 　 b ： ［ geti ］ BuffercountBuffercount 　 　 　 　 初始条件 　 　 p ： ［ Init ］ waitingf 　 　 c ： ［ Init ］ Consumerwaitingf 　 　 b ： ［ Init ］ Buffercount 　 　 　 　 动作 producei 执行 的 必要条件 　 　 p ： enabledproducei → Producerwaitingf 　 　 　 　 动作 consumei 执行 的 必要条件 　 　 c ： enabledconsumei → Consumeritemi ∧ Consumerwaitingt 　 　 　 　 动作 puti 执行 的 必要条件 　 　 p ： enabledputi → Produceritemi ∧ Producerwaitingt 　 　 b ： enabledputi → Buffercount ＜ size 　 　 　 　 动作 geti 执行 的 必要条件 　 　 c ： enabledgeti → Consumerwaitingf 　 　 b ： enabledgeti → Buffercount ＞ 　 　 　 　 动态 约束 　 　 p ： Producerwaitingt → FputProduceritem 　 　 c ： Consumerwaitingt → FconsumeConsumeritem 　 　 b ： puti → Fgeti 　 　 然而 在 构造 系统 时 有时 我们 需要 使 多个 对象 与 同一 对象 ob 相互 独立 地 通信 并 使 该 对象 执行 相同 的 动作 由于 独立 要求 相应 的 对象 使用 不同 的 动作 名而 同步 通信 则 要求 进行 同步 通信 的 各 对象 的 应 动作 有 相同 的 动作 符号 名 因此 我们 必须 扩充 ob 的 对象 标记 和 描述 这 可 由 增加 动作 符号 名 和 相应 程序 公理 而 得 如 对 BUFFER 我们 可 增加 动作 符号 名 getITEMgetITEM 和 相应 公理 ： 　 　 ab ： geti → geti 　 　 ab ： geti → geti 　 　 ab ： geti ∧ geti 　 　 ab ： geti → geti ∨ geti 其中 公理 ab 和 ab 表示 我们 给 BUFFER 引入 新 的 行为 仅 是 对 动作 get 换名 特化 因此 保 封装 性 ； 公理 ab 表示 getget 互斥 ； 而 公理 ab 则 阻止 对 BUFFER 的 进一步 扩充 　 　 我们 也 可以 引入 对象 标识 进行 “ 参数 化 ” 即 　 　 ab ′ ： pgetidi → geti 　 　 ab ′ ： pgetidi ∧ pgetid ′ i → idid ′ 　 对象 系统 推理 　 　 根据 Goguen 和 Burstall 关于 Institution 的 结论 我们 可以 将 一 复杂 系统 分解 分别 对系统 的 各 成分 对象 进行 描述 和 推理 并 将 由 成分 对象 推理 所得 的 结论 作为 系统 整体 特性 推理 的 引理 我们 有 下面 的 定理 　 　 定理 给定 两个 对象 标记 Ω SFAE 和 Ω ′ SF ′ A ′ E ′ 一个 对象 标记 态射 σ ： Ω → Ω ′ 　 　 F Ω p σ F Ω ′ σ p ； 　 　 F Ω sp σ F Ω ′ s σ p ； 　 　 F Ω lp σ F Ω ′ l σ p ； 　 　 F Ω ep σ F σ Enc Ω Ω ′ e σ p ； 　 　 F Ω sep σ F σ Enc Ω Ω ′ se σ p ； 　 　 F Ω lep σ F σ Enc Ω lee Ω ′ σ p 其中 上标 表示 相应 推导 为 Ω 或 Ω ′ 推导 ； 下标 slese 和 le 分别 表示 相应 推导 为 安全性 推导 、 活动性 推导 、 封装 性 推导 、 带 封装 性 的 安全性 推导 和 带 封装 性 的 活动性 推导 等 　 　 定理 给定 两个 对象 标记 Ω SFAE 和 Ω ′ S ′ F ′ A ′ E ′ 一个 对象 标记 态射 σ ： Ω → Ω ′ 我们 有 如下 规则 ： 　 　 struct ∪ ｛ ［ xg ］ fxxnfxxn ｝ Ω ′ σ Enc Ω 其中 g ∈ E ′ σ Ef ∈ A ′ 〈 s × × sn 〉 sxg ∈ XE ′ xi ∈ X σ si ≤ i ≤ nn ≥ 　 　 结论 是 显然 的 该 定理 指出 若 在 Ω ′ 中 新 增加 的 动作 不 修改 相应 于 Ω 中 属性 的 Ω ′ 属性 对 继承 而言 是 继承 属性 对 聚合 而言 是 成分 对象 的 属性 则 对象 标记 态射 σ 保 封装 性 　 　 对于 生产 消费 问题 令 相应 于 PRODUCERCONSUMERBUFFER 和 SYSTEM 的 对象 标记 分别 为 Ω p Ω c Ω b 和 Ω s 以及 对象 标记 态射 σ p ： Ω p → Ω s σ c ： Ω b → Ω s 和 σ b ： Ω c → Ω s 不难 验证 ： SYSTEM Ω s σ pEnc Ω pSYSTEM Ω s σ cEnc Ω cSYSTEM Ω s σ bEnc Ω b 　 　 例 ： SYSTEM Ω sproducei → Fconsumei 　 　 证明 ： 由 文献 ［ ］ 中例 我们 有 PRODUCER Ω pproducei → Fputi 　 　 由 b 我们 有 BUFFER Ω bputi → Fgeti 　 　 现在 我们 来 证明 PRODUCER Ω cgeti → Fconsumei 　 　 geti → ［ geti ］ waitingt ∧ ［ geti ］ itemi 　 　 　 　 公式 geti 的 定义 　 　 ［ geti ］ waitingt ［ geti ］ waitingt 　 　 　 　 　 　 “ ” “ t ” 是 严格 的 　 　 geti → ［ geti ］ waitingt ∧ ［ geti ］ itemi 　 　 　 prep 　 　 ［ a ］ itemitem ∧ ［ a ］ waitingwaiting ∨ kgetk ∨ lconsumel 　 　 封装 性 　 　 enabledgeti → waitingf 　 　 　 　 　 　 　 　 　 　 　 　 　 　 c 　 　 lconsumel ∨ waitingt ∧ enableda → 　 　 　 　 　 　 ［ a ］ itemitem ∧ ［ a ］ waitingwaiting 　 　 　 　 　 　 　 　 geti → Xwaitingt ∧ itemiUconsumei 　 　 　 　 　 　 　 clive 　 　 geti → Fconsumei 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 prep 又 因为 　 　 SYSTEM Ω s σ pEnc Ω p 　 　 SYSTEM Ω s σ cEnc Ω c 　 　 SYSTEM Ω s σ bEnc Ω b 所以 有 　 　 SYSTEM Ω sproducei → Fputi 　 　 SYSTEM Ω sputi → Fgeti 　 　 SYSTEM Ω sgeti → Fconsumei 由 prep 可得 SYSTEM Ω sproducei → Fconsumei 　 　 通常 我们 省略 推导 “ ” 的 上下 标 　 对象 精化 　 　 前面 我们 讨论 了 对象 的 结构化 描述 和 推理 下面 讨论 有关 对象 精化 的 问题 一般而言 有 两类 实现 抽象 描述 的 方法 即 ： 用 已有 的 具体 描述 实现 其他 的 抽象 描述 ； 可 执行 的 描述 第类 方法 涉及 到 一系列 设计 决策 这些 决策 包括 如何 给出 抽象 对象 的 具体 表示 等 有关 这 类 方法 的 讨论 很多 如 基于 求精 refinement 的 方法 、 基于 行为 抽象 的 方法 等 第类 方法 属于 编译 或 解释 方法 这样 的 方法 将 描述语言 看做 程序设计 语言 将 规范 描述 看做 模块 基于 等式逻辑 的 项 重写 就是 这 类 方法 的 一个 典型 　 　 面向对象 的 软件 构造 不但 要求 允许 使用 现有 具体 对象 构造 系统 还 要求 提供 使用 低层 对象 来 精化 高层 对象 的 机制 前者 可 称为 水平 结构化 horizontalstructuring 后者 可 称为 垂直 结构化 verticalstructuring 　 　 这里 我们 所 采用 的 是 基于 求精 的 实现 方法 　 　 在 进行 抽象 对象 精化 时 通常 将 具体 对象 组合 起来 构成 中间 对象 然后 对 该 中间 对象 的 行为 作 进一步 限制 如 事务 约束 以 满足 特定 的 抽象 对象 行 约束 我们 把 这种 为 满足 特定 的 抽象 对象 行 约束 而 对 中间 对象 的 行为 的 限制 称为 精化 reification 　 抽象 对象 的 精化 　 　 抽象 对象 的 精化 包括 抽象 属性 在 具体 属性 上 的 实现 、 抽象 动作 在 具体 动作 上 的 实现 和 初始条件 的 实现 显然 抽象 对象 Abs 的 属性 来自 于 那些 具体 对象 其 动作 对应 于 这些 具体 对象 动作 上 的 事务 transaction 在 精化 对象 时 我们 通常 将 多个 具体 对象 复合 成 一个 大 对象 Con ； 然后 通过 增加 必要 的 导出 属性 和 事务 要求 公理 来 扩充 Con 得到 对象 Tmp ； 最后 必须 证明 存在 一个 从 Tmp 到 Abs 的 “ 精化 ” 即用 Tmp 的 动作 “ 编码 ” Abs 的 动作 　 　 我们 以 对象 BUFFER 为例 说明 对象 精化 及其 正确性 我们 用 一个 数组 和 两个 指针 来 实现 BUFFER 　 　 ObjectSpecPOINTERINT 　 　 　 Sorts ： 　 　 　 Functions ： 　 　 　 Attributes ： 　 　 　 　 v ： INT 　 　 　 Actions ： 　 　 　 　 inc 　 　 　 Axioms ： 　 　 　 p ： ［ inc ］ vv 　 　 End 　 　 ObjectSpecARRAYITEMINDEX 　 　 　 Sorts ： 　 　 　 Functions ： 　 　 　 Attributes ： 　 　 　 　 v ： INDEX → ITEM 　 　 　 Actions ： 　 　 　 　 putINTITEM 　 　 　 　 getINTITEM 　 　 　 Axioms ： 　 　 　 　 a ： ［ putki ］ vmodsizeki 　 　 　 　 a ： ［ getki ］ vmodsizelvmodsizel 　 　 　 　 modsizel ≠ modsizek 　 　 　 　 a ： putki ‖ putli → modsizekl 　 　 　 　 a ： enabledgetki → vmodsizeki 　 　 End 其中 INDEX 为 ［ size ］ modsize 为 以 size 取模 公理 a 不 允许 对 数组 并发 赋值 Con 包含 两个 指针 实例 和 一个 数组 实例 Con 的 标记 包含 它们 不 相交 的 并 　 　 ObjectSpecConITEMINDEX 　 　 　 Sorts ： 　 　 　 Functions ： 　 　 　 Attributes ： 　 　 　 　 Arrayv ： INDEX → ITEM 　 　 　 　 Headv ： INDEX 　 　 　 　 Tailv ： INDEX 　 　 　 Actions ： 　 　 　 　 ArrayputINDEXITEM 　 　 　 　 ArraygetINDEXITEM 　 　 　 　 Headinc 　 　 　 　 Tailinc 　 　 　 Axioms ： 　 　 　 　 Arraya ～ Arraya 　 　 　 　 Headp 　 　 　 　 Tailp 　 　 End 现在 我们 扩充 Con 首先 我们 引入 属性 count 作为 Con 属性 的 导出 属性 满足 countHeadvTailv 　 　 由 count 的 实现 不难 得到 HeadvTailv ＜ size → count ＜ sizeTailv ＜ Headv → count ＞ 　 　 初始条件 ： 　 　 i ： ［ Init ］ Headv 　 　 i ： ［ Init ］ Tailv 　 　 下 一步 我们 考虑 抽象 动作 的 实现 对于 抽象 动作 put 我们 可 将 它 实现 为 指针 Head 的 前移 和 对 数组 的 赋值 即 ： 　 　 i ： puti → Headinc 　 　 i ： puti → ArrayputHeadvi 　 　 i ： enabledgeti → HeadvTailv ＜ size 　 　 对于 抽象 动作 get 我们 可 将 它 实现 为 指针 Tail 的 前移 和 从 数组 中 取值 即 ： 　 　 i ： geti → Tailinc 　 　 i ： geti → ArraygetTailvi 　 　 i ： enabledgeti → Tailv ＜ Headv ∧ iArrayvTailv 　 　 另外 上面 我们 仅 给出 对 putget 实现 的 一些 要求 并 没有 完全 给出 它们 的 具体 实现 其中 指针 前移 和 从 数组 赋值 取值 可以 “ 并发 ” 执行 即 ArrayputHeadvi ‖ HeadincArraygetTailvi ‖ Tailinc 也 可以 处理 成 一个 事务 将 事务 看成 一个 原子 动作 即 ArrayputHeadvi ； Headinc ， ArraygetTailvi ； Tailinc 在 事实 实现 时需 满足 事务 的 原子 性 这里 原子 性可 表示 为 如下 约束 ： ArrayputHeadvi → XHeadincArraygetTailvi → XTailincHeadinc → XiArrayputHeadviTailinc → XiArraygetTailvi 最后 相应 于 动态 约束 我们 有 　 　 i ： Headinc → FTailinc 从 实际 实现 来看 我们 可以 给 “ → ” 以 更 清楚 的 解释 对于 两 动作 a 和 ba → b 可 看成 是 “ 传播 ” propagate 或 过程 调用 　 对象 精化 的 正确性 　 　 现在 我们 必须 证明 抽象 对象 BUFFER 的 精化 的 正确性 即 精化 满足 抽象 对象 的 描述 　 　 我们 以 b 为例 这里 我们 仅 考虑 合法 行为 假设 我们 将 抽象 动作 put 精 化为 一 事务 ： ArrayputHeadvi ； Headinc 那么 我们 证明 b 即 是 证明 其 在 实现 中 的 翻译 ： ［ ArrayputHeadvi ； Headinc ］ HeadvTailvHeadvTailv 这里 ［ ArrayputHeadvi ； Headinc ］ 意 为 ［ ArrayputHeadvi ］ ［ Headinc ］ 　 　 我们 有 ： 　 　 ［ Headinc ］ HeadvHeadv 　 　 　 　 　 　 　 　 　 　 　 　 　 Headp 　 　 ［ ArrayputHeadvi ］ HeadvHeadv 　 　 　 　 　 　 　 　 　 Head 的 封装 性 　 　 ［ ArrayputHeadvi ］ ［ Headinc ］ Headv 　 　 　 　 　 　 　 ［ ArrayputHeadvi ］ Headv 　 　 　 　 　 　 　 　 和 “ ” 是 严格 的 　 　 ［ ArrayputHeadvi ］ ［ Headinc ］ HeadvHeadv 　 　 替换 　 　 ［ ArrayputHeadvi ］ ［ Headinc ］ TailvTailv 　 　 　 Tail 的 封装 性 　 　 ［ ArrayputHeadvi ； Headinc ］ HeadvTailv 　 　 　 　 　 　 　 ［ ArrayputHeadvi ］ ［ Headinc ］ Headv 　 　 　 　 　 　 　 ［ ArrayputHeadvi ］ ［ Headinc ］ Tailv 　 　 　 “ ” 是 严格 的 　 　 ［ ArrayputHeadvi ； Headinc ］ HeadvTailv 　 　 　 　 　 　 　 　 HeadvTailv 　 　 　 　 　 　 　 　 　 　 　 　 　 　 替换 　 　 更 一般 地 我们 可以 忽略 一些 实现 细节 不管 动作 的 实现 是 “ 并发 ” 还是 “ 事务 ” 为此 类似 于 对象 的 数据 封装 性 我们 可 对 具体 对象 的 行为 加以 限制 使 其 只 响应 抽象 动作 这 也 可以 看成 是 一种 封装 性 因此 我们 有 ： 　 　 i ： Headinc → iputi 　 　 i ： Tailinc → igeti 　 　 i ： Arrayputki → puti 　 　 i ： Arraygetki → puti 　 　 由此 我们 可以 得到 一些 特性 如 　 　 tx 　 ［ a ］ ArrayvpArrayvp ∨ modsizepHeadv 　 　 证明 ： 　 　 Arrayputki → ArrayputHeadvi 　 　 　 　 　 　 　 　 　 　 　 ii 　 　 Arraygetki → modsizekHeadv 　 　 　 　 　 　 　 　 　 　 　 Arraya 　 　 ［ a ］ ArrayvpArrayvp ∨ Arrayputqi ∧ modsizepq 　 　 Array 的 封装 性 　 　 ［ a ］ ArrayvpArrayvp ∨ modsizepHeadv 　 　 　 　 　 prep 　 　 由 任何时刻 对 数组 的 赋值 只能 是 ArrayputHeadv 即仅 数组 的 modsizeHeadv 单元 可以 被 修改 其他 的 赋值 动作 被 藏 hide 起来 另外 由 i 和 Array 的 封装 性可得 ， 　 　 tx 　 ［ α ］ ArrayvpArrayvp ∨ puti ． 　 　 类似 地 由 指针 描述 的 封装 性 我们 有 ： ［ a ］ HeadvHeadv ∨ Headinc ， ［ a ］ TailvHeadv ∨ Tailinc 　 　 我们 可以 得到 ： 　 　 tx 　 ［ a ］ HeadvHeadv ∨ puti 　 　 tx 　 ［ a ］ TailvHeadv ∨ geti 也就是说 除非 执行 了 putgetHeadvTailv 将 保持 不变 　 　 这样 我们 证明 b 即 是 证明 其 在 实现 中 的 翻译 ： ［ puti ］ HeadvTailvHeadvtailv 　 　 ［ puti ］ HeadvTailv ［ puti ］ Headv ［ puti ］ Tailv 　 　 　 － 是 严格 的 　 　 ［ Headinc ］ HeadvHeadv 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 Headp 　 　 ［ puti ］ HeadvHeadv 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 i 　 　 ［ puti ］ TailvTailv 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 tx 　 　 ［ puti ］ HeadvTailvHeadvTailv 　 　 　 　 　 　 　 　 　 替换 　 　 其他 程序 公理 类似 可证 　 结论 　 　 在 对象 语义 模型 下 对象 被 定义 为 封装 属性 和 行为 的 实体 它 是 静态 结构 和 动态 行为 的 有机 组合 对象 态射 刻画 了 对象 之间 的 关系 包括 对象 静态 结构 之间 的 关系 和 对象 动态 行为 之间 的 关系 对象 精化 则 提供 对象 的 垂直 结构化 机制 这样 在 设计 的 每 一 层次 对象 或 对象 系统 都 可 看成 是 由 一些 对象 通过 继承 、 聚合 等 构造 而 得 而 在 设计 的 低层 可以 进一步 精化 这些 对象 对象 精化 也 是 建立 在 对象 的 封装 性 之上 的 即 具体 对象 只 响应 相应 抽象 对象 的 动作 这是 一种 动作 封装 性 最后 总结 一下 结构化 对象 演算 系统 的 特点 　 　 既 可以 方便 地 描述 和 推理 对象 的 静态 特性 也 可以 方便 地 描述 和 推理 对象 的 动态 特性 　 　 需求 requirement 描述 和 规范 specification 描述 相一致 对 对象 的 需求 规模 和 对象 特征 的 规范 描述 同样 使用 约束 公式 对象 语义 描述 来 完成 　 　 结构化 使用 对象 演算 既 可以 描述 和 推理 对象 的 构造 水平 结构化 也 可以 描述 和 推理 对象 的 精化 垂直 结构化 　 　 不 依赖于 具体 实现 考虑 对象 演算 系统 是 一个 抽象 系统 它 将 对象 的 状态 变迁 抽象 为 具体 原子 性 的 动作 而 不管 它 是 基于 过程 调用 方式 还是 基于 消息 传送 方式 也 不管 消息 传送 是 同步 还是 异步 的 　 　 统一 对象 的 局部 演算 和 全局 演算 于 同一 逻辑 演算 系统 框架 中 对象 演算 既 可以 方便 地 分别 描述 和 推理 单个 对象 也 可以 方便 地 描述 和 推理 对象 的 相互作用 避免 了 其他 面向对象 方法 的 局部 演算 局部 描述 系统 和 全局 演算 全局 描述 系统 的 区分 我们 认为 这样 的 区分 是 不 自然 ， 且 违背 面向对象 的 原则 　 本文 研究 得到 国家自然科学基金 和 国家 高科技 项目 基金 资助 本文 通讯联系 人 ： 黄涛 北京 中国科学院 软件 研究所 计算机科学 开放 研究 实验室 作者简介 ： 黄涛 年生 博士 ， 研究员 主要 研究 领域 为 软件工程 对象 技术 分布 计算 程序设计 语言 及 环境 　 　 　 　 　 钱军 年生 博士生 主要 研究 领域 为 面向对象 的 理论 和 技术 分布 对象 计算 形式化 方法 　 　 　 　 　 王栩年生 博士生 主要 研究 领域 为 面向对象 的 理论 和 技术 分布 对象 计算 作者 单位 ： 黄涛 ， 钱军 ， 王栩 （ 中国科学院 软件 研究所 计算机科学 开放 研究 实验室 北京 ） 　 　 　 　 　 黄涛 ， 钱军 ， 王栩 （ 中国科学院 软件 研究所 对象 技术 中心 　 北京 　 ） 参考文献 ： ［ ］ 黄涛 钱军 倪彬 Trace 演算 软件 学报 ～ HuangTaoQianJunNiBinTracecalculusJournalofSoftware ～ ［ ］ 黄涛 钱军 周桓 对象 演算 I 软件 学报 ～ HuangTaoQianJunZhouHuanObjectcalculus Ⅰ JournalofSoftware ～ ［ ］ GoguenJABurstallRMIntroducinginstitutionsInClarkeEKozenDedsProceedingsoftheLogicofProgrammingLNCSBerlinSpringerVerlag ［ ］ 黄涛 对象 形式 语义 理论 研究 ［ 博士学位 论文 ］ 合肥 中国科技大学 HuangTaoTheoreticalresearchonobjectformalsemantics ［ PhDThesis ］ HefeiUniversityofScienceandTechnologyofChina 收稿 日期 ： ， 修改 日期 ：
计算机 研究 与 发展 JOURNALOFCOMPUTERRESEARCHANDDEVELOPMENT 　 Vol 　 No 　 PNDPolya 类比 实现 技术 摘 　 要 ： 从 认识论 和 方法论 的 角度 来看 ， 分类 不是 认识 事物 解决问题 的 唯一 方法 ， 类比 同样 十分 重要 然而 传统 的 继承 只 体现 分类 的 方法 自行设计 的 面向对象 语言 NDPolya 通过 引入 新 的 继承 机制 — — 柔性 继承 来 支持 类比 方法 使用 柔性 继承 机制 ， 程序员 能以 描述 事物 或 问题 间 相似性 的 方式 进行 软件开发 文中 简要 介绍 了 NDPolya 的 柔性 继承 设施 ， 并 在 此基础 上 具体 地 讨论 了 该 机制 的 类比 实现 技术 关键词 ： 柔性 继承 ， NDPolya ， 类比 ， 实现 分类号 ： TPTHEIMPLEMENTATIONTECHNIQUESOFTHEANALOGYINNDPOLYAMAXiaoXing ， TANGBao ， TAOXianPing ， YIBo ， L ü JianStateKeyLaboratoryforNovelSoftwareTechnologyNanjingUniversityNanjingInstituteofComputerSoftwareNanjingUniversityNanjingAbstract ： AnalogyisaveryimportantmethodforcognitionandsolvingproblemsbesidesclassificationintheviewofepistemologyandmethodologyHoweverthetraditionalinheritanceonlyreflectstheideaofclassificationTheNDPolyalanguagesupportstheanalogyinobjectorientedprogrammingbyprovidinganewinheritancemechanism — — softinheritancewithwhichonecandevelopanewsoftwaresystembydescribingitssimilaritytoanexistingsystemAftergivingabriefintroductiontothesoftinheritancefacilitiesintheselfdesignedlanguageNDPolyatheimplementationtechniquesofthesoftinheritancearediscussedindetailKeywords ： softinheritanceNDPolyaanalogyimplementation ▲ 　 引 　 　 言 　 　 所谓 类比 是 指 思考者 带 着 某种 意图 去 考察 对象 间或 系统 间 的 相似性 这里 的 意图 就是 希望 把 相似 处 化为 明确 的 对应 关系 ， 并且 希望 这种 对应 关系 能 帮助 我们 理解 或 解决 所 关心 的 问题 ［ ］ 类比 是 认识 世界 的 重要 方法 ， 也 是 解决问题 的 有效 手段 ， 它 与 分类 方法 一起 构成 认识论 中 不可分割 的 两个 方面 ［ ］ 　 　 继承 是 支持 面向对象 风范 的 核心 机制 之一 ， 它 不但 构成 了 多态 对象 计算 的 基础 ， 还 为 代码 复用 提供 了 有效 的 途径 然而 ， 现有 面向对象 语言 的 继承 机制 是 机械 的 、 硬性 的 继承 ， 它 在 概念 上 体现 的 是 分类 分析方法 ， 而 不能 支持 认识论 中 同样 也 很 重要 的 类比 方法 当 人们 使用 类比 来 考察 新 事物 解决 新 问题 时 ， 就 复用 了 旧 事物 的 概念 和 旧 问题 的 解决 方法 ， 但是 这种 复用 复用 的 是 已有 概念 或 已有 方法 的 某种 抽象 ， 而 不是 其 本身 ， 也就是说 ， 复用 了 其 高阶 特征 现有 的 继承 机制 对此 无能为力 　 　 为此 ， 我们 以 类比 理论 和 方法 为 基础 ， 提出 了 一种 新型 的 继承 机制 — — 柔性 继承 机制 采用 这种 新型 的 柔性 继承 机制 ， 可 在 面向对象 语言 里 通过 描述 当前 类 与 另 一 已 实现 的 类 之间 的 相似性 和 相 异性 的 方式 来 定义新 类 ， 而 由 机器 通过 类比 分析 和 类比 推导 来 （ 部分 地 ） 自动 生成 这个 新类 的 实现 ， 从而 得到 对源类 性质 及 代码 的 复用 这样 就 将 类比 程序设计 的 思想 应用 于 面向对象 程序设计 方法 ， 从而 提高 了 复用 的 层次 和 深度 　 　 NDPolya 是 我们 设计 的 一个 面向对象 语言 ， 它 提供 了 一组 支持 类比 的 柔性 继承 设施 ， 用户 可 使用 它们 来 描述 目标 类 与 源类 的 相似性 ， 然后 由 系统 进行 类比 分析 和 类比 推导 ， 自动 完成 该类 的 实现 关于 柔性 继承 的 概念 和 NDPolya 语言 的 设计 将 另文 详细 讨论 ， 本文 只 对 其作 简要 介绍 柔性 继承 机制 是 一种 新 的 语言 机制 ， 其 类比 实现 技术 的 研究 是 一个 十分困难 的 问题 本文 工作 的 重点 主要 是 基于 我们 在 对 类比 理论 和 方法 多年 研究成果 ［ ～ ］ ， 提出 了 一种 基于 类 的 “ 商 结构 ” 的 类比推理 方法 ， 通过 这个 方法 ， 我们 不但 可以 支持 不同 应用领域 间 的 类比 ， 还 可以 通过 类比 来 解决 比原 问题 更 复杂 的 类似 问题 ， 较 好 地 实现 了 NDPolya 语言所 提供 的 柔性 继承 机制 　 NDPolya 中 的 类比 设施 　 　 对 两个 对象 相似 的 一种 基本 的 理解 是 其 某些 属性 （ 关于 对象 的 一元 或 可 化为 一元 的 谓词 ） 相似 同样 ， 描述 两个 类 相似 ， 要 描述 其 特征 （ 包括 属性 和 程式 ） 的 相似性 在 类比 形式 理论 中 对象 属性 的 相似 常常 简单 地用 同名 谓词 来 表达 ， 而 两个 相似 类 可能 针对 不同 领域 的 不同 问题 ， 不但 其 相似 特征 可能 不同 名 ， 其 相似 的 方式 也 多种多样 例如 ， 长方体 与 长方形 可以 类比 ， 但 长方形 的 顶点 是 二维 点 而 长方体 的 顶点 是 三维 点 ； 若 将 原子结构 系统 与 恒星 星系 系统 类比 ， 则 原子 中 的 电子 与 星系 中 的 行星 相似 ， 其 相似 的 方式 是 电子 因其 所带 电荷 而 受 电荷 引力 的 作用 ， 而 行星 因 其 质量 而 受 万有引力 的 作用 我们 提供 了 两个 关键字 as 和 where 来 描述 相似 特征 及其 相似 方式 上述 第二个 例子 可 表达 为 ： 　 　 class 原子结构 系统 ～ 恒星 星系 系统 　 　 　 　 　 电子 类型 电子 as 行星 类型 行星 where 电子 电量 ～ 行星 质量 　 　 　 　 　 … … 　 　 在 这里 ， 我们 实际上 已 放宽 了 传统 继承 不能 在 子类 中重 定义 属性 的 限制 　 　 Gentner 认为 ［ ］ ： 在 类比 中 ， 系统 中 的 关系 比 属性 重要 得 多 因为 属性 是 孤立 的 、 表面 的 性质 ， 关系 则 是 系统 中 的 结构 ， 类比 主要 建立 在 关系 的 相似 上 进而 ， 刻画 关系 与 关系 间 依赖 的 高阶 关系 更能 揭示 系统 的 内在 本质 ， 它 往往 反映 系统 的 动态 特征 ， 因而 在 类比 中 尤为重要 所以 ， 仅 描述 两个 类 的 （ 部分 ） 特征 之间 的 相似 是 不够 的 ， 应该 在 两个 类 的 逻辑 结构 之间 建立 明确 的 对应 关系 例如 平面 上 的 点 DP 和 空间 上 的 点 DP 类似 ， 可以 建立 DP 和 DP 之间 的 类比 对应 ： 首先 ， DP 中 的 xy 相似 ， 应划 为 一组 ， 同样 DP 中 的 xyz 相似 ， 也 划为 一组 ， 而 在 这 两个 组 之间 建立 对应 对应 地 ， move 的 参数 也 要划 为 一组 ， … … 这样 ， 我们 就 有 图 的 对应 从 这个 例子 可以 看出 ， 我们 在 建立 对应 前 将 类 中 相似 的 属性 划分 成组 ， 从而 将类 的 平面 的 、 具体 的 结构 转换 为 一种 抽象 的 “ 商 ” 结构 ， 这种 商 结构 在 某种程度 上 体现 了 类 中 各 特征 间 高阶 逻辑关系 如果 在 两个 类 的 商 结构 之间 建立 了 同构 关系 ， 则 我们 就 认为 它们 之间 就 建立 了 良好 的 类比 对应 Gentner 结构 映射 structuremapping 的 系统性 原理 systematicityprinciple 指出 ， 在 高阶 关系 联系 下 的 关系 移植 到 靶 系统 中 具有 较 高 的 可信度 我们 在 同构 的 商 结构 下 推导 出 的 方法 体 代码 也 应 具有 较 高 的 正确性 图 　 　 　 那么 ， 怎样 得到 类 的 商 结构 或者说 用户 如何 向 系统 提供 属性 分组 的 信息 呢 ？ 我们 在 Polya 中 提供 了 种 手段 来 描述 分组 信息 第种 方法 是 一种 程序 行文 上 的 暗示 ， 例如 上述 DP 类中 的 x 和 y 在 变量 说明 时 写作 　 　 　 　 intxy 而 不 写作 　 　 intx 　 　 inty 另一方面 不是 同组 的 同 类型 变量 不应 在 同 一条 变量 说明 语句 中 说明 这 实际上 是 一种 良好 的 程序 书写 风格 第种 方法 用于 方法 声明 的 形式 参数表 中 参数 的 分组 ， 我们 用 逗号 来 分隔 各个 参数 ， 而用 分号 来 分隔 不同 的 组第种 方法 用于 说明 新增 属性 与 其它 属性 的 相似性 ， 例如 ， 在 上述 DP 类中 对 z 的 说明 应 写作 ： 　 　 intzlikexy 这条 语句 在 声明 一个 新 变量 z 的 同时 指出 了 z 与 x 及 y 相似 ， 应划 为 一组 由于 进行 类比 的 两个 类 未必 在 所有 方面 都 相似 ， 有时 我们 只 需要 进行 部分 类比 ， 此时 就 应该 在 （ 柔性 ） 继承 时 隐藏 源类 的 某些 域 ， 使 某些 属性 和 方法 不 复 可见 ： 　 　 discardsSomethingNotNeeded 　 　 用户 通过 上述 手段 描述 源类 与 目标 类 之间 的 相似性 ， 系统 利用 这些 信息 在 两个 类 之间 建立 类比 对应 关系 ， 并 通过 类比推理 自动 完成 类比 方法 的 实现 例如 上述 DP 中 的 move 方法 只 需作 如下 声明 即可 ： 　 　 DPmoveintdxintdyintdzfromDPmoveintdxintdy 而 move 方法 的 具体 实现 即 其 代码 由 系统 经 类比 推导 得出 更加 具体 的 例子 请 参见 附录 　 　 在 这里 ， 用户 根据 他 对 现实 世界 事物 相似性 的 认识 来 定义 源类 与 目标 类 之间 的 相似性 ， 因而 原则上 他 自己 需对 类比 的 合理性 负责 而 柔性 继承 机制 将 负责 检查用户 所 提供 的 类比 信息 是否 矛盾 （ 将 导致 某些 类比 对应 无法 建立 ， 或者 推导 出 的 代码 有 类型 错误 ） 以及 类比 信息 是否 充分 （ 足以 进行 类比 推导 ） 当 类比 信息 不 充分 或者 有 矛盾 时 ， 系统 将 提示 用户 进一步 考察 类比 是否 合理 ， 他 对 类比 的 描述 是否 恰当 、 完整 　 系统 实现 　 　 我们 的 整个 系统集成 了 NDPolya 编辑器 ， 从 Polya 到 Java 的 翻译 系统 和 Java 的 编译 、 解释 运行 系统 其中 翻译 系统 是 关键 ， 类比推理 的 工作 就是 在 其中 实现 的 在 两个 类 之间 进行 类比 包含 两 方面 的 工作 ： 首先 ， 要 精确 定义 两个 类 之间 的 相似 关系 ， 也 就 是从 （ 部分 ） 结构 的 类比 对应 得出 完整 结构 的 类比 对应 ， 这 属于 类比 分析 ； 然后 将源类 （ 基 系统 ） 的 性质 通过 类比 对应 移植 到 目标 类 （ 靶 系统 ） 中 ， 从而 得到 目标 类 的 实现 ， 也 就是 类比 推导 用户 提交 的 Polya 源程序 同 它 用到 Java 类比 源程序 结合 成为 完整 的 Polya 源程序 提交 给 分析器 ， 经 语法分析 和 类比 分析 生成 一棵 附有 类比 信息 的 语法 树 ， 再 由 推理 器 进行 论域 转化 和 扩展 推理 ， 生成 新 的 语法 树 ， 最后 整理 成 Java 程序 输出 这个 翻译 系统 的 总体 结构 如图所示 图 　 　 语法分析 与 类比 分析 　 　 在 进行 类比 推导 之前 ， 首先 要 对 NDPolya 源程序 进行 语法分析 和 类比 分析 在 这 一 过程 中 ， 我们 完成 了 下列 工作 ： 　 　 依据 我们 设计 的 语言 ， 利用 成熟 的 编译 技术 ， 在 Lex 和 YACC 等 工具 的 辅助 下 编制 词法 分析 和 语法分析 程序 ， 对 源程序 进行 扫描 和 识别 ， 排除 词法 错误 和 一些 简单 的 语法错误 ， 同时 自 底向上 地 建立 起 一棵 语法 树 　 　 创建 符号表 对 语法 树中 的 各 标识符 予以 解释 — — 即将 其 联系 于 符号表 相应 项 从而 进一步 联系 至 其 在 语法 树中 的 定义 点 ； 进一步 排除 诸如 标识符 无 定义 之类 的 错误 这 一步 的 工作 依据 语法 树 自顶向下 递归 下降 地 进行 　 　 在 对 标识符 进行 解释 的 同时 ， 进行 类比 信息 的 收集 和 分析 ， 包括 源类 与 目标 类 之间 特征 的 相似 对应 关系 、 属性 的 分组 信息 和 组 之间 的 相似 对应 关系 此时 可以 排除 部分 类比 信息 矛盾 错误 值得注意 的 是 ， 类比 信息 也 是 有 作用域 的 ， 因而 它们 的 存放 也 应 依附于 语法 树 的 嵌套 层次结构 　 　 静态 类型 检查 除了 要作 一般 的 静态 类型 检查 外 ， 我们 还要 作 类比 类型 相容性 检查 ， 主要 是 检查 as 子句 的 类型 相容性 如果 当前 类中 声明 类型 为 B 的 属性 t 相似 于源类 中 类型 为 A 的 某 属性 s ， 则 要求 B 与 A （ 类比 ） 相容 ， 即 凡 程序 中 通过 s 引用 的 A 的 属性 或 方法 在 B 中均 有 其 明确 的 对应物 （ 保证 下面 的 类比推理 有 足够 的 类比 对应 信息 ） 这有 如下 几种 情况 ： ① 某些 简单 类型 具有 相同 的 方法 ， 如 实数 类型 的 加法 和 整数 类型 的 加法 ； ② 有 继承 关系 的 两个 类中 的 同一 属性 或 方法 （ 可能 已重 定义 ） ； ③ 使用 where 子句 显式 说明 了 的 对应 的 属性 或 方法 　 　 现在 ， 我们 得到 了 一棵 已 充分 解释 的 语法 树 以及 依附 其上 的 类比 信息 表 ， 接下来 就 可以 进行 类比推理 ， 以 得到 所 需 目标 类 的 实现 　 类 实现 的 类比推理 　 　 为了 得到 所 需 目标 类 的 实现 ， 我们 首先 复制 一份 源类 的 语法 树 ， 然后 依据 类比 信息 进行 推理 ， 将 它 转化 为 目标 类 的 完整 的 语法 树 这个 工作 分为 两步 进行 ： 论域 转换 和 扩张 推理 　 论域 转换 　 　 进行 类比 的 源类 和 目标 类 所 描述 的 问题 可能 属于 不同 的 领域 如果 把 整个 类 比作 一个 代数 系统 ， 那么 源类 与 目标 类 就 具有 不同 的 “ 论域 ” 把 类 的 语法 树 从源类 的 “ 论域 ” （ 称为 基域 ） 变换 到 目标 类 的 “ 论域 ” （ 称为 靶域 ） 的 工作 我们 称之为 “ 论域 转换 ” 　 　 论域 转换 的 主要 工作 是 换名 ， 可 依据 语法 树 递归 下降 地 进行 每 深入 一个 语法 层次 ， 首先 将 联系 于本 语法 节点 的 类比 信息 表 （ 如果 有 的话 ） 与 从 上 一 语法 层次 继承 下来 的 有效 类比 信息 表 合并 ， 形成 当前 有效 类比 信息 表 ； 然后 对本 节点 的 各 语法 成分 递归 地 进行 换名 ， 直至 可 根据 当前 有效 类比 信息 表 直接 决定 如何 处理 的 单个 标识符 　 　 对 语法 树 换名 的 同时 也 就 破坏 了 其 原有 的 类型 体系 必须 保证 新 语法 树 无 类型 错误 若 此时 发现 类型 错误 则 说明 类比 不当 ， 其 原因 可能 是 用户 使用 where 子句 所 指定 的 类比 对应 本身 有 类型 矛盾 ， 应 报告 用户 　 　 这 一步 有 一个 棘手 的 问题 ： 如何 处理 临时 变量 的 类型 ？ 一种 办法 是 在 编写 源类 的 语言 中 引入 Eiffel 语言 中 的 “ like ” 机制 （ 不同于 上文 所述 的 like ） ， 要求 把 临时 变量 的 类型 联系 于 非 临时 变量 （ 这 也 是 一种 良好 的 程序 风格 ） 但 由于 Java 中 并 无 这种 机制 ， 我们 决定 采用 另 一种 方法 ， 就是 依据 某些 表达式 对 该 临时 变量 的 类型 进行 猜测 ， 以 使得 这些 表达式 类型 匹配 如果 猜测 的 结果 使得 本 段程序 无 类型 错误 ， 我们 就 认为 猜测 成功 了 虽然 猜测 不 一定 能 成功 ， 成功 了 也 不能 保证 绝对 正确 ， 但 在 大多数 情况 下 是 能 猜出 正确 的 类型 的 　 　 到 这 一步 为止 ， 我们 的 系统 已 具备 相当 的 类比推理 能力 ， 能 从源 类推 导出 （ 直接 ） 同构 的 目标 类 ， 其 效果 有些 类似 于 一般 语言 中 的 模板 类 属 机制 ， 然而 与 之 相比 ， 类比 机制 有 下列 优点 ： 　 　 类比 机制 不 要求 事先 抽象 模板 机制 要求 在 使用 之前 已经 对 相似 的 类 或 方法 作出 抽象 ， 并 写成 模板 的 格式 而 在 实际 的 编程 实践 中 ， 人们 常常 是 在 解决 新 问题 时才 发现 其 与 已知 问题 类似 ， 可以 复用 已有 代码 ， 然而 此时 人们 又 不 愿意 特地 编写 一个 模板 了 　 　 与 模板 机制 相比 ， 类比 机制 概念 更 深刻 ， 功能 更 强大 例如 ， 类比 机制 不但 可以 换掉 一个 类 的 某 属性 的 类型 ， 而且 还 能 换掉 该 属性 （ 作为 一个 对象 ） 的 属性 和 方法 （ 通过 where 子句 ） ， 这是 模板 机制 所 难以 做到 的 　 　 类比 机制 不仅 能 推导 出 与 源类 直接 同构 的 目标 类 ， 更 重要 的 是 它 能 通过 扩张 推理 推导 出 与 源类 在 商 结构 下 同构 的 目标 类 ， 从而 解决 更 复杂 的 问题 下面 我们 就 来 讨论 扩张 推理 　 扩张 推理 　 　 在 进行 类比 时 ， 当前 面临 的 问题 往往 比 已知 的 问题 要 来得 复杂 前 文 指出 我们 的 类比 是 建立 在 商 结构 同构 的 基础 上 的 ， 这样 新 问题 的 复杂性 就 表现 为 目标 类 的 属性 的 组比 与其 相似 对应 的 组 扩大 了 例如 第节 中 空间 的 点 与 平面 的 点 类比 的 例子 中 ， DP 的 属性 组 〈 xyz 〉 就 比 DP 中 相应 的 属性 组 〈 xy 〉 扩大 了 在 这种 情况 下 ， 要 得到 目标 类 的 实现 就 必须 对 相关 代码 进行 相应 的 变换 当有 多个 组 相互作用 时 ， 问题 变得 比较复杂 下面 我们 较 详细 地 讨论 对 代码 进行 扩张 的 算法 　 　 扩张 在 语法 树上 进行 为了 方便 叙述 ， 先 引入 一些 概念 ： 　 　 对等子 树 　 　 ① 语法 树 同构 ： 叶 节点 与 叶 节点 同构 语法 树 TTT … Tn 与 SSS … ， Sn 同构 当且 仅 当 T 与 S 为 相同 语法结构 且 Ti 与 Si 同构 i … n 　 　 ② 线性 表示 ： 一棵 语法 树 S 可 看作 是 施于 其 所有 叶 节点 上 的 某种 操作 若用 OPs 表示 该 操作 同构 的 语法 树 看作 是 同样 的 操作 ， 则 S 可 表示 为 ： OPsnn … nk ， 其中 nn … nk 为先 根 遍历 S 依次 遇到 的 叶 节点 易知 ， 该 表示 是 唯一 存在 的 　 　 ③ 对 等 ： 同构 子树 OPnn … nk 与 OPmm … mk 对 等 当且 仅 当 ni 与 mii … k 满足 下 例 条件 之一 ： 　 　 相同 　 　 均 为 常量 ， 且 类型 相容 　 　 均 为 局部变量 ， 且 类型 相同 　 　 均 为 同 一组 中之非 新增 变量 　 　 均 为 与 各组 均 无关 的 非 局部变量 显然 ， 子树间 的 对等关系 是 一种 等价关系 它 实际上 体现 的 是 代码 间 一种 基于 组内 变量 相似 关系 的 “ 对称 ” 的 关系 　 　 扩张 的 基 　 　 ① 组 扩张 的 基 ： 若 某 几个 变量 恰好 为 不 重复 ， 不 遗漏 某 一个组 G 的 全部 非 新增 变量 ， 称其为 该组 扩张 的 基 　 　 ② 子树 扩张 的 基 ： 子树 　 　 　 　 　 　 　 　 　 　 　 　 　 OPnn … nk 　 　 　 　 　 　 　 　 　 　 　 　 　 OPnn … nk 　 　 　 　 　 　 　 　 　 　 　 　 　 … … 　 　 　 　 　 　 　 　 　 　 　 　 　 OPsnsns … ， nsk 　 　 若 同时 满足 下列 条件 则 构成 一子 树 扩张 的 基 ： 　 　 其中 任意 两棵 子树 对 等 　 　 若 nit ≤ i ≤ s ≤ t ≤ k 为 某 一组 G 中 之 变量 ， 则 对于 所有 的 jj … s ， 诸 njt 均 相同 或 它们 恰好 构成 组 G 扩张 的 基 　 　 至少 存在 一个 t ≤ t ≤ k 诸 njtj … s 不是 局部变量 ， 并 恰好 构成 某组 G 扩张 的 基 　 　 若 存在 r ≤ r ≤ k 诸 njrj … s 均 为 局部变量 ， 则 它们 要么 全部 相同 ， 要么 两 两 不同 ， 在 后 一种 情况 下 隐含 定义 了 一个组 这些 局部变量 构成 该组 扩张 的 基 ， 而 该组 扩张 的 新 变量 将 也 是 新 的 局部变量 ， 其 个数 等于 非 局部变量 组需 扩张 的 变量 个数 　 　 若 存在 rt ≤ rt ≤ k 诸 njr 为组 G 扩张 的 基诸 njt 为组 G 扩张 的 基 ， 则 G 与 G 中需 扩张 的 变量 个数 应 相同 　 　 若 存在 rt ≤ rt ≤ k 诸 njrj … s 诸 njtj … s 为同 一组 G 扩张 的 基 ， 则 有 njrnjtj … s 　 　 所谓 子树 扩张 的 基 实际上 乃是 代码 中待 扩张 的 合适 的 对称 结构 ， 条件 到 条件 保证 它 对于 一次 扩张 来说 既 是 完整 的 又 是 最小 的 　 　 现在 来 讨论 如何 扩张 由于 我们 大量 的 操作 在 不同 子树 的 对应 叶 节点 间 进行 ， 而 语法 树 的 结构 很 不 适合 这样 的 操作 ， 所以 我们 先要 将子 树 变换 为 其 线性 表示 （ 线性化 ） ， 实现 上用 一个 指针 数组 指向 该子 树 的 所有 叶 节点 我们 的 算法 总体 上 还是 依据 语法 树 递归 地 进行 ， 只是 这里 要 按照 深度 优先 的 顺序 ， 即先 扩张 小 的 语法 单元 ， 后 扩张 大 的 语法 单元 每 到达 一个 可 扩张 的 语法 层次 （ 节点 ） ， 首先 将 各 同构 的 语法 子树 分别 线性化 ， 组成 一个 索引 矩阵 ， 然后 在 这个 矩阵 里 查看 是否 有待 扩张 的 基 每 找到 一个 子树 扩张 基 OPnn … nkOPnn … nk … … OPsnsns … ， nsk 就 一次 扩张 出子 树 OPsnsns … ， nsk … … OPrnrnr … ， nrk 扩张 的 规则 是 ： 　 　 ① 每个 新 扩张 出 的 子树均 对 等于 原来 的 子树 　 　 ② 若 诸 njtj … s 相同 ， 则 诸 njtj … r 相同 ， 否则 　 　 ③ 若 诸 njtj … s 恰好 构成 某组 G 扩张 的 基 ， 则 诸 njtjss … r 恰为 G 中所 需 扩张 的 变量 ， 否则 　 　 ④ 若 诸 njtj … s 均 为 局部变量 ， 则 诸 njtjss … r 亦 为 新 的 局部变量 ， 否则 　 　 ⑤ 若 诸 njtj … s 均 为 与 诸 组均 无关 之 全局变量 ， 则 诸 njtjss … r 亦 为 全局变量 ， 否则 　 　 ⑥ 诸 njtj … s 均 为 常量 ， 则 诸 njtjss … r 亦 为 常量 （ 常量 的 值 可能 需要 提示 用户 决定 ） 并 将 新 扩张 出 的 子树 不 重复 地 插入 索引 矩阵 和 本 语法 节点 继续 以上 步骤 ， 直至 所有 待 扩张 的 基均 已 扩张 完毕 　 整理 输出 　 　 最后 ， 将 推导 出 的 语法 树 还原 为 Java 源程序 输出 我们 设计 了 一组 语法 制导 的 规则 来 控制 相应 语法 成分 的 换行 与 缩进 ， 使得 输出 的 程序 呈现出 一种 锯齿状 的 风格 ， 满足 了 易于 阅读 的 要求 　 结 　 　 语 　 　 本文 简要 讨论 了 类比 模型 语言 NDPolya 中 支持 柔性 继承 的 类比 语言 设施 ， 并 较 详细 地 给出 了 其 实现 技术 我们 已经 用 C 在 SUNSolaris 上 实现 了 NDPolya ， 并 通过 了 一些 实例 ， 其中 包括 从 一个 平面 图形 旋转变换 系统 类比 得到 了 立体 图形 旋转变换 系统 （ 可 参见 附录 ） 　 　 通过 这个 实践 ， 我们 认为 通过 类比 推导 实现 的 柔性 继承 是 一种 灵活 的 代码 复用 机制 ， 同时 它 体现 了 类比 程序设计 这种 新 的 程序设计 的 思想 和 方法 ， 具有 相当 的 应用 前景 　 　 使用 NDPolya 语言 进行 类比 程序设计 ， 除了 可以 直接 复用 一些 原来 难以 复用 的 概念 和 代码 外 ， 还有 一个 潜在 的 好处 ： 若 发现 某些 代码 多次 被 作为 类比 源 的话 ， 就 可以 将 其 总结 为 模板 、 框架 或者 设计模式 ， 这有 可能 形成 一种 自动 生成 模式 的 途径 这一 问题 值得 继续 研究 附录 　 　 在 这个 例子 中 ， 我们 已有 了 一个 可 进行 平面 模型 的 平移 、 旋转 等 变换 的 系统 图 ， 而 现在 要 开发 一个 用于 立体 模型 的 变换 的 系统 图 根据 我们 的 几何 知识 ， 二维 空间 和 三维空间 具有 许多 相似 的 性质 这 就 启发 我们 去 复用 已有 系统 的 思想 和 代码 进一步 ， 从 程序设计 和 计算机 图形学 的 角度 分析 ， 这 两个 系统 应 具有 相似 的 结构 和 相似 的 关键 算法 （ 用 齐次 矩阵 的 乘法 来 进行 复合 变换 ） 然而 ， 尽管 两个 系统 从 结构 到 算法 思想 都 很 相似 ， 传统 的 机械 的 代码 复用 方法 （ 继承 、 类属 等 ） 在 这里 却 无能为力 而 使用 类比 的 思想 ， 利用 柔性 继承 的 手段 ， 我们 可以 灵活 地 复用 已有 的 程序 ， 方便 地 开发 出所 需 的 三维 的 模型 旋转变换 系统 下面 就是 使用 我们 的 语言 开发 的 这个 程序 的 部分 节录 首先 是 原有 的 二维 系统 ， 接下来 是 类比 开发 的 三维 系统 ， 最后 是 推导 出 的 部分 Java 程序 平面 点 及其 平移 旋转 变化 等 classPoint 　 　 floatxy 　 　 voidmovefloatdxfloatdy 　 　 　 xdx 　 　 　 ydy 　 　 floatdistancePointp 　 　 　 returnfloatMathsqrtxpxxpxypyypy 　 　 绕 原点 旋转 ： 　 　 voidrotdoubletheta 　 　 　 theta 　 　 　 doublectMathcostheta 　 　 　 doublestMathsintheta 　 　 　 floatNyfloatyctxst 　 　 　 floatNxfloatxctyst 　 　 　 xNx 　 　 　 yNy 　 　 略去 一些 方法 　 　 … … 用于 平面 模型 变换 的 齐次 矩阵 及其 乘法 等 ： classMatrix 　 　 Pointpopxpy 　 　 旋转 　 　 voidrotdoubletheta 　 　 　 porottheta 　 　 　 pxrottheta 　 　 　 pyrottheta 　 　 用于 平面 复合 变换 的 齐次 矩阵 乘法 　 　 voidmultMatrixDrhs 　 　 　 PointlxnewPointlynewPoint 　 　 　 PointlonewPoint 　 　 　 lxxpxxrhspxxpxyrhspxy 　 　 　 lyxpyxrhspxxpyyrhspxy 　 　 　 loxpoxrhspxxpoyrhspxy 　 　 　 loxrhspox 　 　 　 lxypxxrhspyxpxyrhspyy 　 　 　 lyypyxrhspyxpyyrhspyy 　 　 　 loypoxrhspyxpoyrhspyy 　 　 　 loyrhspoy 　 　 　 pxxlxx 　 　 　 pyxlyx 　 　 　 poxlox 　 　 　 pxylxy 　 　 　 pyylyy 　 　 　 poyloy 　 　 略去 一些 方法 　 　 … … classModel 　 　 使用 Point 和 Matrix 实现 平面 模型 及其 旋转 等 功能 　 　 … … classTwoDextendsApplet 　 　 显示 平面 模型 变换 效果 　 　 … … 从 二维 点 类比 出 三维 点 ： classPointD ～ Point 　 　 floatzlikexy 　 　 … … 　 　 voidmovefloatdxfloatdyfloatdzasmovefloatdxfloatdy 　 　 　 　 voiddistancePointDpasdistancePointp 　 　 三维空间 旋转 有 三个 维度 ， 各以 不同 的 类比 方式 从 二维 空间 旋转 方法 类比 得到 　 　 voidrotydoublethetafromrotdoublethetawherexz ～ PointxPointy 　 　 voidrotxdoublethetafromrotdoublethetawhereyz ～ PointxPointy 　 　 voidrotzdoublethetafromrotdoublethetawherexy ～ PointxPointy 　 　 … … 从 二维 齐次 矩阵 类比 出 三维 矩阵 及其 关键 算法 ： classMatrixD ～ Matix 　 　 PointDpopxpyasPointpopxpywherexyz ～ xy 　 　 voidrotxdoublethetafromrotdoublethetawherePointDrotx ～ Pointrot 　 　 voidrotydoublethetafromrotdoublethetawherePointDroty ～ Pointrot 　 　 voidrotzdoublethetafromrotdoublethetawherePointDrotz ～ Pointrot 　 　 此处 同样 仅 需 一个 类比 声明 就 可 完成 三维 齐次 矩阵 乘法 ： 　 　 voidmultMatrixDrhsfrommultMatrixDrhswherePointDxPointDyPointDz ～ PointxPointy 　 　 … … classModelD ～ Model 　 　 略 　 　 　 classThreeD ～ TwoD 　 　 略 　 　 　 下面 是 类比 推导 出 的 PointD 和 MatrixD 的 部分 结果 ： classPointDextendsjavalangObject 　 　 floatxyz 　 　 　 　 voidmovefloatdxfloatdyfloatdz 　 　 　 　 　 xdx 　 　 　 ydy 　 　 　 zdz 　 　 　 　 floatdistancePointDp 　 　 　 　 　 returnfloatMathsqrtxpxxpxypyypyzpzzpz 　 　 　 　 voidrotydoubletheta 　 　 　 　 　 thetapi 　 　 　 doublectMathcostheta 　 　 　 doublestMathsintheta 　 　 　 floatNyfloatzctxst 　 　 　 floatNxfloatxctzst 　 　 　 xNx 　 　 　 zNy 　 　 　 　 rotx ， rotz 与 roty 类似 、 ， 为 节省 篇幅 ， 此处 略 classMatrixDextendsjavalangObject 　 　 PointDponewPointDpxnewPointDpynewPointD 　 　 voidrotydoubletheta 　 　 　 　 　 porotytheta 　 　 　 pxrotytheta 　 　 　 pyrotytheta 　 　 　 pzrotytheta 　 　 　 　 rotx ， rotz 与 roty 类似 ， 为 节省 篇幅 ， 此处 略 　 　 这 就是 推导 出 的 三维 齐次 矩阵 乘法 ： 　 　 voidmultMatrixDrhs 　 　 　 　 　 PointDlxnewPointDlynewPointDlxnewnewPointD 　 　 　 PointDlonewPointD 　 　 　 lxxpxxrhspxxpxyrhspxypxzrhspxz 　 　 　 lyxpyxrhspxxpyyrhspxypyzrhspxz 　 　 　 loxpoxrhspxxpoyrhspxypozrhspxz 　 　 　 loxrhspox 　 　 　 lxypxxrhspyxpxyrhspyypxzrhspyz 　 　 　 lyypyxrhspyxpyyrhspyypyzrhspyz 　 　 　 lxnewxpzxrhspxxpzyrhspxypzzrhspxz 　 lxzpxxrhspzxpxyrhspzypxzrhspzz 　 lxnewzpzxrhspzxpzyrhspzypzzrhspzz 　 lyzpyxrhspzxpyyrhspzypyzrhspzz 　 lxnewypzxrhspyxpzyrhspyypzzrhspyz 　 　 　 loypoxrhspyxpoyrhspyypozrhspyz 　 　 　 lozpoxrhspzxpoyrhspzypozrhspzz 　 　 　 loyrhspoy 　 　 　 lozrhspoz 　 　 　 pxxlxx 　 　 　 pyxlyx 　 　 　 poxlox 　 　 　 pxylxy 　 　 　 pyylyy 　 　 　 pzxlxnewx 　 　 　 pxzlxz 　 　 　 pzzlxnewz 　 　 　 pyzlyz 　 　 　 pzylxnewy 　 　 　 poyloy 　 　 　 pozloz 　 　 PointDpznewPointD 图 　 平面 模型 的 旋转 图 　 立体 模型 的 旋转 　 　 致谢 　 感谢 NDPolya 课题组 其他同学 的 精诚合作 他们 是 ： 柳 杨 、 王筱瑾 、 路鹏 ■ 基金项目 ： 本 课题 得到 国家自然科学基金 项目编号 、 国家 杰出青年 科学 基金项目 　 　 　 　 　 　 编号 和 江苏省 青年 基金 项目编号 BQ 资助 作者简介 ： 马晓星 ， 男 ， 年月生 ， 硕士 研究生 ， 主要 研究 方向 ： 面向对象 应用 框架 和 设 　 　 　 　 　 　 计 模式 　 　 　 　 　 唐宝 ， 男 ， 年月生 ， 硕士 研究生 ， 主要 研究 方向 ： 并发 面向对象 语言 　 　 　 　 　 陶先平 ， 男 ， 年月生 ， 博士 研究生 ， 讲师 ， 主要 研究 方向 ： 软件 自动化 、 流 　 　 　 　 　 　 动 Agent 技术 　 　 　 　 　 伊波 ， 男 ， 年月生 ， 副教授 ， 主要 研究 方向 ： 类比 理论 、 软件 自动化 　 　 　 　 　 吕建 ， 男 ， 年月生 ， 教授 ， 博士生 导师 ， 南京大学 软件 新 技术 国家 重点 实验 　 　 　 　 　 　 室主任 ， 中国计算机学会 理事 ， 研究 领域 ： 软件 自动化 及 形式化 、 面向对象 语言 及 　 　 　 　 　 环境 作者 单位 ： 马晓星 （ 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 ） 　 　 　 　 　 唐宝 （ 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 ） 　 　 　 　 　 陶先平 （ 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 ） 　 　 　 　 　 伊波 （ 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 ） 　 　 　 　 　 吕建 （ 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 ） 　 　 　 　 　 马晓星 （ 南京大学 计算机软件 研究所 　 南京 　 ） 　 　 　 　 　 唐宝 （ 南京大学 计算机软件 研究所 　 南京 　 ） 　 　 　 　 　 陶先平 （ 南京大学 计算机软件 研究所 　 南京 　 ） 　 　 　 　 　 伊波 （ 南京大学 计算机软件 研究所 　 南京 　 ） 　 　 　 　 　 吕建 （ 南京大学 计算机软件 研究所 　 南京 　 ） 参考文献 ： ［ ］ 伊波 ， 徐家 福 类比推理 综述 计算机科学 ， ， ： ～ YiBoXuJiafuAsurveyonanalogyreasoningComputerScienceinChinese ～ ［ ］ 伊波 ， 徐家 福 类比 模型 和 类比 对应 中国 科学 A 辑 ， ， ～ YiBoXuJiafuAnalogymodeandanalogycorrespondenceScienceinChinaAinChinese ～ ［ ］ YiBoXuJiafaAnalogicaltypetheorySymbolicComputation ～ YiBoXuJiafuAnalogycalculusTheoreticalComputerScience ～ ［ ］ L ü JianguoXuJiafuAnalogicalprogramderivationbasedontypetheoryTheoreticalComputerScience ～ ［ ］ entnerDStructuremappingAtheoreticalframeworkforanalogyCognitiveScience ～ 收稿 日期 ： 修稿 日期 ：
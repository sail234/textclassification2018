计算机 研究 与 发展 JOURNALOFCOMPUTERRESEARCHANDDEVELOPMENT 年 第卷 第期 VolNoADA 程序 通信 死锁 的 动态 检测 方法 史晓华 　 高仲仪 　 邵 　 晖 摘 　 要 　 针对 ADA 并发 多任务 程序 的 特点 ， 文中 提出 一个 新 的 ADA 程序 动态 死锁 检测 方案 ， 并且 在 这个 理论 的 基础 上 实现 了 一个 动态 死锁 测试工具 DDTTdynamicdeadlocktestingtool 此 工具 能够 正确 检测 ADA 多任务 程序 由于 通信 关系 不当 而 造成 的 死锁 文中 详细 介绍 了 动态 死锁 测试工具 DDTT 所 依赖 的 全部 概念 及 判定 规则 ， 以及 它 的 工作 原理 关键词 　 死锁 ， ADA 程序 ， 动态 检测 中图法 分类号 　 TPADYNAMICDEADLOCKTESTINGMETHODOFACONCURRENTADAPROGRAMSHIXiaoHuaGAOZhongYiandSHAOHuiSoftwareEngineeringInstitute ， BeijingUniversityofAeronauticsandAstronauticsBeijingAbstract 　 AccordingtothefeaturesofADAconcurrentprogramsanewtheoryisintroducedwhichcanbeusedtodetectmostdeadlocksinanADAprogramAdeadlockdetectingtoolnamedDDTTdynamicdeadlocktestingtoolrelyingonthistheoryisdesignedThisdetectingtoolcanbeusedtodetectcommunicatingdeadlocksinamultitaskADAprogramThetheoryanddetectingrulesusedbyDDTTaredescribedindetailFinallytheworkingprincipleofDDTTisintroducedKeywords 　 deadlockADAprogramdynamicdetecting 　 引 　 言 　 　 ADA 语言 是 美国国防部 领导 研制 的 三军 通用 语言 它 在 分布式系统 中 得到 了 广泛 的 应用 其 主要 原因 是 由于 ADA 提供 了 强有力 的 不 依赖于 平台 的 多任务 编程 环境 但 分布式 程序 有 几个 特殊 问题 需要 妥善解决 其中 之一 就是 如何 防止 死锁 任务 task 作为 并发 ADA 程序 中 最 基本 的 单元 ， 由于 其中 不 恰当 的 通信 语句 时序 可以 导致 程序 的 死锁 ， 这种 类型 的 死锁 是 可能 通过 分析 及 监控 检查 出来 的 　 　 静态 死锁 检测 是 发展 得 较 早 的 死锁 检测 方法 ， 其中 有 代表性 的 两种 方法 分别 为 有序 集 ［ ］ 和 Petri 网勿庸 质疑 对 程序 做 静态 分析 可以 得到 一个 比较 全面 透彻 的 了解 ， 如果 借助 一个 好 的 分析模型 ， 是 可能 对 一个 被测 程序 的 各个方面 得到 比较 全面 的 理解 和 判定 的 但是 静态 的 分析 工具 有 两个 问题 是 很 难 处理 的 ： 一是 程序 中 的 任务 数组 、 入口 族 等 必须 在 实际 运行 中 决定 的 情况 ； 二是 静态 的 分析方法 为了 追求 全面 ， 最终 导致 NP 问题 、 组合 爆炸 同时 对 用户 来说 ， 静态 分析 得到 的 “ 可能 ” 死锁 的 报告 是 不 能够 满足 的 他们 更 关心 在 实际 运行 时 是否 会 产生 死锁 ， 实际 运行 时 的 “ 死机 ” 是否 为 死锁 等等 非常 具体 的 问题 因此 ， 国外 在 此 领域 已经 有所 研究 较 有 代表性 的 是 JindeCheng 提出 的 ADA 语言 中 死锁 的 完全 分类 方法 并且 给出 了 相应 的 解决 方法 ， 并 提出 了 一个 采用 动态 监控 方式 进行 实时 死锁 检测 的 方案 ［ ］ ， 而 在 国内 尚未 见到 有 这样 的 研究成果 本文 所作 的 主要 工作 是 ： 给出 了 ADA 任务 通信 死锁 的 定义 ； 提出 了 描述 单元 通信 关系 的 UDG 图 的 形式化 表示 方法 ； 提出 并 证明 了 死锁 的 判定 定理 ； 以及 在 上述 理论 工作 的 基础 上 实现 了 一个 动态 检测 ADA 任务 通信 死锁 的 工具 原型 　 　 文中 将 首先 讨论 采用 动态 监控 手段 检测 ADA 程序 中 由于 任务 通信 语句 的 不 恰当 时序 而 导致 死锁 所 依赖 的 主要 理论 ， 然后 简单 介绍 在 此基础 上 我们 业已 实现 的 一个 动态 死锁 检测工具 DDTTdynamicdeadlocktestingtool 　 动态 死锁 检测 的 理论 准备 　 任务 通信 死锁 的 定义 　 　 定义 通信 语句 　 　 我们 称 一个 任务 的 入口 接收 语句 或 针对 某一 任务 的 入口 调用 语句 为 ADA 语言 的 通信 语句 　 　 定义 ADA 语言 的 任务 通信 死锁 　 　 一个 并发 ADA 程序 的 任务 通信 死锁 是 指 程序 中 一个 或 多个 任务 的 通信 语句 处于 一种 并非 死循环 导致 的 无限 等待 状态 ， 从而 导致 这些 任务 无法 执行 下去 如 不 特别 注明 ， 文中 提及 的 “ 死锁 ” 即 为 “ ADA 语言 任务 通信 死锁 ” 　 死锁 的 判定 方法 　 单元 通信 关系 的 UDG 图 表示 方法 　 　 首先 是 一些 重要 的 概念 准备 ［ ］ ： 　 　 定义 可 执行 单元 可 分为 如下 类 ： 　 　 Subprogram 包括 ① procedure ， ② function ； 　 　 Block 包括 ① declareblock ， ② acceptblock ； 　 　 Task 包括 ① taskbody ， ② theobjectofatasktype ； 　 　 Package 包括 ① packagespecification ， ② packagebody 　 　 定义 活动 单元 　 　 我们 称 一个 可 执行 单元 为 活动 的 ， 当且 仅 当 满足 以下 两种 情况 中 的 一种 ： 　 　 对于 一个 拥有 withpackages 的 主 单元 而言 ， 程序 开始 执行 其 直接 或 间接 with 的 package 的 代码 ； 　 　 对于 其他 可 执行 单元 而言 ， 程序 开始 执行 属于 此 单元 的 首行 代码 ； 并且 这个 单元 的 运行 没有 终止 　 　 特别 地 ， 程序 在 不同 时刻 或 不同 位置 调用 同一个 Subprogram 或 声明 同一个 tasktype 的 不同 对象 或 执行 同 一段 taskbody 的 代码 ， 我们 定义 它们 针对 某一 特定 时刻 是 不同 的 活动 单元 针对 递归 程序 而言 ， 此点 尤为重要 　 　 定义 活动 单元 的 确立 阶段 elaboration 　 　 我们 称 一个 活动 单元 处于 确立 阶段 ， 当且 仅 当此 活动 单元 尚未 完成 其 声明 部分 代码 的 运行 　 　 定义 活动 单元 的 执行 阶段 　 　 我们 称 一个 活动 单元 处于 执行 阶段 ， 当且 仅 当此 活动 单元 不 处于 确立 阶段 　 　 定义 活动 单元 的 完成 状态 　 　 我们 称 一个 处于 执行 阶段 的 活动 单元 为 完成 状态 ， 当且 仅 当此 单元 执行 到 其 END 语句 之前 而 尚未 执行 它 的 结束 语句 　 　 定义 终止 单元 　 　 我们 称 一个 活动 单元 在 完成 其 END 语句 的 执行 之后 ， 此 单元 为 终止 的 　 　 定义 外延 单元 　 　 我们 称 一个 活动 单元 Unit 为 另 一个 活动 单元 Unit 的 外延 单元 ， 当且 仅 当 它们 满足 以下 种 关系 中 的 一种 ： 　 　 Unit 是 Unit 通过 with 语句 直接 或 间接 引用 的 包 ， 并且 Unit 为 这个 并发 ADA 程序 的 主 单元 ； 　 　 Unit 是 Unit 调用 的 子程序 ； 　 　 Unit 是 Unit 体中 直接 声明 的 属于 定义 中类 中 的 单元 　 　 定义 直接 激活 　 　 我们 称 一个 活动 的 Task 或 TaskType 的 对象 是 被 一个 属于 定义 类 ， ， 中 的 活动 单元 直接 激活 的 ， 当且 仅 当 这个 任务 满足 以下 两种 关系 中 的 一种 ： 　 　 这个 task 或 tasktype 的 对象 是 在 这个 可 执行 单元 的 声明 部分 直接 说明 的 ； 　 　 这个 task 或 tasktype 的 对象 是 在 被 这个 可 执行 单元 直接 或 间接 引用 的 包中 （ 包括 包 的 体及 包 的 声明 ） 直接 说明 的 ， 并且 这个 可 执行 单元 是 这个 并发 ADA 程序 的 主 单元 　 　 定义 单元 标识码 　 　 在 一个 并发 ADA 程序 中 ， 每 一个 活动 单元 都 拥有 一个 唯一 的 标识码 直至 其 进入 终止 状态 ； 此码 作为 区分 不同 活动 单元 的 唯一 标识 　 　 定义 任务 标识码 　 　 在 一个 并发 ADA 程序 中 ， 每个 活动 单元 （ 包括 定义 中 所有 类 可 执行 单元 ） 都 拥有 一个 任务 标识码 对于 每个 活动 或 终止 的 task 或 tasktype 的 对象 而言 ， 此码 都 是 唯一 的 即 不同 的 task 或 tasktype 的 对象 或 同一 tasktype 的 不同 对象 都 拥有 一个 可以 唯一 区分 自己 的 任务 标识码 　 　 特别 地 ， 我们 定义 一个 不 具有 任务 的 顺序 流 程序 中 的 所有 活动 单元 都 拥有 一个 同样 的 任务 标识码 　 　 定义 我们 定义 两个 活动 单元 Unit ， Unit 拥有 同样 的 任务 标识码 ， 当且 仅 当 这 两个 单元 满足 以下 两种 关系 中 的 一种 ： 　 　 Unit 为 Unit 的 外延 单元 ， 或 反之 ； 　 　 存在 这样 一个 有序 集合 ： ｛ P ， … ， Pm ｝ 　 　 m ＞ ； 　 　 　 　 ① P 为 Unit 的 外延 单元 ； ② Unit 为 Pm 的 外延 单元 ； ③ 对于 任何 存在 的 ＜ i ≤ m ， Pi 为 Pi 的 外延 单元 ； 或 将 上述 的 Unit 与 Unit 变换位置 　 　 定 义父 单元 　 　 我们 称 直接 激活 一个 task 或 tasktype 的 对象 的 活动 单元 为此 任务 的 父 单元 由 定义 可知 ， 一个 任务 单元 的 父 单元 的 任务 标识码 不同于 此 任务 的 任务 标识码 ， 并且 也 不同于 非 它 本身 的 任何 其它 活动 或 终止 的 任务 单元 的 任务 标识码 　 　 定义 活动 单元 的 完成 等待 状态 　 　 我们 称 一个 活动 单元 处于 完成 等待 状态 ， 当且 仅 当 它 同时 满足 以下 两种 情况 ： 　 　 此 活动 单元 处于 完成 状态 ； 　 　 此 活动 单元 直接 激活 的 任务 中 ， 尚有 未 处于 终止 状态 的 单元 　 　 定义 单元 描述 图 unitdescriptiongraph 　 　 我们 定义 这样 一个 有向图 ， 它 针对 于 某 一 特定 时刻 t （ 对于 实时 嵌入式 系统 interleavedimplementation ， t 为 某 一 物理 时刻 ； 对于 分布式系统 distributedimplementation ， t 为 某 一虚 时刻 ） ， 某一 特定 的 被 测 并发 ADA 程序 P ： 用 符号 表示 为 UDGPt ， 对应 一个 元组 的 有向图 ： OAPt ， OFPt ， EPt ， Aact ， Aext ， Acall ， Aacc ， D ， WOAPt ＝ OATPt ∪ OABPt ∪ OASPt ∪ OAPPt 其中 OATPt 表示 所有 在 时刻 t 的 属于 定义 类中 的 活动 单元 ； 　 　 OABPt 表示 所有 在 时刻 t 的 属于 定义 类中 的 活动 单元 ； 　 　 OASPt 表示 所有 在 时刻 t 的 属于 定义 类中 的 活动 单元 ； 　 　 OAPPt 表示 所有 在 时刻 t 的 属于 定义 类中 的 活动 单元 ； 　 　 OFPt ＝ OFTPt ∪ OFBPt ∪ OFSPt ∪ OFPPt 其中 OFTPt 表示 所有 在 时刻 t 之前 终止 的 属于 定义 类中 的 单元 ； 　 　 OFBPt 表示 所有 在 时刻 t 之前 终止 的 属于 定义 类中 的 单元 ； 　 　 OFSPt 表示 所有 在 时刻 t 之前 终止 的 属于 定义 类中 的 单元 ； 　 　 OFPPt 表示 所有 在 时刻 t 之前 终止 的 属于 定义 类中 的 单元 ； 　 　 EPt 为 P 中 所有 在 时刻 t 的 活动 单元 及 时刻 t 之前 终止 的 任务 单元 的 入口 声明 的 集合 ； 　 　 Aact ＝ OAPt × OATPt 　 　 Aact 表示 OAPt 与 OATPt 之间 的 这样 一种 二元关系 ： 　 　 对于 任意 的 V ∈ OAPt ， V ∈ OATPt ， 当且 仅 当 V 是 被 V 直接 激活 的 ， VV ∈ Aact ； 　 　 Aext ＝ OAPt × （ OABPt ∪ OASPt ∪ OAPPt ） 　 　 Aext 表示 OAPt 与 OABPt ∪ OASPt ∪ OAPPt 之间 的 这样 一种 二元关系 ： 　 　 对于 任意 的 V ∈ OAPt ， V ∈ OABPt ∪ OASPt ∪ OAPPt ， 当且 仅 当 V 是 V 的 外延 单元 ， VV ∈ Aext ； 　 　 Acall ＝ （ OATPt ∪ OABPt ∪ OASPt ） × （ OATPt ∪ OFTPt ） × EPt 　 　 Acall 表示 OATPt ∪ OABPt ∪ OASPt 与 OATPt ∪ OFTPt 与 EPt 之间 的 这样 一种 三元 关系 ： 　 　 对于 任意 的 V ∈ OATPt ∪ OABPt ∪ OASPt ， V ∈ OATPt ∪ OFTPt ， e ∈ EPt ， 当且 仅 当 V 无条件 调用 属于 V 声明 的 入口 e ， VVe ∈ Acall ； 　 　 Aacc ＝ （ OATPt ∪ OABPt ） × （ OATPt ∪ OABPt ） × EPt 　 　 Aacc 表示 （ OATPt ∪ OABPt ） 与 （ OATPt ∪ OABPt ） 与 EPt 之间 的 这样 一种 三元 关系 ： 　 　 对于 任意 的 V ∈ （ OATPt ∪ OABPt ） ， e ∈ EPt ， 当且 仅 当 满足 以下 两个 条件 中 的 一种 ： 　 　 V 无条件 接收 等待 一个 入口 e ； 　 　 V 在 一个 选择 段 中 条件 接收 入口 e ， 并且 同时 满足 下列 个 条件 ： 　 　 　 　 ① e 已经 进入 V 的 接收 等待 队列 ； ② e 还 没有 进入 其 会合 阶段 的 执行 ； ③ e 没有 被 一个 时间 限制 或 被 一个 else 语句 所 约束 或 被 一个 orterminate 语句 所 约束 ； ④ 不 存在 aV ， Vk ∈ Aext ； V ， V ， e ∈ Aacc 　 　 D ＝ OAPt × OATPt 　 　 D 表示 OAPt 与 OATPt 之间 的 这样 一种 二元关系 ： 　 　 对于 任意 的 V ∈ OAPt ， V ∈ OATPt ， 当且 仅 当 下列 个 条件 同时 成立 ： 　 　 　 　 ① VV ∈ Aact ； ② V ， V 都 处于 活动 单元 的 确立 阶段 ； ③ 不 存在 这样 一个 V ∈ OATPt ， 使得 VV ∈ D ； VV ∈ D 　 　 W ＝ （ OATPt ∪ OABPt ∪ OASPt ） × OATPt 　 　 W 表示 OATPt ∪ OABPt ∪ OASPt 与 OATPt 之间 的 这样 一种 二元关系 ： 　 　 对于 任意 的 V ∈ OATPt ∪ OABPt ∪ OASPt ， V ∈ OATPt ， 当且 仅 当 下列 两个 条件 同时 成立 ： 　 　 　 　 ① V 处于 完成 等待 状态 ； ② VV ∈ Aact ； VV ∈ W 　 死锁 的 判定 定理 　 　 定理 活动 单元 死锁 的 充分条件 ： 给定 一个 UDGPt 中 ： 　 　 存在 a （ V ， V ， e ） ∈ Acall ； 　 　 如果 V ∈ OFT ， 我们 称 V 由于 呼叫 一个 已经 终止 的 单元 而 导致 死锁 　 　 存在 a （ V ， V ， e ） ∈ Acall ； 　 　 如果 V ∈ OAT 并且 V 处于 完成 状态 ， 我们 称 V 由于 呼叫 一个 已经 完成 的 单元 而 导致 死锁 　 　 存在 a （ V ， V ， e ∈ Acall ； 　 　 如果 V 已经 处于 死锁 状态 ， 我们 称 V 由于 呼叫 一个 已经 死锁 的 单元 而 导致 死锁 　 　 存在 a （ V ， V ∈ Aext ； 　 　 如果 V 已经 处于 死锁 状态 ， 我们 称 V 为 死锁 的 　 　 存在 a （ V ， V ∈ D ； 　 　 如果 V 已经 处于 死锁 状态 ， 我们 称 V 为 死锁 的 　 　 存在 a （ V ， V ∈ W ； 　 　 如果 V 已经 处于 死锁 状态 ， 我们 称 V 为 死锁 的 　 　 存在 一个 有 向 环 ： a ， … ， an ， n ≥ 　 　 其中 　 　 ai ∈ Acall ， 或 　 　 　 　 　 　 ai ∈ Aext ， 或 　 　 　 　 　 　 ai ∈ D ， 或 　 　 　 　 　 　 ai ∈ W 　 （ ≤ i ≤ n ， 　 　 并且 当 我们 把 ai （ Vi ， Vi ， ei ∈ Acall 写成 的 形式 时 ， 这个 有 向 环 可以 表示 为 （ V ， V ， … ， （ Vn ， V ； 　 　 我们 认为 所有 这个 环上 的 节点 Vi ∈ OA （ ≤ i ≤ n 都 是 死锁 的 　 　 证明 根据 ADA 语义 ， ～ 是 成立 的 下面 我们 仅 证明 　 　 首先 根据 定义 、 、 、 可知 ： 中 定义 的 有 向 环中 ， 存在 并且 至少 存在 一个 ai ∈ Acall 　 　 下面 我们 根据 数学 归纳法 来 证明 这一 结论 　 　 由 死锁 的 定义 定义 ， 不防设 a （ Vi ， Vi ， ei ∈ Acall ： 　 　 ① 当 这个 环 中 只有 一个 边 ， 即 n 时 ： a （ V ， V ， ei 　 　 我们 知道 一个 呼叫 了 自身 入口 的 调用 永远 不能 产生 会合 ， 由 定义 可知 V 为 死锁 的 即 对于 所有 的 Vi （ ≤ i ≤ n ， Vi 为 死锁 的 　 　 ② 假设 nk 时 ， 对于 拥有 k 条边 的 有 向 环中 所有 的 Vi （ ≤ i ≤ n ， Vi 为 死锁 的 当 我们 把 它 写成 中 描述 的 简写 形式 时有 （ V ， V ， … ， （ Vk ， V ； 　 　 ③ 当 nk 时 ， 由题 设知 ak ∈ Acall 或 Aext 或 D 或 W 我们 首先 讨论 当 ak （ Vk ， V ， ek ∈ Acall 时 的 情况 ： 　 　 将 a ～ ak 写成 中 描述 的 简写 形式 ： （ V ， V ， … ， （ Vk ， Vk ， （ Vk ， V ； 　 　 由 定义 可知 ， Vk 能否 继续执行 将 取决于 Vk 的 运行 状态 ， 而 Vk 能否 继续执行 — — 即 能否 同 V 产生 一个 会合 将 取决于 V 的 运行 状态 ， 也 就是 Vk 通过 Vk 将 依赖于 V 的 运行 状态 这样 我们 看到 在 VV … VkV 之间 产生 了 一个 相互依赖 的 环 ， 而 根据 中 的 假设 ， 这样 的 环上 每 一个 节点 都 是 死锁 的 由 可知 ， （ Vk ， V ， ek 中 由于 Vk 呼叫 了 一个 已经 死锁 的 节点 V ， 因此 Vk 也 是 死锁 的 即 对于 所有 的 Vi （ ≤ i ≤ k 都 是 死锁 的 　 　 当 ak ∈ Aext 或 D 或 W 时 ， 由 定义 及 上述 证明 同理可知 这个 有 向 环上 的 所有 结点 都 为 死锁 的 　 　 定理 死锁 的 判定 定理 　 　 给定 一个 UDGPt ， 对于 任意 的 Vj 属于 OA ， 当 它 满足 以下 两种 条件 之一 ， 我们 称 这个 程序 中 的 所有 活动 单元 为 死锁 的 ： 　 　 根据 定理 ， 可 判定 Vj 为 死锁 的 ； 　 　 存在 这样 的 有 向 链 ： 　 　 a ， … ， an ， 　 n ≥ ； 　 　 当 n ＞ 时 ， 其中 　 　 　 　 　 　 ai ∈ Acall ， 或 　 　 　 　 　 　 ai ∈ Aext ， 或 　 　 　 　 　 　 ai ∈ D ， 或 　 　 　 　 　 　 ai ∈ W 　 　 （ ≤ i ＜ n ； 　 　 an （ Vn ， Vn ， en ∈ Aacc ； 　 　 a 是从 节点 Vj 引出 的 边 　 　 这个 有 向 链 满足 这样 的 特性 ： 　 　 如果 存在 一个 最靠近 an 的 am （ Vm ， Vm ， em ∈ Acall ， 并且 Vm 的 任务 标识码 与 Vn 的 任务 标识码 相同 ， 那么 不 存在 （ Vn ， Vn ， ek ∈ Aacc ， 使得 ekem 　 　 证明 即证 如果 一个 UDG 图中 所有 活动 单元 满足 上述 两个 条件 之一 ， 这个 程序 中 的 所有 活动 单元 为 死锁 的 　 　 如果 一个 活动 单元 Vj 满足条件 ， 显见 它 是 死锁 的 ； 　 　 如果 这个 活动 单元 满足条件 ， 即 是 说 Vj 能否 继续执行 取决于 Vn 是否 可以 产生 一个 会合 而 由 条件 中 这个 有 向 链 的 特性 可知 ， 根本 不会 存在 这样 的 一个 活动 单元 Vl ， 使得 Vl 呼叫 Vn 正在 等待 的 入口 并且 产生 一个 会合 也就是说 Vj 不 可能 继续执行 下去 ， 它 为 死锁 的 　 动态 死锁 检测工具 的 实现 　 　 动态 死锁 检测工具 DDTT 由 两 部分 组成 ， 其一 是 预 处理器 ， 另 一个 是 监控器 　 预 处理器 　 　 预 处理器 由 静态 分析器 、 源程序 转换器 及 一个 任务 消息 处理 包 组成 如图所示 图 　 　 　 静态 分析器 作为 ADA 程序 理解 的 一个 基础性 的 工具 ， 它 对 文法 上 符合 ADA 文本 的 ADA 源代码 进行 分析 它 不 需要 运行 源程序 ， 而是 将 ADA 源程序 作为 系统 的 输入 数据 ， 自动 地 产生 被测 程序 的 静态 属性 表格 ， 为 动态 测试 以及 其它 测试 奠定 数据 基础 　 　 源程序 转换器 又称 源码 处理器 ， 是 整个 预 处理器 中 技术 上 的 关键 部分 顾名思义 ， 这 一部分 的 功能 是 将 一个 被测 程序 P 转化 为 我们 所 需要 的 程序 P ′ ， 而 转化 过程 中 所 依赖 的 程序 信息 得 自于 静态 分析器 我们 总 的 原则 是 在 程序 中 插装 适当 的 语句 来 获知 定义 ～ 中 的 各种 单元 的 运行 状态 及 它们 之间 的 各种 关系 　 　 任务 消息 处理 包 单独 编译 后 留在 共享 库中 由于 它 独立 于 任何 不同 的 被 测 文件 ， 因此 被 修改 后 的 被 测 文件 将 引用 这 一个 程序包 　 监控器 　 　 监控器 与 被 测 程序 将 采用 进程 通信 的 手段 来 达到 任务 消息 共享 我们 在 系统 中辟 出 一块 专用 文件 缓冲区 用来 进行 被测 程序 与 监控器 之间 的 通信 　 　 被测 程序 的 任务 消息 处理 是 在 一个 独立 的 任务 中 进行 ， 我们 可以 把 这个 任务 看做 是 一个 缓冲器 ， 被测 程序 只 需 在 插装 位置 上 调用函数 向 内存 中 的 消息 队列 写入 有关 信息 即可 ； 同时 这个 任务 从 内存 中 取出 消息 后 放入 文件 缓冲区 监控器 最终 从文件 缓冲区 中 取得 相应 的 消息 ， 根据 前述 定义 及 死锁 的 判定 定理 加以 处理 　 结束语 　 　 文中 提出 了 在 一个 并发 ADA 程序 起始 运行 后 的 任意 时刻 t ， 根据 不同 任务 单元 的 状态 来 判断 此 程序 是否 处于 由于 通信 设计 不当 而 导致 的 死锁 状态 的 解决方案 根据 此 方案 并 在 本 研究所 “ 七五 ” 、 “ 八五 ” 以来 业已 完成 的 ADA 软件测试 工具 的 基础 上 ， 我们 实现 了 一个 具有 较 好 实用性 、 对 此类 死锁 具有 比较 完全 覆盖面 的 ADA 程序 动态 死锁 检测工具 完全 解决 死锁 问题 是 还有 很 漫长 的 路 要 走 的 ， 但是 我们 本着 了解 一部分 、 解决 一部分 的 方针 ， 希望 能够 将 问题 缩小 ， 在 这 一 领域 有所前进 作者简介 ： 史晓华 ， 男 ， 年月生 ， 博士 研究生 ， 主要 研究 领域 为 软件工程 和 软件测试 技术 高仲仪 ， 男 ， 年月生 ， 教授 ， 主要 研究 领域 为 形式语言 与 自动机 理论 、 软件 质量 与 可靠性 、 软件 及 软件工程 环境 、 过程 工程 邵晖 ， 男 ， 年月生 ， 硕士 研究生 ， 主要 研究 领域 为 嵌入式 系统 的 开发 与 测试 、 软件工程 及其 环境 作者 单位 ： 史晓华 　 高仲仪 　 邵 　 晖 　 北京航空航天大学 软件工程 研究所 　 北京 　 参考文献 　 周伯生 ADA 程序 的 死锁 检测 原理 见 周伯生 主编 计算机软件 开发方法 、 工具 和 环境 西安 西北工业大学 出版社 ， ～ ZhouBoshengAdeadlockdetectingtheoryofADAprogramInZhouBoshengedComputerSoftwareDevelopingMethodsToolsandEnvironmentinChineseXianNorthwestIndustryUniversityPress ～ 　 ChengJingdeAsurveyoftaskingdeadlockdetectionmethodsACMAdaLetters ～ 　 ANSIMILSTDAReferenceManualfortheAdaProgrammingLanguageWashingtonAdaJointProgramOffice 收到 日期 ： 修改 日期 ：
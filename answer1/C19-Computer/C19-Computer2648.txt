软件 学报 JOURNALOFSOFTWARE 年 第卷 第期 VolNo 一个 不 受 常量 序 限制 的 ILP 学习 算法 张润琦 　 陈小平 　 刘贵全 摘要 　 文章 分析 了 FOILfirstorderinductive 递归 谓词 学习 算法 理论 上 的 不足 以及 由此 导致 的 应用 范围 的 局限 并 通过 两个 例子 给予 详细 说明 为了 克服 这一 缺陷 文章 引入 了 反映 递归 规则 集 R 与 实例 空间 E 本质 关系 的 实例 图 HRE 和 实例 序 的 概念 奠定 了 算法 的 理论 基础 在 此基础 上 给出 了 基于 实例 图 的 FOILPlus 算法 算法 通过 对 悬例 、 悬弧 的 操作 把握住 实例 序 自然而然 的 防止 了 病态 递归 规则 的 产生 从而 保证 FOILPlus 可以 不 受 常量 序 限制 地 完成 学习 任务 同时 算法 的 时空 复杂度 较之 FOIL 算法 没有 增加 FOILPlus 算法 已经 编程 实现 并用 它 尝试 了 两个 FOIL 学习 失败 的 递归 任务 都 获得 了 成功 关键词 　 归纳 逻辑 程序设计 FOILfirstorderinductive 递归 实例 图 实例 序悬例 悬弧 FOILPlus 中图法 分类号 　 TPAnILPAlgorithmwithouttheRestrictionofConstantOrderingZHANGRunqiDepartmentoftheSpecialClassfortheGiftedYoungUniversityofScienceandTechnologyofChinaHefeiCHENXiaoping 　 LIUGuiquanDepartmentofComputerScienceUniversityofScienceandTechnologyofChinaHefeiAbstract 　 InthispapertheshortcomingsintheoryandlimitationinapplicationsofFOILareanalysedToovercomethesedifficultiesinstancegraphHREandinstanceorderareintroducedtoclarifytherelationshipbetweenthesetRofrecursiverulesandtheinstancespaceEBasedontheseconceptsanewILPalgorithmFOILPlusisputforwardwhichpreventsthegenerationofharmfulrecursiverulesbyutilizinghungexampleandhungarctoholdInstanceGraphThealgorithmcancompletelearningtaskswithouttherestrictionofconstantorderinganddoesnotsubstantiallyraisethecomputationalcomplexitycomparedwithFOILFOILPlushasbeenimplementedandexperimentswithitshowthatitdoescompletetwolearningtaskswhichFOILfailsKeywords 　 ILPFOILrescursiveinstancegraphinstanceorderhungexamplehungarcFOILPlus 　 　 归纳 逻辑 程序设计 InductiveLogicProgramming ， 简称 ILP 是 机器 学习 的 一条 重要途径 不仅 可 取得 重要 的 理论 研究成果 而且 在 不同 领域 获得 一系列 成功 的 应用 ［ ～ ］ 一个 ILP 学习 任务 可 描述 如下 ［ ］ 　 　 　 　 给定 　 　 背景 理论 B 和 靶 谓词 的 示例 集 EE ∪ E 满足 BE 且 B ∧ E □ 　 　 　 　 求 　 　 　 靶 谓词 的 内涵 定义 （ 逻辑程序 ） H 使 H ∧ BE 且 H ∧ B ∧ E □ 　 　 由 上述 描述 可知 ILP 算法 的 一个 必要 的 基本功能 是 实例 的 可 推出 性 （ 即 覆盖 关系 ） 的 检验 在 一般 条件 下当 H 包含 递归 子句 时 这种 检验 过程 可能 不 终止 为了 使 ILP 技术 能 在 KDD 等 应用 中 直接 为 终端用户 服务 需要 提供 某种 一般 机制 以 检验 上述 过程 的 有效性 特别 是 有限 终止 性 为此 必需 使 H 不含 “ 病态 递归 ” ［ ］ 现有 的 各种 方法 都 基于 文字 的 排序 相对而言 FOIL ［ ］ 采用 的 “ 常量 序 ” 方法 最为 先进 、 完善 这使 FOIL 系统 的 实用化 程度 最高 而且 使 它 成为 目前 唯一 能够 学出 Ackermann 函数 的 ILP 系统 ［ ］ 　 　 然而 “ 常量 序 ” 方法 也 有 不利 的 一面 它 排斥 了 一大 类 本来 可解 的 、 常见 的 学习 任务 使 FOIL 的 应用 范围 受到 很大 限制 本文 提出 了 一个 新 的 ILP 算法 FOILPlus 除 规则 搜索 （ 生成 ） 的 启发式 机制 的 不 完备 （ 这是 目前 无法 避免 的 ） 和 覆盖性 检验 过程 实现 的 不 完备 （ 一阶 ILP 学习 系统 都 存在 此 问题 ） 之外 FOILPlus 本身 对 可 学到 的 规则 集 没有 任何 限制 FOIL 的 递归 谓词 学习 算法 　 　 FOIL ［ ］ 在 一个 常量 集合 有限 的 域 内 学习 目标 关系 （ 或称 靶 谓词 ） 的 内涵 定义 常量 可以 是 不同 的 类型 例如 元素 或 元素 的 表 也 可以 是 离散 的 或 连续 的 关系 中 的 变量 只能 属于 某个 类型 关系 本身 外延 定义 为 实例 的 集合 正 的 实例 （ 用 表示 ） 是 那些 关系 为 真的 实例 负 的 实例 （ 用 表示 ） 是 那些 关系 为 假 的 实例 FOIL 通过 对 目标 或 背景 关系 的 外延 定义 （ 即 实例 ） 学习 目标 关系 的 没有 函数 的 Horn 子句 定义 训练 数据 包含 了 一个 目标 关系 和 一组 背景 关系 （ 均 为 外延 定义 ） 学习 目标 是 建立 一个 逻辑程序 （ 或称 规则 集 ） 该 逻辑程序 给出 了 用 目标 关系 和 背景 关系 表达 的 目标 关系 的 内涵 定义 该 定义 允许 递归 和 有限 的 量化 二者 有利于 处理 难于 用 属性 值 表示法 描述 的 结构 对象 　 　 FOIL 将 所有 训练 实例 放在 一起 考虑 每次 选择 一个 子句 该 子句 覆盖 一部分 正例 不 覆盖 任何 反例 反复 此 操作 直到 任何 正例 都 被 至少 一个 子句 所 覆盖 为止 FOIL 是 一个 topdown 系统 即 由 一般 到 特殊 当 它 产生 一个 子句 时 总是 开始 时 子句 体为 恒真 每次 加入 一个 文字 将 之 特殊化 直到 符合要求 为止 　 　 为了 保证 循环 递归 不会 出现 FOIL 在 递归 文字 recursiveliteral ［ ］ 的 选取 上 借助 “ 常量 序 ” 进行 了 限制 其 具体 过程 如下 常量 排序 　 　 对于 每 一种 类型 T 的 常量 如果 用户 没有 指定 其 顺序 的话 FOIL 就 试图 发现 一个 似乎 合理 的 顺序 FOIL 检查 每个 关系 R 中 的 每 对 类型 为 T 的 变元 aiaj （ aiaj 分别 指 R 中 第 i 和 第 j 个 变元 ） 看 是否 对于 所有 定义 R 的 实例 aiaj 之间 都 存在 一致 的 偏序 记作 aiaj （ 因为 不 可能 分辨 ai ＜ aj 还是 ai ＞ aj ） 如果 这种 偏序 存在 则 R 的 每 一个 实例 将 给出 常量 序 cicj （ 其中 cicj 分别 表示 实例 中 第 i 和 第 j 个 位置 的 常量 ） 如果 出现 某个 常量 ck 有 ckck 则 此 偏序 不 存在 递归 文字 排序 　 　 类型 T 的 常量 的 排序 可能 暗示 了 在 一个 部分 子句 patialclause 中 的 类型 T 的 变量 vivj 之间 可能 存在 偏序 如果 该部 分子 句 的 每个 例化 赋 给 vivj 的 值 cicj 总有 cicj 成立 则 vivj 成立 基于 此 如果 对于 所有 头为 Rvvvn 体 文字 Rwwwn 的 子句 总有 Rwwwn ＜ Rvvvn 则 递归 终止 将 被 确保 定义 基于 常量 序 的 文字 序 Rwwwn ＜ Rvvvn 如果 　 　 　 　 　 　 　 　 　 　 　 　 wi ＜ ivi 或 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 wivi 且 wi ＜ ivi 或 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 wivi 且 wivi 且 … winvin 且 win ＜ invin 　 　 　 　 　 　 　 　 　 　 　 　 其中 iiin 是 n 的 某个 全 排列 ＜ k 其中 k ∈ n 表示 “ ＜ ” 如果 常量 真实 的 顺序 已知 的话 否则 表示 或 二者 之一 每当 一个 递归 文字 被 考虑 FOIL 总 试图 构造 一个 文字 序使 之 能够 同时 满足 本 文字 和 当前 规则 集中 所有 其他 文字 如果 这样 的 文字 序 不 存在 该 递归 文字 从 规则 空间 中 排除 FOIL 递归 谓词 学习 算法 的 缺陷 及其 分析 　 　 如前所述 FOIL 递归 谓词 学习 算法 的 核心思想 是 通过 用户 定义 或 机器 搜索 人为 地 给 常量 排序 在 此基础 上 从 规则 空间 排除 那些 不 存在 文字 序 的 递归 文字 以 保证 递归 最终 会 终结 于 初始条件 FOIL 不能 对 常量 排序 则 它 将 把 所有 递归 文字 从 规则 空间 中 排除 FOIL 对 常量 错误 排序 则 它 也 会 把 一部分 必需 的 递归 文字 从 规则 空间 中 排除 新 的 规则 空间 不再 包含 任何 满足要求 的 递归 规则 集 导致 FOIL 学习 失败 所以 正确 的 常量 排序 是 FOIL 学出 正确 的 递归 规则 集 的 必要条件 　 　 实际 的 学习 任务 本身 的 特点 或 其 个别 噪声 数据 的 影响 可能 会 使 FOIL 找 不到 或 找 错 常量 的 顺序 从而 学不出 或 学不全 正确 的 递归 规则 （ 注意 不是 因为 数据 过于 一般化 或 噪声 太多 等 缘故 ） 　 　 例设 abh 和 abh 为 两个 八边形 背景 关系 succ 和 next 分别 为 其点 的 顺序 关系 目标 关系 map 为 两者之间 点 的 映射 关系 （ g 表示 常量 g 是 理论 常量 — — 可以 用于 子句 体 的 常量 mapXY 表示 关系 map 有 两个 变量 第个 类型 为 X 第个 类型 为 Y ） 　 　 常量 类型 Xabcdefgh 　 　 　 　 　 　 　 Yabcdefgh 　 　 背景 关系 succXXabbccddeeffgghha 　 　 　 　 　 　 　 nextYYabbccddeeffgghha 　 　 目标 关系 mapXYaabbccddeeffgghh 所有 关系 的 反例 均 由 CWA ［ ］ 给定 　 　 显然 规则 空间 内有 满足要求 的 规则 集合 　 　 　 　 　 　 　 　 但经 实际 测试 本文 中 所有 对 FOIL 的 测试 都 是 使用 目前 最高 版本 FOILFOIL 无法 学出 因为 背景 关系 succ 和 next 都 分别 赋予 类型 XY 的 常量 以 明显 的 环而 目标 关系 map 更 没有 蕴涵 任何 常量 有序 的 信息 所以 FOIL 认为 常量 无序 虽然 常量 序 ghabcdef 和 ghabcdef 确实 存在 常量 无法 排序 使得 FOIL 将 所有 递归 文字 从侯选 文字 中 排除 导致 学习 失败 事实上 若 用户 定义 这 两个 常量 顺序 中 任意 一个 FOIL 都 能 学出 规则 集 作为 比较 如果 将 fgghfggh 之一 改为 反例 则 FOIL 因为 能 将 类型 X 或 Y 的 常量 正确 排序 从而 学出 规则 集 所以 实际 数据 中 的 有序性 过于 隐蔽 或 噪声 数据 的 存在 （ 可以 认为 fgghfggh 之中 有 一个 是 噪声 数据 ） 可能 导致 FOIL 常量 排序 失误 从而 产生 不 出 正确 的 递归 规则 集 　 　 例 考虑 任何 自然数 的 二进制 表示 中 的 个数 的 递归 谓词 的 学习 　 　 常量 类型 N 　 　 背景 关系 oddN 　 　 　 　 　 　 　 evenN 　 　 　 　 　 　 　 halfNN 　 　 　 　 　 　 　 succNN 　 　 目标 关系 binaryNN 所有 关系 的 反例 均 由 CWA 给定 　 　 规则 空间 内有 满足要求 的 规则 集合 　 　 　 　 　 　 　 　 根据 测试 结果 FOIL 没能学 出个 规则 中 任何 一个 虽然 FOIL 将 常量 排序 为 但 事实 表明 这个 常量 序对 学习 没有 任何 帮助 如果 勉强 说 本例 中 的 常量 存在 顺序 的话 那 也 不是 全序 若 将 常量 按 自然数 顺序 由小到大 排列 为 将 之 看做 堆则 堆 中 每个 数 的 双亲 结点 是 它 在 该 偏序 中 的 前序 元 　 　 通过 上面 两个 例子 我们 很 容易 看出 FOIL 对 常量 排序 以 帮助 递归 文字 的 选取 这一 方法 的 局限性 对于 常量 无序 、 常量 序为 偏序 、 常量 序 隐蔽 或 噪声 等 导致 FOIL 不能 学出 正确 的 常量 序 的 递归 学习 任务 FOIL 都 是 不能 胜任 的 而且 即使 FOIL 能够 找到 正确 的 常量 序 如前所述 在 FOIL 对 递归 文字 的 排序 过程 中 也 有 可能 这种 递归 文字 的 序 有 多个 （ 即 符合 I 的 全 排列 iiin 有 多个 ） 而 FOIL 找到 的 不 能够 反映 主要矛盾 这 也 可能 导致 FOIL 学不出 正确 的 递归 规则 虽然 FOIL 可以 依赖 用户 给出 常量 序 但 这 只 对 少数 较为简单 的 学习 任务 有效 且 这 是 以 增加 用户 负担 为 代价 的 最后 需要 指出 一点 常量 序 与 递归 规则 没有 本质 联系 能够 反映 递归 规则 本质 的 是 下 一节 将要 讨论 的 实例 图 和 实例 序 实例 图 和 实例 序 规则 空间 与 实例 空间 中 的 几个 基本概念 　 　 定义 e 为 子句 c 的 覆盖 例是 指 c 无 递归 体 文字 且 存在 c 的 某个 头为 e 的 例化 c ′ c ′ 的 所有 体 文字 均 为 背景 正例 此时 也 说 c 覆盖 e （ 记作 ce ） 例化 c ′ 是 覆盖 的 c ′ 是 （ c 的 ） 覆盖 例化 　 　 定义 e 为 子句 c 的 抛弃 例是 指 c 的 任意 头为 e 的 例化 c ′ c ′ 中 存在 体 文字 为 背景 反例 此时 也 说 c 抛弃 e （ 记作 ce ） 例化 c ′ 是 抛弃 的 c ′ 是 （ c 的 ） 抛弃 例化 　 　 定义 e 为 子句 c 的 悬挂 例是 指 c 有 递归 体 文字 且 存在 c 的 某个 头为 e 的 例化 c ′ c ′ 的 所有 体 文字 均 为 背景 正例 此时 也 说 c 悬挂 e （ 记作 ce ） 例化 c ′ 是 悬挂 的 c ′ 是 （ c 的 ） 悬挂 例 　 　 化 　 　 定义 e 为 规则 集 R 的 覆盖 例是 指 存在 R 的 某个 非 递归 子句 c 覆盖 e 或 存在 R 的 某个 递归 子句 c 的 头 为 e 的 例化 c ′ c ′ 的 非 递归 体 文字 均 为 背景 正例 递归 体 文字 全 被 R 覆盖 也 说 R 覆盖 e （ 记作 Re ） 　 　 定义 e 为 规则 集 R 的 抛弃 例是 指 R 的 任意子 句 c 均 抛弃 e 也 说 R 抛弃 e （ 记作 Re ） 　 　 定义 e 为 规则 集 R 的 悬例 是 指 R 的 任意 非 递归 子句 c 抛弃 e 且 存在 R 的 某个 递归 子句 c 的 头 为 e 的 例化 c ′ c ′ 的 非 递归 体 文字 均 为 背景 正例 递归 体 文字 不全 被 R 覆盖 也 说 R 悬挂 e （ 记作 Re ） 　 　 定义 子句 c （ 或 规则 集 R ） 在 实例 空间 E 中 的 覆盖 例集 、 悬例 集 、 抛弃 例集 分别 记作 Ecc 或 EcREhc 或 EhREac 或 EaR 在 不 引起 混淆 的 情况 下 简记 为 EcEhEa 实例 图 和 实例 序 　 　 若 无 特殊 说明 以下 所说 的 图均 指 超图 所说 的 弧均 指超 弧 所说 的 （ 有 向 ） 边均 指 两点 间 的 （ 有 向 ） 线段 如果 某个 目标 关系 的 实例 空间 为 Eeeeq 规则 空间 中 任意 一个 规则 集 Rcccp 则 由 E 和 R 可 唯一 确定 一个 有 向 带权 超图 HRE （ 简记 为 H ） E 的 元素 ei 与 H 的 点 di 一一对应 R 在 E 下 的 非 抛弃 例化 的 集合 的 元素 与 H 的 超弧 一一对应 其中 非 递归 子句 cu 的 头 为 ei 的 例化 映射 为 图 所示 的 超弧 （ 图中 true 是 我们 定义 的 一个 特殊 点 ） 递归 子句 cw 的 头 为 ek 的 例化 映射 为 图 所示 的 超弧 （ 图中 djdjt 是 该 子句 的 所有 递归 体 文字 的 例化 对应 的 点 ） 我们 称 HRE 为 规则 集 R 在 实例 空间 E 下 的 实例 图 （ 在 不 引起 混淆 的 情况 下 简称 实例 图 ） 不难看出 HRE 的 每个 极大 无 环子 超图 都 反映 了 实例 间 的 一个 序 我们 称之为 实例 序 （ 此处 的 无环 是 指有 向 边 无环 ） 显然 实例 序是 偏序 图 图 实例 图中 的 概念 　 　 非 递归 规则 集 的 实例 图中 只 存在 如图所示 类型 的 超弧 退化 为 一颗 星 与 孤立 的 点 的 并 集 以后 我们 只 考虑 递归 规则 集 的 实例 图 定义 H 中 的 覆盖 弧 、 悬弧 分别 为 覆盖 例化 和 悬挂 例化 对应 的 超弧 覆盖 点 、 悬点 、 抛弃 点 分别 为 覆盖 例 、 悬例 、 抛弃 例 对应 的 点 显然 若能 从 true 到达 一条 弧 这条 弧 就是 覆盖 弧 否则 就是 悬弧 入度 为 的 点 为 抛弃 点入度 不 为 的 点 若 能 从 true 到达 该点 这个 点 就是 覆盖 点 否则 就是 悬点 　 　 H 中 可能 有权 值 相同 或 不同 的 重弧 或 重 的 有 向 边 称 存在 实例 ei 被 多个 子句 覆盖 或 悬挂 的 规则 集为 二义 规则 集 ei 在 二义 规则 集下 的 归结 过程 不 唯一 相应 地二义 图 是 指图 中 存在 点 di 以 di 为 终点 的 弧 存在 多种 权值 不难看出 H 中 任意 能够 从 true 到达 （ 超弧 意义 下 ） 覆盖 点 di 的 极 小子 图 都 对应 覆盖 例 ei 的 一个 无二义 归结 称 这样 的 子 图为 di （ 在 H 中 ） 的 一个 归结 图 H 的 一个 归结 图是 指 H 的 这样 的 子 图 H 中 任意 一个 覆盖 点 在 该子 图中 至少 存在 一个 归结 图 FOIL 基于 实例 图 的 再 分析 　 　 FOIL 学习 过程 中 的 递归 规则 集 R 对应 的 HRE 中 肯定 不 存在 环 但 可能 是 二义 的 由 实例 序 定义 知 HRE 只有 唯一 的 实例 序 在 常量 有限 的 实例 空间 E 中学 出 的 规则 集 R 在 实际 应用 于 常量 无限 的 实例 空间 E ′ 时 可能 存在 无限 递归 （ 但 不是 循环 递归 ） 这个 缺陷 对 所有 一阶 ILP 系统 都 存在 我们 不予考虑 　 　 现在 通过 实例 图 和 实例 序 分析 FOIL 递归 规则学习 算法 在 理论 上 的 缺陷 以下 均 假定 FOIL 已 通过 用户 定义 或 常量 排序 获得 了 一个 常量 序且 当前 侯选 递归 规则 集 R 的 所有 递归 文字 满足 一个 基于 该 常量 序 的 文字 序 　 　 缺陷 如 前面 两个 例子 所示 常量 有序 与 递归 规则 没有 本质 联系 FOIL 的 文字 序是 基于 这种 可能 不 恰当 的 常量 序 　 　 缺陷 文字 序 确定 的 实例 顺序 是 全序 当前 规则 集 确定 的 实例 序是 偏序 每个 可能 的 文字 序是 满足 该 偏序 的 一个 全序 随着 递归 规则 的 增加 偏序 越来越 紧致 可能 文字 序 也 越来越少 满足 节 的 递归 文字 也 越来越少 （ 也 即 侯选 递归 文字 空间 越来越 小 ） 如果 前面 采纳 了 不 恰当 的 递归 规则 造成 偏序 的 不 恰当 使 必需 的 递归 文字 过早 的 从 侯选 递归 文字 空间 排除 则 势必 导致 学习 失败 而 出现 这种 情况 的 可能性 是 颇 大 的 小结 　 　 通过 以上 分析 我们 得出 如下 结论 任何 递归 学习 任务 的 实例 空间 E 对于 规则 集 R 都 存在 实例 序 它 （ 们 ） 由 前面 定义 的 实例 超图 HRE 的 每个 极大 无 环子 图 反映 出来 FOIL 的 递归 学习 算法 的 缺陷 就 在于 企图 用 常量 序 和 文字 序来 反映 这种 实例 序 但 事实上 常量 序 和 文字 序 与 实例 序 并 无 本质 关系 我们 下面 给出 的 改进 算法 就是 通过 把握住 这种 更为 本质 的 实例 序 自然而然 的 防止 了 病态 递归 规则 集 的 产生 FOILPlus 算法 　 　 以下 约定 正确 规则 集为 不 覆盖 任何 反例 且 覆盖 所有 正例 的 规则 集 正确 规则 集 对应 的 H 可以 分割 为 两个 子图 Hp 和 HnHp 的 所有 点均 为 正 例点 正例 点 都 是 覆盖 点 Hn 的 所有 点均 为 反例 点 反例 点 都 是非 覆盖 点 H 可能 有环 但 H 至少 有 一个 归结 图 基于 实例 图 的 FOILPlus 算法 框架 　 　 算法 中 的 R 是 当前 规则 集 PN 是 目标 的 正 、 反例 集 B 为 背景 正 、 反例 集 允许 P ∪ N ≠ E 　 　 FOILPlusBEPN 　 　 　 　 Rbettertrue 　 　 　 　 whilebetterdo 　 　 　 　 　 发现 一个 子句 c 使 HR ∪ cE 比 HRE 更 令人满意 　 　 　 　 　 if 这样 的 c 找 不到 　 　 　 　 　 then 　 　 　 　 　 　 　 betterfalse 　 　 　 　 　 else 　 　 　 　 　 　 　 RR ∪ c 　 　 　 　 输出 R 　 　 HRE 的 满意度 为 综合 考虑 H 中 各项 参数 （ 如 覆盖 、 悬挂 正例 点数 覆盖 、 悬挂 反例 点数 等 ） 和 R 的 复杂程度 后 对 H 的 一个 评价 规则 集 R 越 简单 、 紧凑 覆盖 正 例数 越 多 覆盖 反例 数越 少 HRE 的 满意度 就 越 高 满意度 随 我们 对 所 需 规则 集 R 的 要求 的 改变 而 改变 也就是说 我们 对 规则 集 R 的 要求 反映 为 对 HRE 的 满意度 的 定义 例如 我们 需要 一个 正确 规则 集则 所有 覆盖 反例 点 的 实例 图 的 满意度 为 ∞ FOILPlus 算法 　 　 如节 中 的 FOILPlus 理论 算法 所示 FOILPlus 应用 算法 的 核心思想 是 在 规则 集 R 生成 的 同时 维护 HRE 并 通过 HRE 指导 下 一个 子句 的 生成 　 　 算法 没有 避免 HRE 的 环 的 出现 理由 是 若 算法 禁止 HRE 中 出现 环则 与 节中 的 FOIL 的 缺陷 所述 类似 前面 不 恰当 的 递归 规则 的 生成 可能 阻碍 后面 正确 递归 规则 的 生成 且 若 规则 空间 中 不 存在 递归 规则 集 R 使 HRE 无环则 所有 HRE 有环 的 正确 规则 集 R 都 将 不 可能 生成 这 是 不 应该 的 （ 例子 见 第节 ） 而且 可以 在 最后 对 正确 规则 集 消除 冗余 的 同时 进行 HRE 的 去 环 （ 虽然 没太大 必要 ） 因为 这 两个 操作 都 是 NPhard 的 所以 在 实际 系统 中 可以 作为 选项 提供 　 　 算法 确保 了 “ 算法 认为 某个 实例 被 规则 集 R 覆盖 则 该 点 在 HRE 中必 存在 归结 图 ” 我们 认为 这 是 有 重要 意义 的 这 确保 了 算法 产生 的 规则 集 R 不是 FOIL 担心 的 那种 看似 覆盖 了 所有 正例 、 其实 其中 一部分 正例 是 被 悬挂 的 病态 规则 集 　 　 为了 弥补 算法 生成 的 规则 中 可能 隐含 循环 递归 导致 归结 不 终止 的 缺陷 我们 在 FOILPlus 算法 之外 又 给出 了 与 之 配套 的 归结 算法 Resolve 该 算法 的 归结 速度 在 最坏 情况 下 较之 FOIL 依赖 的 归结 ［ ］ 也 仅 有 对 数级 的 提高 我们 认为 是 可以 接受 的 　 　 算法 中 REPNB 定义 如前 EcEhEa 分别 为 R 的 覆盖 点集 、 悬点集 、 抛弃 点集 算法 在 FOIL 算法 的 基础 上 每个 实例 增加 了 记录 ExampleExample 的 各个 域 定义 如下 　 　 　 id 　 　 　 　 实例 e 的 编号 （ 起 唯一 标识 作用 ） 　 　 　 Aset 　 　 　 集合 其 每个 元素 是 以 e 为 终点 的 悬弧 的 所有 始点 的 编号 的 集合 　 　 　 S 　 　 　 　 以 e 为 始点 的 有 向 边 的 终点 的 编号 的 集合 域 Aset 和 S 起 一个 相互 索引 的 作用 使 递归函数 unhang 高速 运作 FOILPlusBEPNREcEhEaEbettertruefore ∈ E 　 　 　 eAset 　 　 　 eSwhilee ∈ P 但 eEcandbetterdo 　 　 　 cFindClauseEcEhEaPNB 　 　 　 ifc 　 　 　 then 　 　 　 　 　 betterfalse 　 　 　 else 　 　 　 　 　 RR ∪ c 　 　 　 　 　 adjustEcEhEacEcEhEaPNB 输出 RadjustEcEhEacEcEhEaPNBifc 为 非 递归 子句 then 　 　 　 forc 的 每个 覆盖 例 e 　 　 　 　 　 ifeEc 　 　 　 　 　 then 　 　 　 　 　 　 　 将 e 由 Eh 或 Ea 移到 Ec 　 　 　 　 　 　 　 unhangeelse 　 　 　 forc 的 每个 悬挂 例化 c ′ 记 c ′ 头为 e 体为 eej 　 　 　 　 　 ifeEc 　 　 　 　 　 then 　 　 　 　 　 　 　 ifeejEc 　 　 　 　 　 　 　 then 　 　 　 　 　 　 　 　 　 将 e 由 Eh 或 Ea 移到 Ec 　 　 　 　 　 　 　 　 　 unhange 　 　 　 　 　 　 　 else 　 　 　 　 　 　 　 　 　 ifeEhthen 将 e 由 Ea 移到 Eh 　 　 　 　 　 　 　 　 　 Aekid ｜ ekEc 　 　 　 　 　 　 　 　 　 eAseteAset ∪ A 　 　 　 　 　 　 　 　 　 for 每个 eiid ∈ A 　 　 eiSeiS ∪ eidunhangefore ′ id ∈ eS 　 　 　 ife ′ ∈ Eh 　 　 　 then 　 　 　 　 　 forA ∈ e ′ Aset 　 　 　 　 　 　 　 ifeid ∈ A 　 　 　 　 　 　 　 then 　 　 　 　 　 　 　 　 　 AAeid 　 　 　 　 　 　 　 　 　 ifA 　 　 　 　 　 　 　 　 　 then 　 　 将 e ′ 由 Eh 移到 Ec 　 　 unhange ′ 　 　 跳出 此 for 循环 　 　 算法 中 的 FindClause 函数 继承 了 FOIL 中 FindClause 函数 ［ ］ 的 所有 启发式 搜索 功能 但 在 评价 和 加入 一个 文字 时 依赖 了 悬例 的 作用 FOIL 算法 中将 文字 划分 为 determinate 和 gainful 两类 本 算法 在 决定 是否 determinate 文字 时 将 悬例 视作 覆盖 例若 一个 部分 子句 有 n 个 正 例化 和 n 个 负 例化 加入 某 gainful 文字 后 有 m 个 正 例化 和 m 个 负例 化记 m 个 正 例化 实际 覆盖 了 k 个 正例 则 FOIL 对 该 文字 的 评价 为 k × ［ InnImm ］ 　 　 　 　 　 　 　 　 　 　 　 　 　 其中 Innlog ［ n ／ nn ］ bits 针对 悬例 我们 引入 了 n 和 m 分别 表示 该部 分子 句 加入 文字 前后 悬例化 的 个数 记 m 个 悬 例化 覆盖 的 悬例 个数 为 h 则 该 文字 的 评价 为 kh × ［ InnnImmm ］ 　 　 　 　 　 　 　 　 　 其中 Innnlog ［ nn ／ nnn ］ bits 显然 当 该部 分子 句 和 该 文字 中均 无 递归 文字 时 nmh 式 转化 为式 归结 算法 Resolve 　 　 本 算法 只 用于 常量 离散 的 情形 当 常量 连续 时 FOILPlus 和 FOIL 一样 不会 生成 递归 规则 所以 此时 的 归结 与 一般 的 归结 相同 算法 中 使用 了 平衡 树 AVL ［ ］ 存 当前 的 归结 路径 平衡 树 的 查找 和 维护 要求 任意 两个 实例 间 能够 比较 大小 一般 的 算法 均 事先 指定 常量 序为 表示 常量 的 字符串 的 顺序 再 用式 （ 令 其中 ikkk ∈ j ） 即可 判断 任意 实例 间 的 大小 　 　 ResolveeR 　 　 　 　 AVL 　 　 　 　 returnCovereR 　 　 CovereR 　 　 　 　 ife ∈ AVLthenreturnfalse 　 　 　 　 AVLAVL ∪ e 　 　 　 　 forc ∈ R 　 　 　 　 　 　 ifc 为 非 递归 子句 　 　 　 　 　 　 then 　 　 　 　 　 　 　 　 if 存在 c 的 覆盖 例化 覆盖 e 　 　 　 　 　 　 　 　 then 　 　 　 　 　 　 　 　 　 　 AVLAVLe 　 　 　 　 　 　 　 　 　 　 returntrue 　 　 　 　 　 　 else 　 　 　 　 　 　 　 　 forc 的 每个 头为 e 的 悬挂 例化 c ′ 记 c ′ 的 体为 eej 　 　 　 　 　 　 　 　 　 　 ifCovereRandandCoverejR 　 　 　 　 　 　 　 　 　 　 then 　 　 　 　 　 　 　 　 　 　 　 　 AVLAVLe 　 　 　 　 　 　 　 　 　 　 　 　 returntrue 　 　 　 　 AVLAVLe 　 　 　 　 returnfalse 算法 时空 复杂度 分析 　 　 记 n 为 实例 数在 数据结构 上 FOILPlus 算法 比 FOIL 主要 增加 了 实例 记录 Example 因为 所有 实例 的 Example 存 的 都 是 当前 HRE 中 所有 悬弧 的 信息 且 每条 悬弧 恰好 被 存储 一次 所以 算法 在 整个 执行 过程 中比 FOIL 多 使用 的 存储空间 至多 为 SnOmaxMR × NR ｜ R ∈ 算法 执行 过程 中 的 每个 当前 规则 集 其中 MRHRE 的 悬 弧数 NRHRE 悬弧 的 平均 始 点数 R 中 递归 规则 的 平均 体 递归 文字 数 因为 在 实际 应用 中 即使 象 前面 提到 的 Ackermann 函数 这种 困难 任务 每个 递归 规则 的 体 递归 文字 数 也 不 超过 所以 可以 认为 ONROMROHRE 的 悬 弧数 OHRE 的 悬 点数 × O 以 每个 悬点 为 终点 的 平均 悬 弧数 ≤ O 实例 点数 OOn 所以 Sn ≤ On 显然 FOIL 的 空间 复杂度 至少 为 On 所以 FOILPlus 与 FOIL 的 空间 复杂度 是 相等 的 　 　 FOILPlus 算法 较之 FOIL 算法 主要 增加 了 unhang 操作 注意 递归函数 unhang 在 整个 算法 执行 过程 中 对 每个 覆盖 例 调用 且 仅 调用 一次 与 FOIL 时间 花费 的 瓶颈 FindClause 比较 完全 可以 忽略 不记 在 FindClause 中 FOILPlus 比 FOIL 要 多 评价 那些 FOIL 通过 文字 序 排除 的 递归 文字 且 要 多 计算 n ⊙ 和 m ⊙ 但 粗略 分析 可知 这 至多 使 FOILPlus 比 FOIL 时间 花费 有 常数 因子 （ 绝大多数 情况 下 ＜ ） 的 增加 所以 算法 的 时空 复杂度 都 是 令人满意 的 　 　 对于 归结 算法 Resolve 记 算法 在 整个 归结 过程 中共 归结 了 m 个 实例 不难看出 该 归结 过程 对应 以 e 为根 的 非 超图 意义 下 的 有 向 树 TT 上 任意 有 向 边 eiej 称 ei 为 ej 的 孩子 记 T 上 结点 ei 深度 di 则 算法 对 该 点 的 AVL 的 查找 和 维护 的 时间 花费 为 Odi 所以 算法 时间 复杂度 为 Tm Σ ［ OOdi ］ OmO Σ diOmOm × dOm × logmOlogm × T ′ m 其中 dOlogm 为 T 的 平均 深度 TmOm 为 普通 归结 ［ ］ 的 时间 复杂度 算法 的 空间 复杂度 SmOmaxdi ≤ Om 所以 归结 算法 resolve 的 时空 复杂度 都 是 可以 接受 的 当 常量 有限 或 归结 实例 范围 已知 时 可以 用 一个 k 维 数组 记录 归结 路径 此时 有 TmT ′ m 小结 　 　 对于 一个 非 递归 学习 任务 FOILPlus 算法 的 运作 和 FOIL 完全相同 对于 一个 递归 学习 任务 算法 由于 在 文字 级别 引入 了 “ 悬例 ” 而 使得 gain 值 的 计算 更趋 合理 在 子句 级别 引入 了 “ 悬例 ” 而 避免 了 病态 递归 规则 集 的 产生 事实上 在 一个 递归 学习 任务 中正 例 加入 Ec 的 顺序 与 我们 前面 定义 的 “ 实例 序 ” 是 一致 的 ！ 所以 算法 在 没有 对 规则 空间 加以 任何 限制 的 情况 下 通过 引入 “ 悬例 ” 、 “ 悬弧 ” 把握住 “ 实例 序 ” 自然而然 的 避免 了 循环 递归 等 病态 递归 规则 的 产生 实验 结果 　 　 我们 用 标准 C语言 实现 了 上述 算法 的 全部 基本功能 并 将 之 用于 学习 任务 map 和 binary 实验 结果 如下 　 　 当 规则 空间 中不含 FOIL 的 内嵌 文字 “ ≠ ” 时 map 的 学习 结果 为 规则 集 　 　 　 　 　 　 　 　 　 　 该 规则 集 对应 的 Hp 如图所示 图 　 　 虽然 图中 有 环 但 显然 对 任意 点 存在 以 true 为 始点 该点 为 终点 的 无 环链 该链 即 为 该点 对应 实例 的 归结 图 我们 认为 这样 的 规则 集是 可以 接受 的 当 我们 将 “ ≠ ” 加入 规则 空间 后 学习 结果 代之以 规则 集 　 　 binary 的 学习 结果 为 规则 集 　 　 　 　 　 　 式 与 规则 集 的 第 、 两个 子句 相同 第 个子 句 略有不同 但 都 是 本质 的 结论 和 进一步 的 工作 　 　 实例 图 的 引入 在 原本 分割 的 规则 空间 和 实例 空间 之间 搭 起 一座 桥梁 我们 在 实例 图 理论指导 下 设计 的 FOILPlus 算法 在 时空 复杂度 没有 增加 的 前提 下除 规则 搜索 （ 生成 ） 的 启发式 机制 的 不 完备 （ 这是 目前 无法 避免 的 ） 和 覆盖性 检验 过程 实现 的 不 完备 （ 一阶 ILP 学习 系统 都 存在 此 问题 ） 之外 FOILPlus 本身 对 可 学到 的 规则 集 没有 任何 限制 这是 FOIL 等 ILP 学习 系统 都 无法 做到 的 不难看出 实例 图 以及 FOILPlus 算法 都 能 推广 到 多 谓词 学习 中 ！ 我们 相信 这 将 显示 出 实例 图 更 重要 的 作用 — — 这 也 是 我们 下 一步 要 进行 的 工作 注 ： 本文 研究 得到 国家自然科学基金 资助 本文 通讯联系 人 张润琦 合肥 中国科技大学 少年班 系 作者简介 ： 张润琦年生 本科 主要 研究 领域 为 机器 学习 ILP 多 谓词 学习 陈小平 年生 博士 副教授 主要 研究 领域 为 机器 学习 MASAI 逻辑 刘贵 全年 生 博士生 主要 研究 领域 为 机器 学习 多 Agent 系统 AI 基础 作者 单位 ： 张润琦 　 中国科技大学 少年班 系 合肥 陈小平 　 刘贵全 　 中国科技大学 计算机系 合肥 Emailzhangrqmailscgyustceducn 参考文献 KingRDMuggletonSLewisRAetalDrugdesignbymachinelearningtheuseofinductivelogicprogrammingtomodelthestructureactivityrelationshipsoftrimethoprimanaloguesbindingtodihydrofolatereductaseInProceedingsoftheNationalAcademyofSciencesofUSA ～ BratkoIDzeroskiSEngineeringapplicationsofILPNewGenerationComputing ～ ～ SrinivasanAMuggletonSHetalTheoriesformutagenicityastudyinfirstorderandfeaturebasedinductionArtificialIntelligence ～ MuggletonSInductivelogicprogrammingderivationssuccessesandshortcommingsSIGARTBulletin ～ QuinlanJRCameronJonesRMInductionoflogicprogramsfoilandrelatedsystemsNewGenerationComputing ～ ～ CameronJonesRMQuinlanJREfficienttopdowninductiveoflogicprogramsInductiveLogicProgrammingSIGARTBulletin ～ LloydJWFoundationsofLogicProgrammingBerlinSpringerVerlagQuinlanJRKnowledgeacquisitionfromstructureddataIEEEExpert ～ KnuthDETheArtofComputerProgrammingVolumeSortingandSearchingAmsterdamAddisonWesleyPublishingCompanyInc 本文 收到 原稿 收到 修改稿
微型机 与 应用 MICROCOMPUTERITSAPPLICATIONS 　 Vol 　 No 　 P Ｊ ａ ｖ ａ ２ 的 安全 体系 及其 应用 金胜昔 　 步 俊杰 　 吉逸 摘要 ： 分析 了 Ｊ ａ ｖ ａ 安全 体系 的 演化过程 ， 介绍 了 Ｊ ａ ｖ ａ ２ 的 安全 体系 的 框架 及其 新 特性 ， 指出 了 Ｊ ａ ｖ ａ ２ 安全 体系 的 概念 及其 运行机制 ， 并 详细 地 讨论 了 关于 Ｊ ａ ｖ ａ ２ 安全性 的 一些 应用 。 关键词 ： Ｊ ａ ｖ ａ ２ 安全 体系 保护 域 　 　 自从 Java 技术 开始 应用 以来 ， 人们 对 Java 平台 的 安全性 以及 由于 部署 Java 技术 所 引发 的 安全 问题 给予 了 极大 的 关注 。 特别 是 在 年 月 Java 发布 后 ， Java 的 安全 体系结构 发生 了 根本 的 改进 ， 对于 终端用户 而言 ， 它 可以 保护 文件 和 私人 数据 不 被 恶意 的 程序 或 病毒感染 和 破坏 ， 鉴别 代码 提供者 的 身份 。 对于 开发者 而言 ， 通过 使用 API 方法 ， 能够 将 安全性 功能 集成 到 应用程序 中 ， 因为 API 的 体系结构 能够 定义 和 集成 对 特定 的 资源 的 使用 权限 、 加密 、 安全性 管理 、 策略管理 ， 并 提供 了 一些 类来 管理 公钥 ／ 密钥 对及 信任 用户群 的 公钥 证书 。 同时 系统管理员 、 开发者 和 用户 可以 使用 它 提供 的 工具 管理 钥匙 库 ， 在 JAR 文件 中 生成 数字签名 、 签名 的 完整性 检测 、 创建 和 修改 策略 文件 。 按照 Java 设计者 的 观点 ， Java 安全 包括 个 方面 的 内容 ， 首先 将 Java 作为 一种 安全 的 平台 提供 给 用户 ， 在 此 平台 上 ， 可 安全 地 运行 Java 程序 ； 其次 提供 用 Java 编程语言 实现 的 安全 工具 和 服务 ， 它 使得 诸如 企业界 这样 一些 对 安全 非常 敏感 的 领域 也 可 应用 Java 技术 。 本文 将 就 这 二个 方面 介绍 Java 的 安全性 新 特性 及其 应用 。 　 Java 安全 体系结构 的 演化 　 　 Java 从 发布 以来 就 通过 一系列 机制 来 实现 其 安全性 。 首先 ， Java 语言 被 设计 为 类型 安全 的 且 便于 使用 的 ， 它 通过 自动 内存 管理 、 内存 垃圾 回收 及 字符串 和 数组 的 越界 检查 等 语言 特性 来 减轻 程序员 的 编程 负担 和 出现 错误 的 可能性 。 其次 通过 编译器 和 字节 码 校验 器 保证 Java 字节 码 的 合法性 ， 以及 类 装载 器 保证 命名 空间 的 独立性 。 最后 ， 对 重要 系统资源 的 访问 通过 Java 虚拟机 来 传递 ， 并 由 SecurityManager 类 进行 预先 检查 ， 这种 最初 的 安全 模型 称为 沙箱 模型 。 沙箱 模式 提供 了 受限 的 环境 ， 运行 从 网络 下载 的 不可 信任 的 代码 ， 本地 代码 是 可以 信任 的 ， 对 系统资源 有 完全 的 访问 权限 ， 从 网络 下载 的 代码 是 不可 信任 的 ， 只有 访问 沙箱 中 提供 的 有限 资源 。 ． 的 安全性 过于 限制 ， 例如 程序员 希望 在 执行 过程 中能 在 客户机 上 存储 一些 持久 的 信息 数据 ， 那么 ． 的 安全 体系 会令 其 失望 。 　 　 从 JDK ． 开始 提出 了 签名 的 Applet 的 概念 。 如图所示 ， JDK ． 的 安全性 是 基于 可以 信任 的 数字签名 ， 一个 数字签名 的 JAR 文件 中 包括 身份 认证 证书 和 确认 ， 证书 说明 是 谁 对 程序 进行 签名 ， 确认 说明 在 程序 进行 签名 后 没有 被 他人 改动 。 用于 检验 签名 的 公钥 是 可 信任 的 ， 一个 有着 正确 数字 签字 的 Applet ， 如果 它 的 签字 被 接收 该 Applet 的 最终 系统 确认 为 是 可信 的 ， 则 这个 Applet 被 认为 是 可信 代码 ， 具有 本地 代码 完全 访问 的 资源 能力 ， 未 签名 的 Applet 仍然 运行 在 沙箱 中 。 签名 的 Applet 将 分别 和 它们 各自 的 签名 一起 存放 在 个 签名 的 JAR 文件 中 ， 并 在 网络 中 传输 。 在 JDK ． 中 已经 包含 了 数字签名 算法 ， 信息 摘要 算法 、 密钥 生成 算法 的 实现 。 图 JDK ． 安全 模式 　 　 JDK ． 对 ． 作 了 一些 改进 ， 它 的 安全 模式 可以 允许 网络管理员 对于 签名 的 代码 选择性 地 释放 原始 沙箱 的 某些 限制 ， 网络管理员 可以 提供 创建 自定义 的 沙箱 来 实现 更加 灵活 的 安全策略 。 被 置于 自定义 沙箱 中 的 类 在 装载 时 仍然 基于 数字签名 。 在 新 的 安全 模式 中 无论是 本地 的 或 远程 的 代码 ， 都 能够 被 赋予 安全性 策略 ， 在 安全性 策略 中 定义 了 组 权限 ， 用户 和 系统管理员 能够 配置 和 管理 这组 权限 。 对于 签名 的 代码 ， 每个 权限 定义 了 可以 访问 的 资源 ， 如 ： 读写 特定 的 文件 或 目录 、 连接 访问 器 和 端口 等 。 运行 时 系统 将 代码 按照 域 进行 管理 ， 每个 域 都 包含 有 组类 ， 它们 的 实例 被 赋予 了 相同 的 组 权限 。 个域 可以 像 原始 的 沙箱 模式 一样 进行 管理 ， 所以 Applet 仍然 能够 运行 在 用户 和 管理员 希望 的 受限 环境 中 ， 缺省 情况 下 ， Application 仍然 像 原来 一样 可以 不 受限 的 运行 ， 同时 也 可以 通过 对 其 赋予 一定 的 安全性 策略 后 进行 优化 。 总之 ， 安全性 在 一 开始 就 被 考虑 到 在 Java 虚拟机 和 核心 库 的 体系结构 中 ， 最初 的 安全 体系结构 是 不 灵活 的 而且 难以 定义 ， Java 的 安全性 框架 的 目标 是 达到 更强 的 灵活性 和 易于 定制 。 　 Java 的 安全性 新 特性 　 　 Java 采用 了 如图所示 的 新 的 安全 体系结构 ， 并 基于 这种 安全 体系结构 提供 了 很多 新 特性 。 图 JDK ． 安全 模式 ． 　 密纹 访问控制 　 　 这种 能力 从 一 开始 就 在 JDK 中 存在 。 但 要 使用 它 ， 应用程序 的 编写者 不得不 做 大量 的 编程 工作 例如 ， 创建 SecurityManager 和 Classloader 类 的 子类 并 使 其 用户 化 。 HotJava ． 就是 一个 这样 的 应用程序 ， 它 允许 浏览器 用户 在 几个 不同 的 安全等级 上 进行 选择 。 然而 ， 这种 编程 涉及 非常 敏感 的 安全 问题 ， 它 要求 程序员 对 计算机 安全 有 精深 的 理解 和 纯熟 的 技巧 。 新 的 安全 体系结构 将 使 这些 变得 简单 而 安全 。 ． 　 易于 配置 的 安全策略 　 　 与 上述情况 相似 ， 这种 能力 在 原来 的 JDK 中 也 是 存在 的 ， 但是 不 便于 使用 ， 而且 编写 安全 代码 也 不是 简单明了 的 事情 。 于是 ， 人们 期望 能够 允许 应用程序 的 编写者 和 用户 能够 不 通过 编程 来 设置 安全策略 。 ． 　 便于 扩展 的 访问控制 结构 　 　 一直 到 JDK ． 为止 ， 为了 创建 个 新 的 访问 许可 ， 你 必须 在 SecurityManager 类中 增加 个 新 的 check 方法 。 新 的 安全 体系结构 则 允许 设置 各类 访问 许可 （ 每个 都 表示 对个 系统资源 的 访问 ） ， 并 能 对 所有 正确 访问 许可 （ 包括 未定义 的 许可 ） 进行 自动 处理 。 ． 　 安全检查 扩展 至 所有 Java 程序 　 　 那种 所有 本地 代码 是 可信 的 内置 概念 将 不复存在 ， 取而代之 的 将 是 本地 代码 （ 例如 非 系统 代码 ， 安装 在 本地 的 应用 程序包 等 ） 服从 于 与 Applet 相同 的 安全控制 ， 但是 可以 声明 对 本地 代码 的 政策 是 最 宽容 的 ， 从而 使 这些 代码 可 被 认为 是 完全 可信 而 有效 地 运行 。 上述 原则 也 可 应用 于 已 签字 的 Applet 和 任何 Java 应用程序 。 　 Java 安全 体系 的 概念 及 运行机制 ． 　 保护 域 　 　 Java 安全 体系结构 中 的 一个 基本 的 概念 是 保护 域 （ ProtectedDomain ） 。 个域 可 通过 对象 集来 划分 范围 ， 这些 对象 当前 可由个 主体 直接 访问 。 而 主体 是 在 计算机系统 中 被 授予 许可 的 实体 。 JDK ． 所 利用 的 沙箱 就是 一个 有着 固定 边界 的 保护 域 实例 。 保护 域 的 概念 是 一种 在 保护 单元 间 起 着 分组 和 隔离 作用 的 便利 机制 。 例如 ， 我们 可以 将 保护 域 分开 以 避免 它们 之间 的 直接 交互作用 ， 于是 ， 任何 允许 的 交互作用 必须 通过 可信 系统 代码 或 被 有关 的 域 所 明确 允许 。 　 　 保护 域 通常 分为 明确 的 个 类别 ， 系统 域 和 应用程序 域 。 所有 被 保护 的 外部 资源 如 ： 文件系统 、 网络设施 以及 屏幕 和 键盘 等 仅 能 通过 系统 域来 访问 。 图中 显示 了 个 Java 应用环境 的 域 的 组成 。 从 概念 上 讲 ， 个域 包括 组类 ， 这些 类 的 实例 被 授予 相同 的 一组 许可 。 保护 域 是 由 现行 策略 所 确定 的 。 Java 应用程序 环境 保持 了 来自 代码 （ 类 和 实例 ） 到 它们 的 保护 域 然后 再 到 它们 的 许可 的 映射 ， 如图所示 。 个 线程 的 执行 可能 完全 发生 在 个 单一 的 保护 域 中 ， 也 可能 涉及 个 应用程序 域 或是 系统 域 。 例如 ： 个 打印消息 的 应用程序 将 不得不 与 系统 域 发生 交互作用 ， 因为 系统 域 是 唯一 对 输出 流 的 访问 点 。 在 此种 情况 下 的 任何 时候 ， 应用程序 域 都 不能 通过 调用 系统 域 获得 除 打印消息 外 的 任何 额外 许可 ， 否则 将 是 一个 严重 的 安全性 隐患 。 在 相反 的 情形 下 ， 个 系统 域 从 个 应用程序 域 中 调用 个 方法 ， 如当个 AWT 系统 域 调用 个 Applet 的 绘画 方法 来 显示 这个 Applet 时 ， 有效 访问 权限 与 应用程序 域 所 允许 的 当前 权限 在 任何 时候 都 相同 ， 这 一点 也 是 同样 至关重要 的 。 换句话说 ， 一个 具有 较 低 权限 的 域 不能 通过 调用 一个 更高 权限 的 域 ， 或 被 一个 更高 权限 的 域 所 调用 来 获得 额外 的 许可 。 上述 有关 个 线程 涉及 个 保护 域 的 讨论 自然 地 归纳 为个 遍历 多重 保护 域 的 线程 ， 计算 许可 的 一个 简单 而 谨慎 的 经验 做法 是 ： 图 Java 应用环境 的 域 的 组成 图类 → 保护 域 → 权限 的 映射 　 　 （ ） 一个 执行 线程 的 许可 集可 被 认为 是 由 该 线程 所 遍历 的 所有 保护 域 的 许可 的 交集 。 　 　 （ ） 当条 代码 调用 doPrivileged 方法 时 ， 执行 线程 的 许可 集 被 认为 是 包括 所有 代码 的 保护 域 以及 由 它 直接 或 间接 调用 的 保护 域 的 权限 。 即 通过 doPrivileged 方法 可使 条 可信 代码 能 临时 访问 更 多 的 资源 ， 这 在 某些 情况 下 是 必要 的 。 例如 ， 个 应用程序 可能 不 被 允许 直接 访问 包含 字体 的 文件 ， 但是 ， 显示 文本 的 系统 实用程序 必须 代表 用户 获得 那些 字体 。 　 　 在 执行 期间 ， 当 请求 访问 个 关键 系统资源 （ 如 文件 I ／ O 和 网络 I ／ O ） 或者 API 方法 需要 执行 个 敏感 的 操作 时 ， 例如 读个 文件 ， 资源 处理 代码 直接 或 间接 地 调用 个 特殊 的 称为 访问控制 （ AccessController ） 类 的 方法 ， 访问控制 类 通过 检查 调用 栈来 作出 决定 是否 准予 该 请求 或 操作 发生 。 在 调用 栈中 是 执行 该 操作 需要 调用 的 一些 类 的 成员 方法 ， 因为 每个 类 都 属于 一些 保护 域 ， 每个 保护 域 都 建立 了 一些 策略 ， 因此 在 调用 栈 的 每个 方法 都 被 分配 了 组 权限 。 访问控制 类由栈 顶 开始 ， 自顶向下 检查 每个 方法 ， 看 是否 方法 被 所在 的 保护 域 所 允许 ， 如果 发现 一个 方法 权限 没有 得到 允许 ， 访问控制 类 就 抛出 安全性 异常 ； 反之 ， 如果 到达 栈底 仍 未 抛出 异常 ， 即 说明 调用 栈中 的 所有 方法 均 满足 保护 域 的 权限 要求 ， 访问控制 允许 操作 发生 。 其中 有 一种 特殊 的 情况 ， 即当 访问控制 遍历 调用 栈时 ， 将 查找 是否 存在 优先 域 （ PrivilegedDomain ） ， 如果 存在 优先 域 ， 即使 没有 到达 栈底 ， 访问控制 也 将 停止 遍历 调用 栈 并 允许 操作 发生 。 虽然 新 的 安全 机制 初 看上去 增加 了 许多 调用 API 方法 的 消耗 ， 但是 Java 确实 使用 了 一些 技术 去 加速 检查 权限 的 过程 ， 例如 访问控制 将 过滤 掉 重复 的 域 并 在 遇到 第一个 优先 域时 停止 检查 ， 这 说明 额外 的 操作 将 是 一个 本地 的 方法 调用 ， SUN 的 基准 测试 显示 了 新 的 安全检查 是 相当 快 的 。 　 　 最后 ， 每个 域 包括 系统 或 应用程序 域 可以 对 其域 边界 内 的 内部 资源 进行 附加 保护 。 例如 ， 一个 银行 系统 的 应用程序 可能 需要 支持 并 保护 其 内部 的 一些 概念 ， 如 查帐 、 存款 和 取款 等 。 由于 此种 保护 的 语义 不像 那些 可 预测 的 语义 可以 被 JDK 预置 ， 因而 ， 在 这个 层次 上 的 保护 最好 留给 系统 或 应用 程序开发 员来 做 。 　 　 目前 ， 个域 单独 地由个 代码 来源 （ CodeSource ） 鉴别 ， 它 封装 了 在 该域 中 运行 的 代码 的 个 特性 ： 代码 基址 和 公共 密钥 证书 集 ， 公共 密钥 对应 于 在 该域 中为 所有 代码 签字 的 私有 密钥 。 因而 ， 由 相同 的 密钥 签字 和 来自 相同 URL 的 类 被 放在 同一个 域 中 。 个域 还 包含 在 该域 中 授予 代码 的 许可 ， 它 是 由 现行 安全策略 所 决定 的 。 ． 　 证书 、 钥匙 库 及其 相关 工具 　 　 在 Java 的 安全 体系 下 ， 个 Applet 开发 和 运行 的 过程 如下 ： 　 　 在 代码 的 分 发端 ： 　 　 （ ） 开发 Java 源程序 并 对 其 进行 编译 。 　 　 （ ） 用 JAR 工具 对类 文件 和 资源 文件 进行 封装 。 　 　 （ ） 用 keytool 创建 公钥 和 密钥 ， 生成 X 。 V 签名 证书 ， 输出 证书 。 　 　 （ ） 通过 jarsigner 工具 用 生成 的 密钥 对 JAR 文件 进行 数字签名 。 　 　 在 代码 的 接收端 ： 　 　 （ ） 用 keytool 输入 证书 视其为 可 信任 。 　 　 （ ） 用 policytool 创建 和 修改 安全性 策略 配置文件 ， 授权 请求 的 访问 权限 。 　 　 （ ） 从 网络 取得 字节 码 ， 用公钥 验证 数字签名 证书 和 文档 代码 的 完整性 。 　 　 （ ） 验证 字节 码 的 合法性 ， 根据 策略 文件 分配 相应 权限 。 　 　 （ ） 执行 代码 ， 完成 后 被 垃圾 回收 器 回收 内存 。 　 　 在 用 公钥 验证 数字签名 证书 之前 ， 接收 方 需要 确认 公钥 自身 的 可靠性 ， 因此 通常 情况 是 提供 一个 包含 公钥 的 证书 而 不是 公钥 自身 。 个 证书 包括 ： 　 　 （ ） 个 公钥 。 　 　 （ ） 个 唯一 的 名字 实体 （ 个人 或 公司 ） ， 它 是 证书 的 所有者 ， 包含 用户 名字 、 公司 、 组织 、 城市 、 地址 、 国家 代码 、 省份 等 信息 。 　 　 （ ） 数字签名 ： 个 证书 被 个 分发者 的 实体 签名 ， 保证 证书 确实 包含 另个 实体 （ 所有者 ） 的 公钥 。 　 　 （ ） 分发者 的 标识 名 信息 。 　 　 对于 接收者 可以 用 分发者 的 公钥来 验证 他 的 数字签名 ， 检查 证书 的 合法性 。 然而 公钥 可能 包含 在 另 一个 证书 中 ， 而 数字签名 需要 用 另 一个 证书 的 分发者 的 公钥来 验证 ， 这样 嵌套 下去 ， 直到 一个 公钥 被 接收者 确认 是 可 信任 的 。 如果 接收者 不能 建立 信任 链 ， 例如 ： 个 分发者 的 证书 不 合法 ， 那么 可以 用 keytool － import 命令 来 计算 指纹 ， 每个 指纹 是 一个 相关 的 短 数字 ， 它 唯一 可靠 地 标识 证书 （ 指纹 是 一个 用 信息 摘要 算法 计算 的 证书 信息 的 哈希 值 ） ， 接收者 可以 呼叫 证书 的 所有者 ， 并 比较 发出 的 证书 和 接收 证书 的 指纹 ， 如果 指纹 相同 ， 则 证书 不同 。 因此 能够 保证 证书 在 传递 的 过程 中未 被 修改 。 另 一个 潜在 的 问题 是 发送者 身份 的 标识 ， 有时 一个 证书 是 自 签名 的 ， 即 使用 证书 中 的 公钥 相对 应 的 密钥 进行 签名 ， 如果 接收者 已经 知道 或 信任 发送者 ， 那么 就 没有 任何 问题 。 否则 发送者 需要 从 一个 可 信任 的 第方 得到 证书 ， 这个 第方 通常 是 一个 证书 的 授权 机构 CA ， 那么 首先 发送 一个 自 签名 的 证书 签名 请求 CSR 给 CA ， 由 CA 验证 CSR 的 签名 及 发送 CSR 的 身份 、 许可证 以及 其它 信息 。 然后 CA 通过 一个 用 CA 的 密钥 进行 签名 的 证书 ， 授权 CSR 的 发送者 作为 公钥 的 所有者 ， 任何人 只要 信任 CA 的 公钥 ， 都 可以 用之来 验证 证书 的 签名 ， 很多 情况 下 CA 自身 有 一个 来自 更高 一级 的 CA 的 证书 ， 从而 构成 证书 链 。 所有 信任 的 证书 实体 都 可以 作为 信任 证书 被 引入 钥匙 库 ， 每个 证书 中 的 公钥 都 可以 用来 验证 用 相应 的 密钥 生成 的 签名 。 　 　 发送者 在 发送 签名 的 代码 和 文档 时 还 相应 提供 包含 与 签名 的 密钥 相应 的 公钥 证书 。 用 keytool － export 命令 或 API 函数 可以 从 钥匙 库中 输出 证书 到 文件 中 ， 然后 将 这个 文件 发送给 需要 的 接收者 ， 由 接收者 用 keytool － import 命令 或 API 函数 将 其 引入 钥匙 库中 。 如果 用 jarsigner 工具 为 JAR 文件 生成 签名 ， 他会 从 钥匙 库中 取出 证书及 证书 链 ， 并 和 签名 一起 放入 JAR 文件 。 　 　 密钥 和 相应 的 公钥 证书 存放 在 一个 由 口令 保护 的 数据库 中 ， 称为 钥匙 库 （ keystore ） 。 个 钥匙 库 包含 种 类型 的 条目 ， 可 信任 的 证书 条目 ， 钥匙 和 证书 条目 ， 每个 都 包含 个 密钥 和 与 密钥 相应 的 公钥 证书 ， 在 钥匙 库中 的 每个 条目 都 有 个别 名 进行 标识 。 个 钥匙 库 的 所有者 在 钥匙 库中 可以 有 多个 钥匙 ， 可以 通过 不同 的 别名 进行 访问 ， 每个 别名 通常 是 用 钥匙 库 的 所有者 使用 的 钥匙 的 特定 角色 来 命名 ， 别名 也 可以 标识 钥匙 的 目的 。 例如 ： SignPersonalEmail 可以 被 用来 标识 个 钥匙 库 的 条目 ， 它 的 密钥 用于 签名 个人 邮件 ， SignJarFiles 用于 标识 个 条目 ， 它 的 密钥 用于 签名 JAR 文件 。 　 Java 安全性 的 应用 　 　 Java 提供 了 开放 的 、 无 垄断 的 标准 。 对于 高可靠性 的 IT 行业 如 金融 、 政府 和 健康 医疗 、 WEB 服务 、 电子商务 站点 是 非常 重要 的 。 有 了 Java 的 企业 安全 特性 ， IT 厂商 可以 从 那些 为 安全 框架 所作 的 繁重 的 编码 及 维护 工作 中 解放出来 ， 将 应用程序 的 体系 架构 交第方 厂商 解决 ， 或者 手工 的 在 多个 计算 网络 中 集成 安全性 连接 。 新 的 Java 的 安全 模式 还 承诺 能够 降低 开发 分布式系统 的 时间 及 费用 ， 例如 ： Java 加密 体系 API 希望 成为 Java 技术 阵营 中 事实 的 标准 。 开发者 只要 学习 加密 次 即可 在 任何 地方 重用 。 JCA ／ JCE ． 将 安全性 连接 视同 原来 的 输入 流 技术 ， 也 即 程序员 可以 将 安全性 连接 看作 原先 的 基于 I ／ O 的 同步 网络 技术 流 。 　 　 增强 的 Java 安全性 加密 体 （ JCA ） 允许 开发人员 增强 数据服务 去 保护 当今 的 分布式计算 的 安全性 ， 例如 传输 数字证书 ； 在 SSL 上 的 流式 服务 ； 公钥 ／ 密钥 的 生成 、 存储 和 返回 ； 密钥 在 不同 的 密钥 表示 之间 进行 转换 。 所有 这些 都 是 Java 平台 的 一次 巨大 的 飞跃 。 直到现在 ， 一些 支持 Java 技术 的 IT 仍然 对 原始 的 沙箱 模式 存在 争论 ， 沙箱 模式 将 自动 地 将 用户 、 Applet 、 应用程序 和 资源 分成 完全 独立 的 二类 ， 完全 可 信任 和 不可 信任 。 Java 的 企业 安全 模式 不再 将 Applet 和 应用程序 限制 在 沙箱 中 。 沙箱 的 概念 是 具有 创造性 的 ， 但 存在 局限性 ， SUN 正在 将 无 控制 状态 下 的 安全 保护 转移 到 建立 在 保护 域 概念 上 的 体系 完整 的 安全 系统 。 在 分布式应用 中为 保护 域 设置 策略 ， 这样 开发人员 可以 容易 地 处理 现代 安全 机制 ， 如 权限 、 加密 、 数字签名 和 证书 。 安全性 已经 在 开发人员 及 管理员 的 控制 之下 。 　 　 加密 API 和 I ／ O 方法 是 一致 的 。 但 IT 策划人员 和 独立 的 软件 开发商 仍然 能够 自由 地 增强 基础 的 Java 安全 模式 ， 而 无需 破坏 基于 原先 的 安全 模式 的 企业应用 。 使用 平台 的 扩展 对象 体系 ， 开发商 可以 使 他们 自己 的 基于 JavaAPI 的 加密 实现 更加 灵活 。 　 　 Java 新 的 安全 模式 最 重要 的 是 能够 建立 分布式系统 的 新 形式 。 它 允许 应用 体系 安全 扩展 和 开拓 企业 计算资源 ， 从 掌上 机 、 桌面 到 服务 ， 从 内部 到 外部 的 后台 办公 资源 的 任何 Java 技术 支撑 的 运行 环境 存在 的 地方 。 它 是 安全性 策略 的 核心 ， 因为 将 策略 表达式 从 实现 安全性 策略 的 实际 运行 环境 代码 中 分离出来 ， 在 其它 的 系统 如 UNIX 或 Windows 中 不能不 修改 核心 安全性 代码 而 增加 资源 并 保证 它们 的 安全性 。 使用 Java ， 能够 从 应用程序 的 可定义 对象 中 取得 权限 的 语义 ， 所以 开发人员 能够 很 容易 地 增加 资源 和 权限 。 如果 希望 构建 一个 从 智能卡 到 主 框架 的 可 伸缩 的 平台 ， 那么 上述 内容 是 非常 重要 的 ， 因为 我们 并不知道 它们 将 运行 在 何 设备 上 。 　 　 Java 的 安全 模式 能够 快速 简单 地 实现 标准 的 商用 组件 。 例如 信用卡 事务 的 SSL ， 提供 更 强壮 的 机制 去 为 严格 的 商业 — 商业 的 事务 增加 安全性 。 　 　 用 Java 语言 编写 的 软件 访问 本地 桌面 资源 ， 可以 使用 Java 对象 的 持久 化 存储 来 提高 应用程序 的 性能 并 同时 保证 对 资源 访问 的 安全性 。 只要 把 经常 使用 的 组件 存放 在 本地 ， 减少 下载 类 的 时间 ， 这样 的 持久 化 存储 对象 在 原始 的 沙箱 模式 中 很 难 实现 ， 因为 沙箱 模式 把 本地 存储 的 代码 认为 是 完全 可 信任 的 ， 对 本地 保护 的 资源 具有 完全 的 访问 权限 。 另外 系统 体系 可以 充分利用 本地 持久 化 存储 的 对象 来 保存 客户 的 资料 和 产品 的 信息 ， 并 对 他们 进行 离线 处理 ， 防止 通过 HTTPCookies 方式 保存 客户 状态 信息 带来 的 不 安全性 。 　 结束语 　 　 Java 的 安全 模式 向 IT 管理员 和 开发商 提供 了 完整 的 机制 。 过去 的 沙箱 不能 使 用户 访问 本地 桌面 资源 ， Java 的 安全 模式 使 用户 能够 为 Java 应用程序 分配 策略 权限 和 访问控制 ， 包括 用户 、 组 、 程序 、 操作系统 服务 、 客户机 和 服务器 以及 任何 组件 对象 ， 精确 定义 与 需要 访问 的 本地 桌面 资源 进行 互操作 的 安全级别 。 这样 能够 安全 、 充分 地 利用 本地 资源 ， 如 DLL 、 文件 、 目录 以及 操作系统 提供 的 服务 。 在 这样 的 安全性 保障 下 能够 让 Java 语言 编写 的 类 和 C ＋ ＋ 编写 的 本地 应用程序 具有 同样 的 功能 。 金胜昔 （ 南京 东南大学 计算机科学 与 工程系 ） 步 俊杰 （ 南京 东南大学 计算机科学 与 工程系 ） 吉逸 （ 南京 东南大学 计算机科学 与 工程系 ） 收稿 日期 ： １ ９ ９ ９ － １ ２ － ２ ０
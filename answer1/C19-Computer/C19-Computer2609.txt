软件 学报 JOURNALOFSOFTWARE 年 第期 第卷 VolNo 基于 双层 类 结构 的 继承 异常 处理 方法 张鸣 　 吕建 　 杨 大军 　 陶先平 　 　 摘要 　 继承 异常 是 并发 面向对象 语言 中 的 一个 很 重要 而且 也 是 处理 起来 很 困难 的 问题 ， 它会 使 同步 代码 难以 重用 为 解决 此 问题 文章 提出 了 一种 新 的 双层 类 结构 模型 的 方法 来 解决 继承 异常 问题 它 可 对 同步 代码 的 复用 提供 全方位 的 支持 　 　 关键词 　 继承 异常 控制 类 具体 类 关联 机制 　 　 中图法 分类号 　 TP 　 ATwolayeredclassMethodforSolvingtheInheritanceAnomalyZHANGMing 　 LJian 　 YANGDajun 　 TAOXianpingStateKeyLaboratoryforNovelSoftwareTechnologyNanjingUniversityNanjingInstituteofComputerSoftwareNanjingUniversityNanjing 　 　 Abstract 　 　 InconcurrentobjectorientedlanguagestheinheritanceanomalyisanimportantanddifficultproblemwhichmakessynchronizationcodesdifficulttoreuseBasedonthetwolayeredclassmodelanewmethodforsolvingtheinheritanceanomalyisproposedItcanprovidetheflexibleandsufficientsupporttothereuseofsynchronizationcodes 　 　 Keywords 　 Inheritanceanomalycontrolclassconcreteclassconnectingmechanism 　 　 随着 面向对象 技术 的 发展 面向对象 程序设计 语言 在 软件设计 、 模块化 、 可扩充性 、 可 复用 性 等 方面 给 软件 开发人员 带来 了 很大 的 方便 ［ ］ 继承 （ inheritance ） 是 顺序 面向对象 语言 （ sequentialobjectorientedlanguages ） 的 一个 基本 特点 继承 机制 是 面向对象 语言 的 重要 机制 之一 是 实现 软件 复用 （ reuse ） 和 可 扩充 的 有效 语言 机制 　 　 由于 应用 对 并行处理 的 需求 许多 学者 希望 能 将 并发 性 与 面向对象 技术 有机 地 结合 起来 通常 在 面向对象 环境 中 引入 对 并发 支持 可以 有 两种 途径 一种 是 在 现有 面向对象 环境 的 基础 上 再 另外 引入 与 并发 性 有关 的 一些 概念 如 进程 （ process ） 、 管程 （ monitor ） 等 Smalltalk ［ ］ 中 采用 的 就是 这种 方法 但 由于 对象 与 进程 概念 的 不同 会 在 问题 建模 和 进行 对象 保护 时 产生 问题 另 一种 方法 就是 将 对象 与 进程 两个 概念 有机 地 统一 成 并发 对象 的 概念 并 将 对象 间 消息传递 与 进程 间 交互 也 有机 地 结合 在 一起 Act 和 ABCL 采用 的 就是 这种 方法 对象 既 是 一个 自 包含 模块 又 是 一个 并发 执行 单位 无论 采用 何种 途径 面向对象 技术 与 并发 机制 结合 都 有 一个 重要 问题 — — 继承 问题 即 如何 在 并发 面向对象 语言 中 提供 合适 的 继承 机制 　 　 很多 支持 并发 的 OO 语言 都 是 在 原来 语言 的 基础 上 融入 并发 的 特性 但 由于 并发 面向对象 环境 中 可以 同时 有 多个 消息 到达 并且 具有 不确定性 致使 并发 和 继承 会 产生 冲突 为 避免 这种 冲突 有 的 语言 中 就 不 提供 对 继承性 的 支持 比如 POOLT ［ ］ COOLPrestoEmerald 等 ［ ］ 严格来说 这 类 语言 不能 算是 面向对象 的 语言 而 只能 是 基于 对象 的 语言 另 一 途径 就是 如 Matroshka 中 采用 的 途径 它 仅 支持 静态 继承 提出 一种 同步 机制 来 避免 这种 冲突 虽然 POOLT 以后 的 版本 （ POOLR ） 中 提供 了 有 限制性 的 继承 但 许多 工作 都 需 由 程序员 来 完成 　 　 很 显然 上述 途径 并 不能 真正 地 解决 并发 语言 中 的 继承 异常 问题 因此 国际 上 对 并发 面向对象 语言 的 继承 异常 问题 进行 了 多方面 的 研究 提出 了 各种各样 的 解决 方法 本文 首先 分析 了 继承 异常 问题 然后 提出 一种 处理 继承 异常 的 新 方法 并 通过 例子 加以 说明 继承 异常 及 解决 途径 分析 　 　 所谓 继承 异常 就是指 为了 保证 并发 对象 的 完整性 在 某些 情况 下 必须 在 子类 中 重新 定 义父 类中 原来 可以 继承 的 方法 继承 异常 带来 的 后果 就是 破坏 了 面向对象 方法 的 最大 优点 信息 隐藏 （ 封装 性 ） 和 代码 重用 　 　 根据 不同 的 同步控制 机制 在 解决 继承 异常 时所 面临 的 问题 文献 ［ ］ 中以 有界 缓冲区 为例 说明 了 继承 异常 的 种 典型 情况 状态 分解 产生 的 异常 、 历史 有关 状态 产生 的 异常 、 状态 修改 产生 的 异常 通过 分析 可以 看出 继承 异常 产生 的 原因 是 没能 将 同步 约束 代码 与 方法 体 代码 从根本上 分开 因而 导致 在 子类 进行 继承 时 无法 继承 本来 可以 继承 的 父类 中 方法 的 代码 产生 继承 异常 　 　 继承 异常 作为 并发 面向对象 语言 中 的 一个 很 重要 的 问题 目前 已有 许多 试图 解决 它 的 语言 同步 机制 从 分离 同步 约束 代码 与 方法 体 代码 的 角度 （ 方法 可以 接收 的 正 条件 ） 出发 有 BehaviorAbstraction ［ ］ MethodGuards 以及 Synchronizers 和 TransitionSpecifications ［ ］ 等 方法 从 方法 不能 接收 的 条件 角度 考虑 比较 典型 的 就是 Illinois 大学 的 Frfund 提出 的 一种 基于 MethodGuards 的 框架 ［ ］ 上述 方法 虽 有 各自 的 特点 但 尚未 有 一种 比较 理想 的 方法 来 简洁 地 处理 继承 异常 问题 提供 对 同步 代码 重用 的 全方位 的 支持 　 　 归结 起来 我们 认为 要 对 同步 代码 的 复用 提供 全方位 的 支持 从根本上 解决 继承 异常 问题 必须 解决 好 以下 方面 的 问题 　 　 同步 代码 的 分离 问题 　 将 同步 代码 从 方法 体中 分离出来 是 解决 继承 异常 的 最 基本 的 要求 它 可 避免 同步 代码 与 方法 代码 在 继承 中 的 相干性 　 　 同步 代码 的 分解 问题 　 虽然 子类 中 的 方法 与 父类 中 的 方法 的 同步控制 约束 有 很大 的 相似性 但 同时 也 存在 部分 不同 因此 ， 如果 能 将 其中 不变 的 那 部分 同步 代码 继承 过来 将会 对 同步 代码 的 重用 提供 一个 很 好 的 手段 这里 的 分解 问题 实际上 就是 考虑 如何 合适 地 对 同步 代码 进行 模块化 使得 子类 能 重用 父类 中 没有 变化 的 同步 代码 　 　 同步 代码 的 独立 问题 　 实际 问题 中有 很多 情况 的 同步控制 模式 是 完全 一样 的 如 读写 模式 等 如果 能 将 这种 模式 写成 一个 公共 的 模式 再 把 该 同步 模式 关联 （ connecting ） 到 各个 具体 的 问题 上 就 可 在 更 大程度 上 达到 重用 同步 代码 的 效果 　 　 从 代码 重用 的 角度 来看 上述 个 问题 分别 是 方法 体 的 重用 、 部分 同步 代码 的 重用 、 整个 同步 代码 的 重用 个 不同 程度 重用 的 问题 或者说 前 两个 问题 是从 继承 的 角度 来 考虑 代码 重用 第个 问题 则 是 对 同步 代码 加以 直接 复用 迄今为止 尚未 见到 哪 一种 方法 能 同时 满足 这方面 的 要求 基于 上述 考虑 我们 提出 了 一 种类 的 双层 描述 思想 来 解决 同步 代码 的 重用 问题 基于 类 层次结构 的 方法 　 　 为了 解决 分离 问题 我们 首先 将 同步控制 部分 与 类体 部分 分开 从而 引入 了 控制 类 与 具体 类 的 概念 为了 解决 分解 问题 更 大程度 地 支持 同步 代码 的 重用 我们 对 并发 环境 中 同步控制 部分 的 执行 特点 以及 对类 本身 产生 的 影响 稍加 分析 就 可以 发现 同步控制 实际上 可以 分成 两个 子 部分 一部分 是 前置条件 判断 即 在 接收 到 消息 时 的 判断 另 一部分 是 后置 状态 转换 即 具体方法 执行 结束 对 抽象 状态 的 影响 因此 一个 完整 的 控制 类 的 定义 应该 包括 以上 两 部分 的 控制 基于 上述 考虑 我们 引入 了 guard 机制 和 消息 集合 相结合 的 方法 从而 可以 解决 较 小 粒度 的 重用 问题 为了 解决 独立 问题 我们 引入 了 关联 （ connecting ） 机制 它 使得 控制 类 可以 灵活 地 与 其他 各类 不同 的 具体 类 相连接 　 　 在 并发 环境 中 我们 可以 认为 类 由 两个 子类 构成 ， 分别 是 控制 类 和 具体 类其 结构 如图所示 图 　 类 结构 简图 　 　 控制 类 描述 类 的 抽象 状态 及其 转换 关系 （ 或 说 是 操作 ） 其 主要 作用 是 完成 类 的 消息 接收 的 同步控制 ， 主要 有 抽象 数据 （ 抽象 状态 和 抽象 变量 ） 和 抽象 方法 具体 类则 是 指 描述 具体 状态 及其 转换 关系 的 部分 或者说 就是 具体 的 实例 数据 及其 上 的 操作 实际上 这 一部分 与 顺序 环境 中 的 完全 一样 　 　 抽象 状态 是 控制 类中 最 核心 的 数据 是 用来 表示 对象 当前 所处 的 不同 消息 控制 状态 与 消息 的 接收 有关 也就是说 在 不同 的 抽象 状态 下类 所能 接收 的 消息 不 一样 抽象 状态 是 由 控制 类中 的 抽象 变量 来 定义 的 引入 抽象 变量 的 目的 在于 隔离 控制 类 与 具体 类 之间 的 直接 依赖 关系 这 一点 在 下面 将会 有 较 具体 的 说明 　 　 控制 类 和 具体 类 两者之间 具有 相对 的 独立性 他们 之间 的 关系 是 通过 特定 的 关联 关系 来 进行 连接 对象 在 接收 到 消息 后 首先 根据 对象 当前 所处 的 抽象 状态 以及 关联 关系 来 确定 该 消息 是否 可 接收 若 可 接收 则 执行 相应 的 具体 类中 的 方法 体在 结束 后 ， 如果 控制 类中 还有 相应 的 状态 转换 （ behavior ） 部分 则 执行 之 　 　 由于 控制 类 也 是 一 种类 因而 它 也 有 继承 等 有关 类 的 特性 控制 类 与 并发 环境 中 对象 的 同步控制 有着 密切 的 关系 因此 ， 本文 将 着重 讨论 控制 类 的 设计 语言 表示 机制 控制 类 的 定义 　 　 抽象 状态 是 控制 类中 最 核心 的 数据 控制 类 主要 就是 围绕 抽象 状态 来 进行 工作 的 一般来说 控制 类 的 定义 需 解决 个 问题 抽象 状态 的 定义 抽象 状态 与 可 接收 消息 集合 的 对应 问题 抽象 状态 与 具体 状态 变化 的 一致性 　 　 （ ） 抽象 状态 的 定义方法 　 　 抽象 状态 采用 表达式 来 定义 statenameexpression 其中 expression 是 用 抽象 变量 来 定义 的 根据 抽象 变量 与 具体 类 数据 能否 建立 关联 可以 有 以下 两类 情况 　 　 a 可以 与 具体 状态 建立 直接 关联 的 expression 在 这种 情况 下 抽象 变量 能 与 具体 变量 建立 直接 对应 关系 也就是说 抽象 状态 的 变化 依赖于 具体 状态 的 变化 实际上 这 隐含 了 抽象 状态 与 具体 状态 之间 的 映射 关系 从而 使 抽象 状态 的 变化 可 随着 具体 状态 的 变化 而 自动 地 进行 　 　 b 不能 与 具体 状态 建立 直接 关联 的 expression 抽象 状态 的 定义 与 具体 状态 无关 需要 定义 控制 类 的 变量 为了 保证 其 变化 与 具体 类 之间 的 一致性 需要 在 具体 类 的 方法 执行 完毕 后 由 控制 类 修改 相应 的 抽象 变量 以 保证 抽象 状态 与 具体 状态 的 一致性 　 　 （ ） 抽象 状态 与 可 接收 消息 集合 的 对应 问题 　 　 采用 方法 集合 来 定义 状态 的 可 接收 消息 Mstatename ≡ methodset 　 　 通过 建立 抽象 状态 statename 与 消息 集合 methodset 的 对应 关系 来 表示 当 对象 处于 抽象 状态 statename 时 可以 接收 集合 methodset 内 包含 的 消息 由于 methodset 是 以 集合 的 形式 来 定义 因此 可以 有 相应 的 交 、 并 等 基本 集合 运算 便于 重用 这里 的 消息 （ 方法 ） 集合 是 指 抽象 方法 集合 ， 它们 与 具体 类 方法 之间 的 关联 关系 则 由 关联 机制 来 实现 　 　 （ ） 抽象 状态 的 转换 关系 　 　 主要 解决 与 具体 类 状态 转换 之间 的 一致性 问题 　 　 通过 定义 一个 抽象 状态 转换 部分 behavior 来 完成 上述 功能 　 　 methodsetexpressions 表示 在 methodset 中 的 方法 执行 结束 后 还 需 完成 的 动作 该 部分 不是 必需 的 如果 在 抽象 状态 的 定义 中 包含 了 无法 与 具体 状态 建立 直接 关联 的 部分 则 为了 保证 二者 的 变化 一致性 需要 定义 这 一部分 控制 类 与 具体 类 之间 的 关系 　 　 系统 中 任一 对象 O 接收 到 某 消息 m 后 将 消息 m 存入 该 对象 的 消息 等待 对列 然后 按 下述 机制 进行 消息 处理过程 　 　 首先 扫描 本 对象 的 消息 等待 队列 若队 列为 空则 没有 待处理 的 消息 处于 空闲 状态 否则 ， 选取 队列 的 第个 消息 m 继续 步骤 　 　 根据 O 当前 所处 的 抽象 状态 ， 决定 m 是否 为 可 接收 消息 若 不可 接收 则 消息 m 继续 在 等待 队列 待处理 若 可 接收 则 将 m 送出 等待 队列 继续 步骤 　 　 执行 相应 的 具体 类 的 方法 m 的 方法 体 部分 　 　 控制 类若 有 与 m 相应 的 behavior 部分 的 转换 则 在 执行 完 步骤 之后 继续执行 该 相应 的 部分 　 　 实际上 控制 类 定义 的 抽象 状态 组成 一个 或 多个 状态 变化 循环 序列 同一 状态 循环 序列 内 的 各个 状态 之间 是 互斥 的 也就是说 任一 对象 在 任一 时刻 不 可能 处于 一个 循环 中 的 不同 状态 （ 这 就 保证 了 消息 同步控制 的 无 歧义 性 ） 但 可以 处于 不同 循环 中 的 不同 状态 只要 消息 属于 其中 一个 状态 的 可 接收 消息 集即 为 可 接收 消息 实际上 不同 状态 循环 只是 从 不同 角度 来 描述 对象 的 状态 变化 过程 及其 特点 关联 机制 　 　 为了 能 使 同步控制 满足 前面 所说 的 分离性 和 独立性 两 方面 的 要求 根据 上 面对 控制 类 所 需 解决问题 的 分析 采用 所谓 的 关联 机制 来 处理 这个 问题 　 　 由于 控制 类 采用 上述 方法 来 定义 因此 ， 为了 能 将 控制 类 的 同步控制 施加 到 具体 的 类 上 必须 在 控制 类 与 具体 类 之间 建立 一种 特殊 的 关联 关系 以 保证 两者之间 的 一致性 这种 关系 应 包含 两 方面 的 内容 抽象 变量 与 具体 变量 之间 的 关系 ， 抽象 方法 （ 集 ） 与 具体方法 之间 的 关系 可以 采用 下面 的 形式 建立 关联 　 　 connecting 〈 controlclassname 〉 ［ by 〈 关联 关系 定义 〉 end ］ ， 其中 〈 关联 关系 定义 〉 详细 刻画 了 抽象 变量 与 具体 变量 以及 抽象 方法 与 具体方法 之间 的 关联 关系 　 　 不论 控制 类 如何 定义 控制 类 与 具体 类 之间 的 关联 关系 都 是 通过 显式 和 隐式 两种 方法 给出 的 隐式 的 方法 主要 就是 利用 同名 相关联 的 原理 进行 显式 定义 就是 在 connecting 语句 之后 明确 给出 抽象 量 与 具体 量 、 抽象 方法 与 具体方法 之间 的 关联 关系 　 　 显式 定义 ： 明确 给出 抽象 变量 与 具体 变量 之间 、 抽象 方法 （ 集 ） 与 具体方法 之间 的 关联 关系 　 　 隐式 定义 ： 针对 一些 特殊 的 情况 如果 抽象 变量 与 具体 变量 、 抽象 方法 （ 集 ） 与 具体方法 同名 则 隐含地 认为 二者之间 有 直接 的 关联 关系 　 　 该 机制 使得 抽象 的 同步控制 部分 可以 十分 灵活 地 用于 不同 的 类 上 尤其 适合 于 那些 通用 的 同步控制 模式 提高 了 同步 代码 的 重用 程度 控制 类 的 继承 　 　 由于 控制 类 是 一 种类 因而 具有 类 的 很多 特性 其中 继承性 是 很 重要 ， 也 是 对 重用 有 很大 作用 的 特性 之一 　 　 子类 可以 通过 继承 机制 继承 父 控制 类中 的 数据 控制 类 继承 的 时候 一般来说 有 两种 情况 一种 是 没有 发生 抽象 状态 变化 的 继承 另 一种 就是 抽象 状态 发生变化 的 继承 第种 情况 很 简单 最 多 就是 改变 一下 抽象 状态 与 抽象 方法 的 对应 关系 这里 不 作 详细 的 讨论 下面 将 着重 说明 抽象 状态 发生变化 时 的 处理 问题 　 　 一般来说 子类 继承 父类 后 对 父类 中 状态 的 变化 有 两种 情况 ① 子类 对 父类 状态 的 分解 ② 子类 中 增加 一些 新 的 状态 因此 相应 地 引入 decompose 和 add 两种 方法 来 处理 　 　 基于 状态 继承 的 decompose 方法 　 　 对于 状态 分解 异常 可以 采用 decompose 机制 来 处理 decomposestateinto 〈 statelist 〉 该 机制 主要 针对 状态 分解 产生 的 继承 异常 问题 将 需要 分解 的 父类 中 的 抽象 状态 state 通过 decompose 在 子类 中 分解 为 多个 状态 〈 statelist 〉 其他 不需 改变 的 状态 则 直接 继承 过来 （ 子类 中 也 就 不 存在 抽象 状态 state ） 对于 相应 状态 的 可 接收 消息 集合 也 作 相应 的 重 定义 （ 能 继承 的 则 继承 过来 ） 对 父类 中 消息 集合 的 引用 采用 super 进行 　 　 基于 状态 继承 的 add 方法 该 机制 就是 在 子类 中 增加 新 的 抽象 状态 原来 父类 中 的 状态 则 以 继承 的 方式 继承 过来 仍然 有效 add 〈 statelist 〉 表示 子类 中将 增加 〈 statelist 〉 中 的 新 的 状态 父类 中 的 状态 被子 类 继承 过来 仍然 有效 此时 原来 父类 中 关于 抽象 状态 的 可 接收 消息 集 的 定义 可以 继承 过来 但 在 子类 中需 增加 对 新增 抽象 状态 的 可 接收 消息 集 的 定义 　 　 对于 不 符合 上述 两种 方法 的 情况 则 采用 一般 的 定义方法 例子 　 　 下面 我们 就 用 前面 所 介绍 的 方法 来 处理 先入 先出 （ FIFO ） 的 有界 缓冲区 例子 所 产生 的 几种 典型 的 问题 有 界 缓冲区 对象 有 两个 公共 方法 put 和 getput 插入 一个 元素 到 缓冲区 中 get 从 缓冲区 中 删除 一个 最先 进来 的 元素 size 表示 当前 缓冲区 中 元素 的 数目 MAX 表示 缓冲区 最大 容量 显然 在 并发 环境 中 对 get 和 put 方法 的 调用 需要 相应 的 同步 约束条件 利用 前面 所 介绍 的 方法 可定义 缓冲区 对象 如下 　 　 controlclass 　 　 　 　 buffersync 　 　 　 　 　 　 ∥ 控制 类 定义 　 　 　 　 　 　 state 　 　 　 emptypartialfull 　 　 　 　 ∥ 抽象 状态 　 　 　 　 　 　 int 　 　 　 　 sizeMAX 　 　 　 　 　 　 　 ∥ 抽象 变量 　 　 　 　 　 　 method 　 　 getput 　 　 　 　 　 　 　 　 ∥ 抽象 方法 （ 集 ） 　 　 　 　 　 　 relation 　 　 　 　 　 　 　 　 　 　 　 emptysize 　 　 　 　 　 　 　 　 　 　 　 partial ＜ size ＜ MAX 　 　 　 　 　 　 　 　 　 　 　 fullsizeMAX 　 　 　 ∥ 可 接收 消息 集 的 定义 　 　 　 　 　 　 　 　 　 　 　 Mempty ≡ put 　 　 　 　 　 　 　 　 　 　 　 Mpartial ≡ getput 　 　 　 　 　 　 　 　 　 　 　 Mfull ≡ get 　 　 　 　 class 　 　 buffer 　 　 　 　 　 　 　 　 　 　 　 　 　 ∥ 具体 类 定义 　 　 　 　 connecting 　 　 　 buffersync 　 　 　 　 　 　 ∥ 隐式 关联 控制 类 buffersync 　 　 　 　 　 　 int 　 　 　 　 sizebuf ［ MAX ］ 　 　 　 　 public 　 　 　 　 　 　 int 　 　 　 　 get 　 　 　 　 　 　 　 ∥ 取走 一 元素 　 　 　 　 　 　 　 　 　 　 　 　 size 　 　 　 　 　 　 　 void 　 　 　 put 　 　 　 　 　 　 　 　 ∥ 插入 一 元素 　 　 　 　 　 　 　 　 　 　 　 　 size 　 　 　 get 引起 的 继承 异常 　 　 当 在 类 buffer 的 子类 xbuffer 中 加入 新 方法 get 同时 取 走 缓冲区 中 的 两个 元素 时会 引起 状态 分解 异常 在 这里 采用 decompose 机制 解决 如下 　 　 controlclas 　 　 　 　 　 xbuffersyncbuffersync 　 　 ∥ 继承 buffersync 的 同步 代码 　 　 　 　 　 　 state 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ∥ emptyfull 继承 父类 　 　 　 　 　 　 　 decomposepartial 　 intoxonexpartial 　 　 ∥ 分解 状态 partial 　 　 　 　 　 　 method 　 　 get 　 　 　 　 　 　 　 　 　 　 　 ∥ 抽象 方法 getput 继承 过来 　 　 　 　 　 　 relation 　 　 　 　 　 　 　 　 xonesize 　 　 　 　 　 　 　 　 xpartial ＜ size ＜ MAX 　 　 　 　 　 　 　 　 ‘ ∥ ’ 可 接收 消息 集 的 定义 ‘ ‖ ’ 为 集合 的 并 操作 　 　 　 　 　 　 　 　 Mxone ≡ superMpartial 　 　 　 　 　 　 　 　 Mxpartial ≡ get ‖ superMpartial 　 　 　 　 　 　 　 　 Mfull ≡ get ‖ superMfull 　 　 　 　 class 　 　 　 　 　 　 　 xbufferbuffer 　 　 　 　 　 　 　 ∥ 具体 类 定义 　 　 　 　 connecting 　 　 　 xbuffersync 　 　 　 　 　 　 　 　 ∥ 隐式 关联 控制 类 xbuffersync 　 　 　 　 　 　 public 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ∥ 实例 变量 、 getput 继承 父类 　 　 　 　 　 　 get 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ∥ 取 走 两个 元素 　 　 　 　 　 　 　 　 　 　 sizesize 　 　 　 　 gget 引起 的 继承 异常 　 　 当 在 类 buffer 的 子类 xbuffer 中 引入 新 方法 gget （ 除了 不能 在 put 方法 调用 后 立即 执行 外 与 get 完全相同 ） 后 会 产生 与 历史 有关 的 继承 异常 这里 应用 Add 机制 可 按 如下 定义 解决 此 问题 　 　 controlclass 　 　 　 xbuffersyncbuffersync 　 　 ∥ 控制 类 定义 　 　 　 　 　 　 state 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ∥ emptypartialfull 继承 父类 　 　 　 　 　 　 　 　 add 　 　 ggetstat 　 　 　 　 　 　 　 　 ∥ 增加 新 状态 ggetstat 　 　 　 　 　 　 bool 　 　 　 　 afterput 　 　 　 　 　 　 　 　 ∥ 抽象 变量 其他 继承 过来 　 　 　 　 　 　 method 　 　 　 gget 　 　 　 　 　 　 　 　 　 　 ∥ 抽象 方法 其他 继承 过来 　 　 　 　 　 　 relation 　 　 　 　 　 　 　 　 ggetstatafterputfalsesuperpartial 　 　 　 　 　 　 　 　 Mggetstat ≡ gget 　 　 　 　 　 　 behavior 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ∥ 抽象 状态 转换 部分 　 　 　 　 　 　 　 　 putafterputtrue 　 　 　 　 　 　 ∥ put 继承 父类 中 　 　 　 　 　 　 　 　 defaultafterputfalse 　 　 　 　 　 ∥ 缺省 所作 的 状态 变化 　 　 　 　 class 　 　 　 　 　 　 　 xbufferbuffer 　 　 　 　 　 　 　 ∥ 具体 类 定义 　 　 　 　 　 　 connecting 　 xbuffersync 　 　 　 　 　 　 　 　 ∥ 隐式 关联 控制 类 xbuffersync 　 　 　 　 　 　 public 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ∥ 实例 变量 、 getput 继承 父类 　 　 　 　 　 　 　 　 　 　 　 ggetsuperget 　 　 关联 机制 的 例子 　 　 下面 以 读者 和 写者 模式 为 例来 说明 关联 机制 写 操作 之间 、 写 操作 与 读 操作 之间 必须 互斥 读 操作 之间 可以 同时 进行 （ 当然 ， 该 功能 也 可以 通过 其他 方法 来 实现 这里 仅 说明 关联 机制 的 特点 ） 　 　 Rop 和 Wop 分别 代表 读者 类 和 写者 类 的 方法 可以 定义 这样 种 抽象 状态 idlestatereadstatewritestate 状态 idlestate 表示 当前 没有 任何 方法 在 执行 可以 接收 读 和 写 操作 状态 readstate 表示 当前 已有 读 操作 在 执行 因此 为 保证 互斥性 只能 接收 读 操作 而 不能 接收 写 操作 状态 writestate 表示 当前 正在 进行 写 操作 拒绝 任何 其他 操作 采用 计数器 （ 抽象 变量 ） 来 表示 当前 读 、 写 操作 的 情况 具体 定义 如下 　 　 controlclass 　 　 readerwriter 　 　 　 　 　 ∥ 控制 类 的 定义 　 　 　 　 　 state 　 　 idlestatereadstatewritestate 　 　 　 　 　 int 　 　 　 rcountwcount 　 　 　 　 ∥ 抽象 变量 　 　 　 　 　 method 　 　 　 　 　 　 　 Rop 　 rcount 　 　 　 　 ∥ 抽象 方法 操作 定义 　 　 　 　 　 　 　 Wop 　 wcount 　 　 　 　 　 relation 　 　 　 　 　 　 　 　 idlestatercountwcount 　 　 　 　 　 　 　 　 readstatewcountrcount 　 　 　 　 　 　 　 　 writestatewcount 　 　 　 　 　 　 　 　 Midlestate ≡ Rop ‖ Wop 　 　 　 　 　 　 　 　 Mreadstate ≡ Rop 　 　 　 　 　 　 　 　 Mwritestate ≡ 　 　 　 　 　 behavior 　 　 　 ∥ 状态 转换 　 　 　 　 　 　 　 　 Roprcount 　 　 　 　 　 　 　 　 Wopwcount 　 　 　 　 下面 我们 希望 定义 这样 一个 缓冲区 的 类 其中 有 两类 方法 一类 是 关于 测试 缓冲区 状态 的 方法 如 empty （ 缓冲区 空否 ） 等 另一类 是 改变 缓冲区 内部 元素 的 方法 如 getput 等 现在 要求 这 两类 方法 按 读写 模式 进行 同步控制 即 第类 方法 相当于 读写 模式 中 的 “ 读 ” 操作 第类 操作 相当于 读写 模式 中 的 “ 写 ” 操作 应用 关联 机制 定义 如下 　 　 classrwbufferbuffer 　 　 　 　 　 　 ∥ 是 类 buffer 的 子类 　 　 　 　 　 　 connectingreaderwriter 　 　 ∥ 显式 关联 控制 类 readerwriter 　 　 　 　 　 　 　 by 　 Ropempty 　 　 　 　 　 　 　 　 Wopgetput 　 　 　 　 　 　 　 end 　 　 　 　 　 　 　 public 　 　 　 　 　 　 　 　 ∥ getput 继承 父类 　 　 　 　 　 　 　 　 　 empty 　 　 　 　 　 ∥ 测 缓冲区 空否 　 　 　 　 　 　 　 　 　 　 　 　 　 ifsizereturntrue 　 　 　 　 　 　 　 　 　 　 　 　 　 elsereturnfalse 　 　 　 　 结语 　 　 我们 认为 要 对 同步 代码 的 复用 提供 全方位 的 支持 从根本上 解决 继承 异常 问题 必须 解决 好 同步 代码 的 分离 、 分解 和 独立 这个 方面 的 问题 迄今为止 尚未 见到 有 哪 一种 方法 能 同时 满足 这方面 的 要求 因此 ， 我们 提出 了 上述 类 的 双层 描述 思想 来 解决 同步 代码 的 重用 问题 对 解决 继承 异常 问题 进行 了 新 的 尝试 　 　 由 上面 的 例子 我们 可以 看到 控制 类 的 定义 与 具体 类 之间 完全 隔离 于 一方面 可以 使 具体 类 部分 在 继承 的 时候 不 受 控制 类 的 干扰 另一方面 也 可以 使 抽象 的 同步控制 代码 灵活 地 与 其他 具体 的 类 相结合 不 受 具体 类 代码 的 限制 从而 可以 提供 方法 体 、 部分 同步 代码 以及 整个 同步 代码 的 个 不同 程度 的 重用 支持 　 　 以上 着重 考虑 的 是 不同 对象 间 的 并发 以及 对象 内 不同 操作间 的 并发 问题 （ 不同 对象 或 同一 对象 同时 调用 相同 的 方法 ） 关于 同一 对象 里 操作 内部 的 并发 问题 不是 本文 讨论 的 范围 对于 同步 点 在 操作 中间 的 并发 问题 则 可以 归结为 对象 内 操作间 的 并发 问题 来 考虑 　 　 进一步 的 工作 就是 将 上述 思想 融入 并发 面向对象 规约 语言 和 并发 面向对象 程序设计 语言 之中 并 探讨 其 实现 技术 另一方面 目前 关于 并发 面向对象 中 的 继承 问题 的 讨论 主要 集中 在 被动 对象 类中 同步 代码 的 继承 问题 上 而 对 主动 对象 及其 协同 代码 的 继承 问题 的 讨论 未见 涉及 值得 开展 进一步 的 讨论 　 本文 研究 得到 国家自然科学基金 、 国家 杰出青年 科学基金 和 国家 攀登 计划 基金 资助 作者简介 　 张鸣 年生 博士生 主要 研究 领域 为 面向对象 语言 形式化 方法 　 　 　 　 　 吕建 年生 博士 教授 博士生 导师 主要 研究 领域 为 软件 自动化 并行程序 形式化 方法 并发 面向对象 语言 和 环境 等 　 　 　 　 　 杨 大军 年生 博士生 主要 研究 领域 为 面向对象 语言 形式化 方法 　 　 　 　 　 陶先 平年生 讲师 主要 研究 领域 为 软件体系结构 面向对象 应用 框架 软件 自动化 本文 通讯联系 人 张鸣 南京 南京大学 计算机软件 研究所 作者 单位 ： 南京大学 计算机软件 新 技术 国家 重点 实验室 南京 　 　 南京大学 计算机软件 研究所 南京 Emailljnetranjueducn 参考文献 　 　 徐家 福等 对象 式 程序设计 语言 南京 南京大学 出版社 XuJiafuetalObjectorientedProgrammingLanguagesNanjingNanjingUniversityPress 　 　 YokoteYasuhikoTokoroMarioConcurrentprogramminginconcurrentSmalltalkObjectorientedConcurrentProgrammingCambridgeMITPress 　 　 AmericaPierrePOOLTaparallelobjectorientedlanguageObjectorientedConcurrentProgrammingCambridgeMAMITPress 　 　 WyattBetalParallelisminobjectorientedlanguagesasurveyIEEESoftware ～ 　 　 MatsuokaStaoshiYonezawaAkinoriAnalysisofinheritanceanomalyinobjectorientedconcurrentprogramminglanguagesInAghaGWegnerGYonezawaAkinoriedsResearchDirectionsinConcurrentObjectorientedProgrammingCambridgeMAMITPress 　 　 KafuraDGLeeKHInheritanceinactorbasedconcurrentobjectorientedlanguagesInCookSedProceedingsoftheEuropeanConferenceonObjectorientedProgrammingCambridgeCambridgeUniversityPress 　 　 MatsuokaSatoshietalHighlyefficientandencapsulatedreuseofsynchronizationcodeinconcurrentobjectorientedlanguagesACMSigplanNotices ～ 　 　 FrflundSInheritanceofsynchronizationconstraintsinconcurrentobjectorientedconcurrentlanguagesInMadsenOLedProceedingsoftheEuropeanConferenceonObjectorientedProgrammingBerlinHeidelbergSpringerVerlag ～ 本文 收到 原稿 收到 修改稿
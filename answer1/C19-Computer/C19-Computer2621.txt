软件 学报 JOURNALOFSOFTWARE 年 第卷 第期 　 NoVol 一种 运行 时 消除 指针 别名 歧义 的 新 方法 汤志忠 　 乔林 　 张 赤红 　 苏伯珙 　 　 摘要 　 提出 一种 采用 软硬件 结合 的 运行 时 消除 指针 别名 歧义 的 新 方法 SHRTD （ softwarehardwareruntimedisambiguation ） 为 延迟 运行 时 不 正确 的 内存 访问 及其 后继 操作 SHRTD 的 功能 单元 执行 NOP 操作 为 保证 所有 延迟 操作 执行 顺序 的 一致性 编译 时 就 确定 执行 NOP 操作 的 所有 功能 单元 的 顺序 和 NOP 操作 的 数目 SHRTD 方法 适用 于 不 可逆 代码 同时 它 的 代码 空间 受限 也 不 存在 严重 的 代码 可重 入性 问题 新 方法 有效 地 解决 了 指针 别名 问题 为 获得 潜在 的 指令 级 并行 加速 提供 了 可能 　 　 关键词 　 指令 级 并行性 超长 指令 字 指针 别名 运行 时 检查 运行 时 补偿 　 　 中图法 分类号 　 TPANewRunTimePointerAliasingDisambiguationMethodTANGZhizhongQIAOLinZHANGChihongSUBogongDepartmentofComputerScienceandTechnology 　 TsinghuaUniversity 　 Beijing 　 DepartmentofComputerScience 　 WilliamPatersonUniversity 　 USA 　 　 Abstract 　 InthispaperanewruntimepointeraliasingdisambiguationmethodcalledSHRTDsoftwarehardwareruntimedisambiguationwhichcombineshardwareandsoftwaretechniquesispresentedDuringruntimetheSHRTDmethodletsfunctionunitsexecuteNOPstoimplementthepostponementoftheincorrectmemoryloadoperationanditssuccessiveoperationsToguaranteetheconsistencyoftheexecutionsequenceofallpostponedoperationstheorderoffunctionunitswhichexecutesNOPsandthenumberofNOPsmustbedeterminedduringcompilertimeTheSHRTDcanbeusedforirreversiblecodeandithasverylimitedcompensationcodespaceandnoseriousrerollabilityproblemTheSHRTDmethodsolvespointeraliasingproblemefficientlyandmakesitpossibletoobtainpotentialinstructionlevelparallelspeedup 　 　 Keywords 　 Instructionlevelparallelismverylonginstructionwordpointeraliasingruntimecheckingruntimecompensation 　 　 当前 的 超长 指令 字 （ verylonginstructionword 简称 VLIW ） 编译器 都 采用 静态 代码 调度 和 软件 流水 的 方法 开发 程序 的 指令 级 并行性 （ instructionlevelparallelism 简称 ILP ） ［ ］ 这 两种 方法 最大 的 局限 是 存在 内存 访问 的 歧义 相关性 （ ambiguousdependence ） 因而 即使 编译器 能够 处理 数组 静态 别名 分析 也 不 能够 很 好 地 处理 指针 别名 （ pointeraliasing ） 分析 为了 解决 指针 别名 问题 以 获得 更 高 的 潜在 指令 级 并行处理 加速 文献 ［ ］ 提出 了 两种 运行 时 消除 歧义 性 （ runtimedisambiguation 简称 RTD ） 的 方法 ： 运行 时 检查 （ runtimecheck ） 方法 和 运行 时 补偿 （ runtimecompensation ） 方法 将 这 两种 方法 应用 于 软件 流水 时 运行 时 补偿 方法 虽然 允许 不 确定 的 内存 访问 但 它 只 适合 那些 可逆 代码 ［ ］ 运行 时 检查 方法 虽然 适用 于 任何 代码 但 存在 代码 可重 入性 （ rerollability ） 问题 这 两种 方法 共同 的 缺陷 是 存在 严重 的 代码 空间 问题 尤其 是 在 全局 软件 流水 中 可能 导致 巨大 的 补偿 代码 空间 开销 　 　 本文 提出 一种 新 的 基于 软硬件 结合 的 运行 时 检查 方法 SHRTDSHRTD 的 基本 思想 是 ： （ ） 为 延迟 运行 时 不 正确 的 内存 访问 及其 后继 操作 功能 单元 执行 NOP 操作 而 不是 执行 补偿 代码 ； （ ） 为 保证 所有 延迟 操作 执行 顺序 的 一致性 编译 时 就 确定 执行 NOP 操作 的 所有 功能 单元 的 顺序 和 NOP 操作 的 数目 SHRTD 硬件 基本 结构 　 　 一个 完整 的 指令 级 并行 计算机 加速 系统 主要 由 三 大部分 组成 ： 主机 、 采用 超标 量 体系结构 的 单 处理机 和 采用 VLIW 体系结构 的 个 处理单元 （ PE ） 串联 的 多处理机 图是 一个 简化 的 PE 体系结构 和 SHRTD 硬件 支持 环境 该 体系结构 包含 个 功能 单元 ： 个 ALU 、 个 乘法器 、 个 内存 访问 端口 和 个 分支 和 循环 控制 单元 （ BRLC ） 该 VLIW 处理器 能够 在 个 时钟 周期 中 处理 个 整数 操作 、 个 内存 访问 操作 和 个 分支 操作 SHRTD 的 硬件 支持 环境 在 指令 存储器 上 添加 了 一个 存储 延迟 操作 的 指令 缓冲区 、 一个 从 指令 缓冲区 或 正常 的 指令 存储器 选择 操作 的 多路 选择器 集合 和 一个 带有 SHRTDWORD 只 读存储器 的 控制指令 缓冲区 图 　 单个 PE 的 体系结构 　 相关 定义 与 定理 　 　 本文 假设 ： 所有 的 操作 都 只 占用 个 时钟 周期 ； 所有 的 PE 共享 一个 单一 的 内存 片 ； 且 每个 PE 只有 一个 内存 读 、 内存 写 和 BRLC 单元 每个 BRLC 单元 可以 同时 处理 个 分支 操作 　 　 定义 操作 距离 设 op 和 op 是 程序 中 的 两个 操作 则 它们 之间 间隔 的 操作 数目 加 称为 这 两个 操作 的 操作 距离 记为 disopop 　 　 定义 安放 距离 设 op 和 op 是 程序 中 已 安放 的 两个 操作 且 在 原始 串行 代码 中 操作 op 在 操作 op 之前 若 安放 后 它们 之间 间隔 的 VLIW 操作 数目 为 N 则 这 两个 操作 的 安放 距离 　 　 　 　 　 　 　 　 　 定义 （ 代码 补偿 量 ） 设 op 和 op 分别 是 程序 中 两个 已 安放 的 歧义 STORE 和 LOAD 操作 且 它们 的 安放 距离 dopop ＜ 当 检测 到 地址 冲突 时 ， 必须 补偿 一些 空 操作 以 延迟 不 正确 的 LOAD 及其 后继 操作 我们 称 这些 补偿 的 空 操作 数目 为 代码 补偿 量 （ codecompensationmeasure ） 　 　 显然 若 op 和 op 安放 在 不同 的 内存 端口 则 相应 的 代码 补偿 量 Ω dopop 　 　 定义 （ 体内 安放 距离 和 体间 安放 距离 ） 对 任意 一个 迭代 次数 为 n 的 循环 中 的 操作 op 和 op 设 opk 和 opj 分别 表示 op 和 op 的 第 k 次 和 第 j 次 迭代 ≤ j ≤ n ≤ k ≤ n 如果 j ≠ k 称 安放 距离 dopkopj 为 体间 安放 距离 ； 如果 jk 称 安放 距离 dopkopj 为 体内 安放 距离 考虑 到 操作 op 和 op 在 循环体 不同 迭代 的 体内 安放 距离 是 相同 的 故 可 将 体内 安放 距离 简记 为 dinnopop 　 　 循环 程序 的 软件 流水 算法 必须 在 循环 调度 前 确定 循环 的 体间 启动 间距 II 即 相邻 两次 循环 迭代 的 第个 操作 之间 的 体间 安放 距离 一旦 确定 了 循环体 间 启动 间距 II 则 有 如下 定理 　 　 定理 给定 循环 的 体间 启动 间距 II 设 opk 和 opj 分别 是 循环 程序 中 两个 已 安放 的 歧义 LOAD 和 STORE 操作 且 它们 的 体内 安放 距离 为 dinnopop 体间 安放 距离 dopkopjjk 若 opk 和 opj 安放 在 不同 的 内存 端口 则 一次 迭代 需要 插入 的 SHRTD 操作 个数 p 　 　 证明 ： 因为 并行程序 每隔 II 启动 一次 循环 迭代 则 在 操作 opj 和 opj 之间 共 启动 了 次 循环 迭代 注意 到 不 在 这 段时间 内 启动 的 循环 迭代 并 不 存在 歧义 相关性 从而 只 需要 在 这些 循环 迭代 所属 的 操作 opk 之前 插入 相应 的 SHRTD 操作 以 判断 操作 opk 和 opj （ j ≤ k ≤ j 是否 存在 歧义 相关性 即可 p 即为 一次 迭代 需要 插入 的 SHRTD 数目 　 　 □ 　 　 定理 给定 循环 的 体间 启动 间距 II 设 opk 和 opj 分别 是 循环 程序 中 两个 已 安放 的 歧义 LOAD 和 STORE 操作 当 SHRTD 检测 到 地址 冲突 时 相应 的 代码 补偿 量 　 　 　 　 　 　 　 　 Ω ｜ dopkopj ｜ dinnopopkj × II 　 　 证明 ： 因为 对 存在 歧义 相关性 的 任意 操作 opk 和 opj Ω ｜ dopkopj ｜ 为 其 代码 补偿 量设 操作 opj 的 启动 周期 为 t 则 操作 opj 的 启动 周期 为 tdinnopop 操作 opk 的 启动 周期 为 tkj × II 故 操作 opk 和 opj 的 体间 安放 距离 　 　 　 　 dopkopjtkj × IItdinnopopkj × IIdinnopop 　 　 既然 opk 在 opj 之前 启动 上述 结果 显然 是 负值 当 SHRTD 检测 到 歧义 相关性 时 opk 已经 超前 执行 了 kj × IIdinnopop 个 时钟 周期 并 读取 了 opj 执行 前 的 数据 为 保证 程序 的 正确 执行 必须 在 opk 之前 插入 ｜ kj × IIdinnopop ｜ 个 补偿 空 操作 从而 有 相应 的 代码 补偿 量 Ω ｜ dopkopj ｜ dinnopopkj × II 　 　 □ 　 SHRTD 基本原理 　 　 表和表 说明 了 如何 在 软件 流水过程 中 使用 SHRTD 原始 的 程序代码 如图所示 插入 RTD 代码 之后 的 程序 如图所示 表是 无地址 冲突 的 软件 流水 结果 操作 号 和 指针 别名 后加 括号 的 上标 编号 表示 该 操作 属于 哪次 迭 代表 　 循环 程序 实例 ： 无地址 冲突 时 的 软件 流水 结果 CLKALUALUMULMULMEMMEMBRLCBRLCBRLC 　 　 op 　 　 　 　 　 　 　 　 op 　 op 　 　 　 SHRTDopopop 　 op 　 op 　 　 SHRTDopopSHRTDopopopopop 　 op 　 SHRTDopopSHRTDopopSHRTDopopopopop 　 opopSHRTDopopSHRTDopopSHRTDopopopopopopopopSHRTDopopSHRTDopopSHRTDopopopopopopopopSHRTDopopSHRTDopopSHRTDopopopopopopopopSHRTDopopSHRTDopopSHRTDopopopopopopopopSHRTDopopSHRTDopopSHRTDopop … … … … … … … … … … 表 　 循环 程序 实例 ： SHRTDopop 检测 到 op 和 op 地址 冲突 CLKALUALUMULMULMEMMEMBRLCBRLCBRLCopopopopopopSHRTDopopSHRTDopopSHRTDopopopopNOPopNOPopSHRTDopopSHRTDopopSHRTDopopNOPopNOPopNOPopSHRTDopopSHRTDopopSHRTDopopNOPNOPopNOPopNOP 　 NOP 　 NOP 　 NOPopNOPopNOPopNOP 　 NOP 　 NOP 　 NOPopopopopopopSHRTDopopSHRTDopopSHRTDopop … … … … … … … 　 … 　 … 　 … 　 　 　 　 　 　 　 图 　 原始 循环体 代码 　 　 　 图 　 插入 SHRTD 后 的 代码 　 　 从 时钟 周期 到 时钟 周期 是 循环 的 装入 阶段 ； 时钟 周期 之后 是 循环 的 流水 阶段 在 循环 的 流水 阶段 每条 VLIW 指令 其实 执行 的 是 相邻 次 循环 迭代 的 语句 其中 各 语句 分 属于 不同 的 循环 迭代 即 一次 循环 迭代 只 需要 一个 时钟 周期 当 循环 次数 远远 大于 循环 体内 的 操作 时 循环 装入 和 排空 过程 可以 忽略不计 从而 在 无地址 冲突 时 程序 的 并行 加速 比约 为 　 　 因为 循环 程序 的 体间 启动 间距 IIdinnopop 从而 需要 插入 的 SHRTD 操作 个数 p 这些 SHRTD 操作 将 分别 判断 紧接着 的 LOAD 操作 是否 与 前次 迭代 的 STORE 操作 存在 循环体 间 内存地址 冲突 的 问题 即 是否 存在 体差 为 或 的 体间 相关 当 SHRTDopop 检测 到 op 和 op 地址 冲突 时 （ 时钟 周期 为 ） 必须 添加 一些 补偿 空 操作 相应 的 代码 补偿 量 Ω dinnopopkj × II 　 　 此时 操作 op 和 op 的 循环体 差为 op 必须 在 op 之后 完成 如表 所示 因为 这 两个 操作 的 体间 安放 距离 dopop 所以 功能 单元 必须 插入 两个 NOP 操作 这些 NOP 操作 延迟 了 第次 迭代 中有 歧义 的 LOAD 操作 及其 后继 操作 的 执行 这里 存在 两个 时钟 周期 的 延迟 执行 顺序 在 时钟 周期 返回 到 正常 状态 整个 过程 不 存在 任何 代码 可重 入性 的 问题 　 SHRTD 的 并行 加速 比 分析 　 　 定理 设 循环 程序 的 体间 启动 间距 为 II 循环 的 串行 代码 总长度 为 l 循环 次数 为 n ， 设 op 和 op 分别 是 循环 程序 中 两个 已 安放 的 歧义 LOAD 和 STORE 操作 且 体间 安放 距离 dinnopopd 则 某次 发生 j 次体 差为 j 次体 差为 j 次体 差为 的 地址 冲突 后 的 并行程序 加速 比 发生 m 次 地址 冲突 后 的 算术平均 并行 加速 比 　 　 证明 ： 由 定理 知 发生 体差 为 x 的 地址 冲突 时 的 代码 补偿 量 Ω xdx ≤ x ≤ d 则 在 某次 发生 j 次体 差为 j 次体 差为 j 次体 差为 的 地址 冲突 后 总 的 代码 补偿 量 Ω jjj 　 　 串行 执行 该 程序 时 总 的 时钟 周期 为 n 并行执行 时 装入 和 排空 阶段 分别 需要 个 时钟 周期 在 没有 检测 到 地址 冲突 时 流水 阶段 需要 n 个 时钟 周期 由于 在 运行 时 检测 到 地址 冲突 则 总 的 并行执行 周期 为 n × jjjnjjj 从而 此时 程序 的 并行程序 加速 比 在 一次 迭代 的 过程 中 发生 一次 地址 冲突 后 的 算术平均 代码 补偿 量 从而 发生 m 次 地址 冲突 后 的 算术平均 并行 加速 比 　 　 □ 　 　 当 jjj 时 不 存在 任何 地址 冲突 加速 比当 n → ∞ 时 的 极限 S ； 当 jnjj 时 全部 地址 冲突 体差 都 为 S ； 当 jjnj 时 全部 地址 冲突 体差 都 为 S ； 当 jjjn 时 全部 地址 冲突 的 体差 都 为 S 考虑 到 程序 本身 的 特殊性 — — 循环 体内 的 所有 操作 都 是 不可 并行 的 获得 这样 的 加速 比 还是 令人满意 的 　 　 使用 同样 的 方法 可以 分析 检测 到 其他 地址 冲突 时 的 指令 级 并行 流水 结果 结论 　 　 上面 的 例子 表明 SHRTD 方法 有效 地 解决 了 指针 别名 问题 并 获得 了 与 使用 软件 实现 的 运行 时 补偿 方法 同样 的 效果 SHRTD 方法 可以 与 诸如 内存 缓冲区 等 硬件 支持 联合 工作 以 加快 地址 比较 的 速度 　 　 SHRTD 方法 具有 下述 个 优势 ： 因为 运行 时 检查 方法 没有 代码 重做 问题 所以 它 特别 适合 任何 不 可逆 代码 ； 因为 任何 SHRTD 只 需要 一个 SHRTD 控制指令 补偿 代码 的 代码 空间 并不大 ； 不 存在 代码 可重 入性 问题 　 　 SHRTD 方法 需要 下述 的 特别 硬件 支持 ： 一个 大小 为 D × W 的 指令 缓冲区 W 是 VLIW 指令 的 宽度 D 等于 dmax 这里 dmax 是 大多数 流行 程序 中 的 最大值 ； 一个 多路 选择器 MUXMUX 的 数目 等于 VLIW 指令 字 的 操作 域 数目 ； SHRTD 控制指令 缓冲区 和 SHRTDWORD 寄存器 　 　 将来 的 研究 将 着重 考虑 如何 处理 嵌套循环 和 在 流水 安全法 ［ ］ 中 使用 SHRTD 方法 　 　 本文 研究 得到 国家自然科学基金 资助 作者 汤志忠 年生 教授 博士生 导师 主要 研究 领域 为 计算机 并行 体系结构 并行算法 并行 编译 技术 乔林 年生 博士生 主要 研究 领域 为 计算机 并行 编译 技术 Petri 网 并行程序 的 形式 语义 张 赤红 年生 副教授 主要 研究 领域 为 计算机 并行算法 并行 编译 技术 苏伯珙 年生 教授 主要 研究 领域 为 软件 流水 算法 并行 编译 技术 　 　 本文 通讯联系 人 汤志忠 北京 清华大学 计算机科学 与 技术 系 　 　 作者 单位 ： 汤志忠 　 乔林 　 张 赤红 清华大学 计算机科学 与 技术 系 北京 ； 苏伯珙 WilliamPaterson 大学 计算机科学 系 　 美国 参考文献 　 　 RauBRFisherAInstructionlevelparallelprocessinghistoryoverviewandperspectiveTheJournalofSupercomputing ～ 　 　 NicolauARunTimedisambiguationcopingwithstaticallyunpredictabledependenciesIEEETransactionsonComputers ～ 　 　 汤志忠张 赤红 乔林 流水 安全法 — — 一个 面向 软件 流水 技术 的 新 的 数据 相关性 分析方法 计算机 学报 增刊 ～ TangZhizhongZhangChihongQiaoLinPipeliningsafemethod — — anewwaytosupportdatadependenceanalysisforsoftwarepipeliningChineseJournalofComputerssupplement ～ 收到 原稿 收到 修改稿
计算机 研究 与 发展 JOURNALOFCOMPUTERRESEARCHANDDEVELOPMENT 年 第卷 第期 VolNo 开放 的 异种 对象 标识 及 绑定 机制 研究 兑继英 　 沈卓炜 　 顾 冠群 摘 　 要 　 随着 各种 分布 对象 计算 系统 的 广泛 使用 ， 异构 对象 系统 之间 的 互操作 已 成为 必要 其中 ， COMCORBA 互操作 是 最为 迫切 的 ， 很多 CORBA 产品 遵照 OMG 组织 的 COMCORBA 互操作 规范 提供 了 互操作 功能 然而 规范 中 异种 对象 的 标识 及 绑定 机制 存在 问题 ， 影响 了 应用程序 的 可移植性 和 互 操作系统 之间 的 互操作性 文中 将 互操作 中 异种 对象 的 标识 和 绑定 机制 形式化 地 描述 为 异种 对象 标识 空间 的 映射 ， 在 此基础 上 归纳 出种 对象 标识 方法 和 相应 的 绑定 语义 ， 并 提出 一种 开放 的 对象 标识 机制 以 提高 应用 的 移植性 和 互 操作系统 之间 的 互操作性 关键词 　 分布 对象 计算 ， COM ， CORBA ， 互操作 ， 对象 标识 ， 对象 绑定 中图法 分类号 　 TPRESEARCHONANOPENFOREIGNOBJECTIDENTIFYINGANDBINDINGMECHANISMDUIJiYingSHENZhuoWeiandGUGuanQunDepartmentofComputerScienceandEngineeringSoutheastUniversityNanjingAbstract 　 WiththewideapplicationofdifferentdistributedobjectcomputingsystemsinterworkingbetweenheterogeneoussystemsbecomesnecessarySinceinterworkingbetweenCOMandCORBAismosturgentmanyCORBAproductsprovideinterworkingcapabilitiesaccordingtotheOMGsCOMCORBAinterworkingspecificationHoweverthespecificationhassomelimitationsontheobjectidentifyingandbindingmechanismandtheselimitationsmakeitdifficulttoprovideportabilityofapplicationsandinteroperabilityofinterworkingsystemsInthispaperforeignobjectidentifyingandbindingmechanismisformalizedasmappingbetweenforeignobjectidentifiersBasedonthisformalizationthreemethodsforobjectidentifyingandbindingareconcludedAndthenanopenobjectidentifyingandbindingmechanismisproposedtoachieveportabilityandinteroperabilityKeywords 　 distributedobjectcomputingCOMCORBAinterworkingobjectidentifyingobjectbinding 　 引 　 　 言 　 　 各种 分布 对象 计算 系统 的 广泛 使用 使得 异构 对象 系统 之间 的 互操作 成为 必要 OMG 组织 的 CORBA 和 Microsoft 公司 的 COMDCOM 是 当前 分布 对象 模型 中 的 两大 主流 ， 很多 分布式应用 同时 采用 了 COM 和 CORBA ［ ］ ， 用户 迫切需要 COM 和 CORBA 的 互操作 以 开发 和 集成系统 ， 因此 目前 绝大多数 CORBA 产品 都 提供 了 COMCORBA 互操作 的 功能 　 　 OMG 的 CORBA 规范 及其 后续 版本 中 都 制订 了 COMCORBA 互操作 规范 ， 其 目的 在于 制定 COM 和 CORBA 对象 之间 的 通信 机制 ［ ］ ， 用于 保证 基于 规范 开发 的 互操作 产品 之间 的 互操作性 和 用户 应用程序 的 可移植性 但是 规范 中 的 异种 对象 标识 （ identifier ） 和 绑定 （ binding ） 机制 存在 缺陷 ， 这样 不同 的 互操作 产品 很 可能 使用 不同 的 对象 标识 和 绑定 机制 例如 ， 当 COM 客户 使用 CORBA 对象 时 ， IONA 公司 的 OrbixActiveX 使用 COM 视图 对象 所在 代理 的 名字 、 接口 的 名字 和 CORBA 对象 的 标识 来 指定 所 要 使用 的 CORBA 对象 ［ ］ ， 而 HP 的 ORBplusCORBAConnect 则 使用 CORBA 对象 的 名字 来 指定 所 要 使用 的 CORBA 对象 ［ ］ 即使 两种 产品 都 使用 CORBA 对象 名来 指定 所 要 使用 的 CORBA 对象 ， 也 无法 保证 其 格式 的 一致性 ： HP 的 ORBplusCORBAConnect 直接 将 CORBA 对象 的 名字 作为 参数 ， 而 Orbix 的 COMet 则 使用 接口 的 名字 和 CORBA 对象 的 名字 来 指定 CORBA 对象 ［ ］ 　 　 显然 ， 对象 标识 和 绑定 机制 的 差异 妨碍 了 互操作 应用程序 的 可移植性 和 互 操作系统 之间 的 互操作性 此外 ， 规范 中 CORBA 客户 和 COM 对象 的 绑定 机制 无法 以 通用 映射 方式 实现 针对 这些 问题 ， 文中 对 COMCORBA 互操作 中 的 对象 标识 和 绑定 机制 进行 了 形式化 描述 ， 归纳 出种 对象 标识 和 绑定 方法 ， 在 此基础 上 提出 一种 开放 的 标识 和 绑定 机制 ， 并 对 其 实现 进行 了 可行性 论证 　 COMCORBA 互操作 中 的 对象 标识 和 绑定 问题 　 　 在 COMCORBA 互操作 模型 中 ， 客户 通过 视图 对 异种 对象 进行 访问 ， 由桥 负责 两种 系统 之间 的 转换 工作 ［ ］ ， 如图所示 图 　 互操作 模型 　 　 客户 在 使用 异种 对象 之前 需要 以 某种 方式 指明 所 要 使用 的 异种 对象 ， 该 问题 称为 对象 标识 之后 ， 系统 根据 客户 指定 的 对象 标识 定位 异种 对象 ， 创建 相应 的 视图 对象 ， 将 视图 对象 和 异种 对象 联系 起来 并 将 视图 对象 的 引用 返回 给 客户 ， 该 问题 称为 对象 绑定 此后 ， 客户 通过 访问 视图 对象 实现 对 异种 对象 的 访问 　 　 ① 在 对象 标识 和 绑定 方面 ， Automation 和 CORBA 之间 的 映射 与 COM 和 CORBA 之间 的 映射 基本相同 ， 因此 本文 只 讨论 COM 和 CORBA 的 映射 ， 结果 同样 适用 于 Automation 和 CORBA 之间 的 映射 　 CORBA 对象 的 标识 和 绑定 ① 　 　 规范 中 COM 客户 通过 互 操作系统 提供 的 ICORBAFactory 类 工厂 来 绑定 CORBA 对象 ICORBAFactory 类 工厂 为 COM 对象 ， 代表 了 系统 中 所有 的 CORBA 对象 ， 其 接口定义 如图所示 图 　 ICORBAFactory 接口 　 　 CreateObject 的 行为 包括 ： 　 　 创建 COM 视图 对象 ； 　 　 创建 CORBA 对象 并 将 其 绑定 到 COM 视图 方法 中 的 factoryName 参数 标识 了 所要 创建 的 CORBA 对象 的 类型 规范 没有 规定 factoryName 参数 的 具体 语义 ， 例如 ， 该 参数 可以 用来 表示 CORBA 对象 类 工厂 的 名字 ， 也 可以 用来 表示 COM 视图 对象 的 ProgID ； 　 　 将 COM 视图 的 引用 返回 给 客户 ； 　 　 GetObject 的 行为 包括 ： ① 将 方法 中 的 objectName 映射 为 CORBA 的 对象 引用 规范 中 没有 指定 objectName 映射 到 CORBA 的 对象 引用 的 映射 规则 ， 例如 ， 该 参数 可以 用来 表示 CORBA 对象 的 名字 ， 也 可以 用来 表示 已经 创建 了 的 COM 视图 的 名字 ； ② 将 CORBA 对象 引用 绑定 到 已有 的 视图 对象 ， 将 视图 对象 的 引用 返回 给 客户 　 COM 对象 的 标识 和 绑定 　 　 CORBA 客户 使用 互 操作系统 实现 的 SimpleFactory 类 工厂 来 绑定 COM 对象 SimpleFactory 类 工厂 是 一个 实现 了 SimpleFactory 接口 的 CORBA 对象 ， 每个 COM 对象 的 类 工厂 映射 为 一个 单独 的 SimpleFactory 类 工厂 SimpleFactory 接口 的 定义 如图所示 图 　 SimpleFactory 接口 　 　 规范 中 没有 规定 如何 将 CORBASimpleFactory 类 工厂 提供 给 CORBA 用户 使用 另外 ， 规范 也 没有 将 实现 CORBASimpleFactory 类 工厂 作为 互操作 规范 的 遵从 点 （ compliancepoint ） 　 存在 问题 　 　 从 以上 分析 可以 看出 ， 规范 中 的 对象 标识 和 绑定 机制 存在 以下 问题 ： 　 　 规范 没有 定义 对象 标识 所 代表 的 语义 ， 因此 应用程序 中 的 对象 标识 在 不同 的 互操作 产品 中 可能 会作 不同 的 解释 ， 从而 导致 应用程序 无法 在 不同 的 互操作 产品 上 移植 ； 　 　 由于 规范 没有 定义 对象 标识 所 代表 的 语义 ， 因此 无法 针对 不同 的 语义 定义 对象 标识 的 格式 ， 即使 不同 的 互操作 产品 采用 同样 的 标识 和 绑定 方法 ， 也 会 由于 标识 格式 的 不同 而 影响 应用 移植 ； 　 　 规范 中 列举 了 两种 可能 的 互操作 实现 方式 ： 通用 映射 和 特定 于 接口 的 映射 ［ ］ 通用 映射 方式 下 视图 对象 可以 根据 客户 使用 的 异种 对象 动态 生成 ， 而 CORBA 视图 到 COM 对象 的 绑定 机制 没有 提供 类似 ICORBAFactory 的 接口 来 动态 地 创建 COM 对象 ， 而且 无法 绑定 已有 的 COM 对象 ； 　 　 一个 互 操作系统 有 可能 需要 在 另 一个 互 操作系统 上 创建 视图 对象 ， 以上 问题 影响 了 互 操作系统 之间 的 互操作性 　 互操作 中 异种 对象 标识 和 绑定 机制 的 形式化 描述 　 　 从 规范 中 的 互操作 模型 可以 看出 ， 互 操作系统 需要 根据 用户 指定 的 对象 标识 来 确定 视图 对象 和 异种 对象 设互 操作系统 提供 给 用户 使用 的 对象 标识 空间 为 Nc ， 视图 对象 的 标识 空间 为 Nv ， 异种 对象 的 标识 空间 为 Ns ， 则 互操作 的 对象 标识 和 绑定 机制 可以 形式化 地 描述 为 函数 fNcNv 和 gNcNs ， 其中 函数 f 的 作用 为 根据 用户 指定 的 对象 标识 来 确定 视图 对象 ， 函数 g 的 作用 为 根据 用户 指定 的 对象 标识 来 确定 异种 对象 ， 如图所示 图 　 互操作 中 的 对象 标识 和 绑定 机制 　 　 Nc 可以 由 Nv 和 或 Ns 组成 定义 函数 h 为 Nc 的 构成 方式 ， 则 h 有种 （ CC ） 形式 ： hNv → NchNs → Nc 或 hNv × Ns → Nc 其中 ， h 表示 用户 在 绑定 异种 对象 时 将 视图 对象 的 标识 作为 参数 ， 通过 视图 对象 隐含地 指定 所 要 使用 的 异种 对象 ， 称 这种 标识 及 绑定 方式 为 间接 方式 ； h 表示 用户 在 绑定 异种 对象 时 将 异种 对象 的 标识 作为 参数 ， 隐含地 指定 所 要 使用 的 视图 对象 ， 称 这种 方式 为 直接 方式 ； h 表示 用户 在 绑定 异种 对象 时 参数 既 包括 视图 对象 的 标识 又 包括 异种 对象 的 标识 ， 称 这种 方式 为 混合 方式 　 　 在 间接 方式 中 ， 互 操作系统 先 确定 视图 对象 ， 再 根据 视图 对象 确定 异种 对象 ， 即 gxg ′ fx 其中 函数 g ′ 为 Nv 到 Ns 的 映射 ， 如图所示 ； 在 直接 方式 中 ， 互 操作系统 先 确定 异种 对象 ， 再 根据 异种 对象 确定 视图 对象 ， 即 fxf ′ gx 其中 f ′ x 为 Ns 到 Nv 的 映射 ， 如图所示 ； 在 混合 方式 中 ， 客户 指定 的 标识 中 既 包括 视图 对象 的 标识 又 包括 异种 对象 的 标识 ， 因此 视图 对象 和 异种 对象 的 标识 可以 直接 从 客户 标识 中 得到 ， 如图所示 图 　 间接 方式 的 对象 标识 和 绑定 机制 图 　 直接 方式 的 对象 标识 和 绑定 机制 　 开放 的 异种 对象 标识 机制 　 　 在 COM 和 CORBA 中 ， 用户 可以 采用 各种 方式 标识 对象 ， 因此 Nc 中 的 对象 标识 需要 带有 所 使用 的 对象 所在 系统 的 类型信息 ； 此外 ， 规范 中 的 ICORBAFactory 接口 采用 字符串 作为 对象 标识 的 类型 ， 因此 使用 串化 的 对象 标识 来 组成 Nc 开放 的 对象 标识 包括 了 上述 种 Nc 的 构成 方法 ， 这种 标识 方式 简称 为 OOID （ openobjectidentifier ） 下面 是 Nc 的 构成 文法 ： 　 　 〈 OOID 〉 ∷ 〈 COM 对象 标识 〉 〈 CORBA 对象 标识 〉 　 　 〈 COM 对象 标识 〉 “ ” 〈 CORBA 对象 标识 〉 　 　 〈 COM 对象 标识 〉 ∷ 〈 COM 对象 标识 类型 〉 “ ” 〈 串化 的 COM 对象 标识 〉 　 　 〈 CORBA 对象 标识 〉 ∷ 〈 CORBA 对象 标识 类型 〉 “ ” 〈 串化 的 CORBA 对象 标识 〉 　 　 （ ） COM 对象 标识 　 　 COM 中 的 对象 通过 其 CLSID 或 对应 的 ProgID 来 标识 ［ ］ 其中 CLSID 是 一个 位 的 整数 ， 可以 按照 COM 中 UuidToString 和 UuidFromString 函数 的 转换 格式 将 其 串化 和 反串 化 ProgID 是 一个 以 “ ” 分隔 开来 的 字符串 ， 可以 直接 用作 串化 的 COM 对象 标识 因此 COM 对象 有 两种 OOID ： 　 　 ① “ CLSID ： ” 〈 串化 的 CLSID 〉 ， 表示 通过 COM 对象 的 CLSID 标识 COM 对象 ； 　 　 ② “ ProgID ： ” 〈 ProgID 〉 ， 表示 通过 COM 对象 的 ProgID 标识 COM 对象 　 　 （ ） CORBA 对象 标识 　 　 CORBA 中 的 对象 通过 可以 通过 以下 几种 方式 获得 对象 的 引用 ： 将 串化 的 IOR 反串 化 ［ ］ ； 使用 CORBA 的 名录 服务 （ namingservice ） ， 通过 对象 的 名字 查找 对象 的 引用 ［ ］ ； 使用 CORBA 的 交易 服务 （ tradingservice ） ， 通过 一组 服务 对象 的 属性 来 查找 对象 ［ ］ ； 使用 类 工厂 创建对象 ［ ］ 　 　 其中 ， CORBA 交易 服务 中 对象 的 属性 可以 是 各种类型 的 数据 ， 串化 和 反串 化 的 代价 很 高 ， 而且 得到 的 对象 引用 可能 不止 一个 ， 因此 不 适合 使用 OOID 标识 替代 的 办法 是 将 CORBA 的 交易 服务 映射 为 COM 的 交易 服务 ， COM 客户 可以 使用 映射 后 的 交易 服务 得到 串化 的 对象 的 IOR ， 再 将 串化 的 IOR 转换 为 OOID 来 使用 另外 ， CORBA 中 的 类 工厂 也 是 CORBA 对象 ， 因此 CORBA 类 工厂 的 标识 和 CORBA 对象 的 标识 相同 ， 但 需要 在 前面 加 “ Factory 〖 KG 〗 　 ” 前缀 ， 表明 它 是 一个 类 工厂 ， 用户 希望 得到 的 是 通过 该类 工厂 创建 的 CORBA 对象 需要 指出 的 是 ， 如果 通过 类 工厂 创建 的 对象 仍然 是 一个 类 工厂 对象 ， 此时 系统 直接 返回 该类 工厂 对象 （ 或 它 的 视图 ） 而 不再 做 进一步 的 创建 工作 ， 因为 客户 有 可能 确实 需要 得到 该类 工厂 或 其 COM 视图 因此 针对 CORBA 对象 有种 OOID ： 　 　 ① “ IOR ： ” 〈 串化 的 IOR 〉 ， 表示 通过 IOR 标识 CORBA 对象 ； 　 　 ② “ NS ： ” 〈 串化 的 对象 名 〉 ， 表示 通过 CORBA 名录 服务 中 CORBA 对象 的 名字 标识 CORBA 对象 其中 对象 名 可以 串 化为 以下 格式 ： 〈 id 〉 〈 kind 〉 〈 id 〉 〈 kind 〉 … 〈 idn 〉 〈 kindn 〉 ， 这里 对象 名 包括 n 个 对象 名 组件 （ namecomponent ） ； 　 　 ③ “ FactoryIOR ： ” 〈 串化 的 IOR 〉 ， 表示 通过 CORBA 类 工厂 创建 CORBA 对象 ， 其中 IOR 是 CORBA 类 工厂 对象 的 IOR ； 　 　 ④ “ FactoryNS ： ” 〈 串化 的 对象 名 〉 ， 表示 通过 CORBA 类 工厂 创建 CORBA 对象 ， 其中 对象 名是 CORBA 类 工厂 对象 的 对象 名 　 开放 的 异种 对象 绑定 机制 及其 实现 方法 　 　 规范 中 列举 了 两种 互操作 实现 方式 ： 通用 映射 和 特定 于 接口 的 映射 ［ ］ （ 以下 简称 为 通用 方式 和 特定 方式 ） ， 当前 COMCORBA 互操作 产品 也 分为 这样 两大类 ［ ］ 在 通用 方式 中 ， 所有 接口 都 由 一组 固定 的 互操作 组件 动态 地 进行 映射 并 生成 视图 对象 当 目标 系统 中 注册 了 新 的 接口 和 对象 时 ， 用户 可以 直接 去 访问 这些 新 的 对象 而 无需 针对 这些 接口 专门 生成 视图 对象 这种 方法 简化 了 配置管理 ， 但是 性能 较 低 在 特定 方式 中 ， 用户 在 访问 目标 对象 之前 需要 使用 互操作 编译器 对 目标 对象 的 接口 描述 文件 进行 编译 生成 代理 ， 之后 才 可以 通过 该 代理 创建 视图 对象 这种 方法 提高 了 性能 ， 但 用户 的 使用 和 视图 对象 的 管理工作 较为 复杂 　 　 以 通用 方式 实现 的 互 操作系统 大都 采用 直接 方式 标识 异种 对象 ， 例如 HP 的 ORBplus 以 特定 方式 实现 的 互 操作系统 大都 采用 混合 方式 标识 异种 对象 ， 例如 IONA 的 OrbixActiveX 为了 支持 用户 应用 的 移植 ， 互操作 应 支持 多种 标识 和 绑定 方式 以下 结合 这 两种 实现 方式 讨论 开放 的 对象 绑定 机制 及其 实现 方法 　 COM 客户 对 CORBA 对象 的 绑定 　 　 由于 OOID 是 字符串 ， 因此 不 需要 改变 ICORBAFactory 接口 ， 只 需 将 CreateObject 方法 和 GetObject 方法 中 的 factoryName 参数 和 GetObject 方法 中 的 objectName 参数 按照 OOID 进行 解释 　 　 直接 方式 　 　 如果 factoryName 或 objectName 是 CORBA 对象 标识 ， 那么 表示 客户 希望 通过 直接 方式 创建 或 绑定 CORBA 对象 系统 根据 OOID 中 指明 的 CORBA 对象 标识 创建 一个 新 的 CORBA 对象 （ 如果 OOID 标识 的 是 一个 CORBA 类 工厂 对象 ） 或 绑定 一个 已经 存在 的 CORBA 对象 （ 如果 OOID 标识 的 是 一个 CORBA 对象 实例 ） ， 并 根据 CORBA 对象 的 类型 创建 或 绑定 相应 的 COM 视图 对象 ， 将 CORBA 对象 绑定 到 COM 视图 对象 ， 最后 将 COM 视图 对象 引用 返回 给 客户 　 　 不论 通用 方式 还是 特定 方式 ， 互 操作系统 都 可以 根据 CORBA 对象 的 IDL 描述 来 确定 视图 对象 　 　 间接 方式 　 　 如果 factoryName 或 objectName 是 COM 对象 标识 ， 那么 表示 客户 希望 通过 间接 方式 创建 或 绑定 CORBA 对象 　 　 视图 是 根据 CORBA 对象 的 接口 描述 生成 的 ， 一个 视图 对象 可以 绑定 多个 同种 类型 的 CORBA 对象 ， 因此 需要 用户 通过 配置 来 指定 缺省 情况 下 视图 对象 所 对应 的 CORBA 对象 在 以 通用 方式 实现 的 互 操作系统 中 ， 可以 将 COM 视图 的 标识 作为 CORBA 对象 的 别名 使用 并 由 用户 事先 设置 ， 之后 系统 可以 根据 COM 视图 的 标识 查找 对应 的 CORBA 对象 标识 ， 并 根据 CORBA 对象 的 类型 生成 相应 的 视图 对象 ； 在 以 特定 方式 实现 的 互 操作系统 中 ， 一个 代理 可以 支持 多个 视图 对象 ， 系统 可以 直接 定义 视图 对象 的 标识 并 由 用户 定义 缺省 情况 下 视图 对象 所 要 绑定 的 CORBA 对象 　 　 混合 方式 　 　 如果 factoryName 或 objectName 是 COM 对象 标识 加 CORBA 对象 标识 ， 那么 表示 客户 希望 通过 混合 方式 创建 或 绑定 CORBA 对象 对于 以 通用 方式 实现 的 互 操作系统 ， 可以 只 使用 CORBA 对象 的 标识 ， 以 直接 方式 绑定 对象 ； 对于 以 特定 方式 实现 的 互 操作系统 ， 可以 根据 COM 对象 标识 确定 视图 对象 ， 根据 CORBA 对象 标识 来 确定 CORBA 对象 　 CORBA 客户 对 COM 对象 的 绑定 　 　 规范 中 没有 规定 用户 以 何种 方式 获得 SimpleFactory 类 工厂 由于 SimpleFactory 类 工厂 是 一个 CORBA 对象 ， 因此 可以 将 其 命名 并 登记 在 CORBA 的 名录 服务 中 ， 用户 通过 名录 服务 查找 得到 其 IOR ， 但是 这样 做 不利于 使用 通用 映射 方式 实现 COM 到 CORBA 的 互操作 ， 而且 SimpleFactory 类 工厂 没有 提供 绑定 已有 COM 对象 的 功能 这里 仿照 ICORBAFactory 定义 了 一个 COMFactory 接口 ， 用于 创建 和 绑定 包括 COM 对象 类 工厂 对象 在内 的 COM 对象 互 操作系统 可以 实现 一个 具有 该 接口 的 CORBA 对象 ， 并 给 它 指定 一个 周知 的 CORBA 名录 服务 中 的 名字 ， 例如 将 其 名字 的 id 设为 “ COMFACTORY ” ， kind 设为 NULLCOMFactory 对象 的 接口定义 如图所示 图 　 COMFactory 接口 　 　 其中 createfactory 方法 用于 创建 COM 类 工厂 ， getfactory 方法 用于 绑定 已有 的 COM 类 工厂 ； createobject 方法 用于 创建 COM 对象 ， getobject 方法 用于 绑定 已有 的 COM 对象 factoryName 和 objectName 分别 为 标识 COM 对象 类 工厂 和 COM 对象 的 OOID 具体 的 绑定 方法 与 前面 的 ICORBAFactory 类似 ， 这里 不再 赘述 　 结束语 　 　 开放 的 对象 标识 和 绑定 机制 的 基本 思想 是 将 对象 标识 的 类型 和 对象 标识 的 内容 捆绑 起来 标识 对象 ， 同时 针对 各种 OOID 定义 具体 的 绑定 语义 ， 从而 解决 了 对象 标识 及 绑定 所 带来 的 应用程序 的 移植性 问题 和 互 操作系统 之间 的 互操作 问题 从 OOID 的 定义 可以 知道 任何 可以 串化 的 对象 标识 都 可以 用 它 来 表示 ， 因此 具有 很 好 的 可扩充性 　 　 互操作 产品 可以 将 其 可以 支持 的 OOID 公布出来 ， 这样 用户 可以 据此 判断 其 应用 是否 可以 移植 到 其它 互操作 产品 上去 规范 也 可以 指定 一些 OOID 作为 对 规范 的 遵从 点 ， 从而 保证 用户 在 使用 这些 OOID 时 能够 在 所有 遵从 规范 的 互操作 产品 上 移植 此外 ， 文中 对象 标识 和 绑定 机制 的 形式化 是 针对 任意 两个 异构 分布 对象 计算 系统 的 互操作 进行 的 ， 开放 的 对象 标识 和 绑定 机制 也 可以 应用 到 其它 异构 分布 对象 计算 系统 的 互操作 中本 课题 得到 国家 “ 八 六三 ” 重大 攻关项目 （ 项目编号 ） 基金 资助 作者简介 ： 兑继英 ， 男 ， 年月生 ， 博士 研究生 ， 主要 研究 方向 为 计算机网络 、 电子邮件 及 　 　 　 　 　 分布式 处理 　 　 　 　 　 沈卓炜 ， 男 ， 年月生 ， 主要 研究 方向 为 计算机网络 和 分布式 处理 　 　 　 　 　 顾 冠群 ， 男 ， 年生 ， 中国工程院 院士 ， 教授 ， 博士生 导师 ， 主要 研究 方向 为 高性 　 　 　 　 　 能 计算机网络 、 网络协议 工程 、 CIMS 、 分布 对象 技术 作者 单位 ： 东南大学 计算机科学 与 工程系 　 南京 　 参考文献 　 　 JohnMontgomeryDistributedcomponentsBYTE ～ 　 　 ObjectManagementGroupTheCommonObjectRequestBrokerArchitectureandSpecificationRevision 　 　 IONATechnologiesOrbixActiveXIntegrationGuideIONATechnologiesLtd 　 　 MikeFoodyLetstalkBYTE ～ 　 　 IONATechnologiesOrbixCOMetDesktophttpwwwionacomorbixcometwhitepapercomethtml 　 　 MicrosoftCorporationandDigitalEquipmentCorporationTheComponentObjectModelSpecificationDraftVersion 　 　 ObjectManagementGroupCORBAServicesCommonObjectServicesSpecificationRevisedEdition 原稿 收到 日期 ： ； 修改稿 收到 日期 ：
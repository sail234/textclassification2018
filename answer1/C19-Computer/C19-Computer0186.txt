软件 学报 JOURNALOFSOFTWARE 　 Vol 　 No 　 P 基于 故障 敏感 图 的 回卷 算法 和 故障 恢复 柳颖 　 陈道 蓄 　 谢立 　 曹建 农摘 　 要 ： 扩充 的 面向 图 结构 的 分布式 程序设计 模型 extendedgraphorientedmodel 简称 ExGOM 提供 了 一个 支持 动态 配置 的 系统 框架 系统 的 动态 配置 包括 系统 运行 时 的 伸缩 、 运行 时 的 升级 以及 出现 故障 后 的 重 配置 故障 后 的 重 配置 所 涉及 的 问题 之一 是 如何 恢复 系统 原 状态 该文 着重 就此 问题 进行 了 讨论 给出 了 基于 故障 敏感 图 的 异步 检查点 回卷 算法 和 故障 恢复 策略 该 算法 和 策略 考虑 了 在 暂时性 主机 故障 中 单个 主机 上 有 多个 故障 进程 的 情况 与 其他 异步 回卷 及 故障 恢复 算法 相比 该 算法 将 故障 区域 局部 化仅 对 故障 敏感 节点 进行 回卷 从而 有效 地 降低 了 系统 开销 关键词 ： 分布式 程序设计 检查点 回卷 故障 恢复 分类号 ： TPRollbackAlgorithmandCrashRecoveryBasedonFaultSensitiveGraphsLIUYing 　 CHENDaoxu 　 XIELiStateKeyLaboratoryforNovelSoftwareTechnologyNanjingUniversityNanjingCAOJiannongDepartmentofComputingHongKongPolytechnicUniversityHongKongAbstract ： ExtendedgraphorienteddistributedprogrammingmodelExGOMprovidesasystemarchitecturetosupportdynamicconfigurationDynamicconfigurationinvolvessystemexpansionandshrinkduringexecutionupgradingwhilerunningandreconfigurationafterafaultoccursOneprobleminreconfigurationishowtorecoverthesystemtotheconsistentstatesthatexistjustbeforetheoccurrenceoffaultsThispaperisfocusedonthisproblemandproposesanasynchronousrollbackalgorithmandacrashrecoverymechanismbasedonfaultsensitivegraphsTheissueofmultiplefaultyprocessesonasingletransientfaultyhostisaddressedComparedwithotherasynchronousrollbackandrecoveryalgorithmsthealgorithmpresentedinthispaperlocalizestheregionoffaultsOnlyfaultsensitivenodesarerolledbackThisresultsinaminimizedsystemoverheadKeywords ： Distributedprogrammingcheckpointrollbackcrashrecovery ▲ 　 　 扩充 的 面向 图 结构 的 分布式 程序设计 模型 extendedgraphorientedmodel 简称 ExGOM 提供 了 一个 支持 动态 配置 的 系统 框架 它 支持 多种 动态 配置 包括 系统 运行 时 任务 图 的 伸缩 、 系统 运行 时 系统 模块 的 替换 与 升级 以及 系统 运行 过程 中 由于 若干 主机 结点 故障 或 其他 原因 如 负载 、 效率 等 所 导致 的 各 进程 的 重新 映射 对于 第种 情形 无论是 迁出 进程 还是 在 主机 正常 后 恢复 进程 运行 都 需要 适当 地 保存 进程 的 状态 用以 故障 恢复 这种 方法 也 被 称为 “ 检查点 ” 方法 目前 国内外 都 有 大量 关于 检查点 算法 的 研究 ［ ～ ］ 其中 大致 可 分为 同步 方法 与 异步 方法 两类 在 同步 方法 下 所有 进程 协调 其 检查点 动作 以 获得 一个 全局 一致 的 状态 在 异步 方法 下 每个 进程 各自 独立 地 进行 检查点 动作 故障 恢复 时 进程 需 协作 回卷 至 一个 全局 一致 状态 采用 消息传递 模型 的 分布式系统 各 进程 除 需 记下 进程 状态 外 还 需 记下 其 传递 的 消息 本文 给出 的 回卷 算法 和 故障 恢复 采用 异步 检查点 方式 系统 模型 　 　 为了 更好 地 说明 问题 本节 将 简要 介绍 回卷 和 故障 算法 运行 其上 的 ExGOM 模型 　 　 ExGOM 下 的 分布式应用 程序 由 部分 组成 ［ ］ ： 树型 逻辑 结构图 、 若干 应用程序 以及 从 应用程序 到 图 中 节点 再 到 主机 的 映射 关系 用户 在 该 模型 下 编写 分布式应用 程序 时 首先 定义 一个 树型 逻辑 结构图 该 逻辑图 结构 反映 了 该 应用 下 进程 间 的 初始 静态 关系 用户 也 可以 通过 虚拟 节点 或边 定义 潜在 的 进程 关系 实 节点 意味着 分配 其上 的 进程 一旦 启动 该 应用 即 被 生成 并 运行 ； 虚 节点 上 的 进程 则 由 其他 进程 动态创建 如果 一条 边 的 两个 端点 均 为实 节点 则 该 边 为 实边 否则 称为 虚边 可见 虚边 表明 了 一个 进程 与 一个 动态创建 的 进程 间 的 潜在 的 通信 关系 然后 用户 在 定义 的 图 结构 之上 利用 图上 提供 的 多种 操作 编写程序 逻辑图 结构 及 映射 关系 都 在 该 应用 的 配置文件 中 定义 当 执行 一个 ExGOM 应用 时 运行 系统 读取 配置 信息 构造 动态 执行 图 DEGdynamicexecutiongraph 根据 映射 关系 创建 各 进程 并 启动 运行 此后 由 运行 系统 负责 维护 动态 执行 图 　 　 每个 主机 有 一个 运行 系统 的 核 kernel 每个 核都 维护 着 一个 DEG 正常 情况 下 各 DEG 是 一致 的 运行 系统 的 核 结构 如图所示 其中 SLGstaticlogicalgraph 是 用户 定义 的 初始 逻辑图 结构 FSGfaultsensitivegraph 是 当 故障 发生 后 从 DEG 得到 的 故障 敏感 图 Fig 　 Corestructureofruntimesystem 图 　 运行 系统 的 核 结构 故障 敏感 图 　 　 当 系统 监控器 监测 到 某台 主机 故障 时 就 通知 本地 的 运行 系统 运行 系统 于是 检查 映射 表 找出 运行 在 该 主机 上 的 所有 进程 在 DEG 上 标注 出来 图 给出 了 一个 标有 故障 进程 的 DEGFig 　 DEGwithfaultprocessestagged 图 　 标有 故障 进程 的 DEG 　 　 FSG 是 一个 树型 结构 它 的 顶点 是 某 一个 故障 节点 当某 一个 节点 上 的 进程 为 故障 进程 时该 节点 就是 故障 节点 故障 节点 在 DEG 中 的 父 节点 和 孩子 节点 都 被 添加 进 FSGFSG 中 各 节点 间 的 边 也 都 被 加进 FSG 假定 每个 FSG 片段 至多 有 两个 故障 节点 这 可 在 定义 配置文件 时 做到 由图 可 得到 图 所示 的 两个 FSG 片段 从图 我们 也 可以 看到 多个 FSG 中 的 节点 有 可能 相互 交叠 Fig 　 FSGderivedfromDEG 图 　 由 DEG 获得 的 FSG 　 　 采用 FSG 是因为 我们 考虑 到 当 一个 分布式应用 中 的 某 一 进程 发生 故障 后 其他 相对 独立 于 该 进程 的 进程 应 可以 继续执行 下去 而 无需 真正 回卷 这 也 是 本文 稍后 给出 的 回卷 算法 和 故障 恢复 的 基本 思想 运行 系统 收到 监控器 发来 的 故障 通知 消息 后 即 挂 起 本地 进程 将 其 状态 设 为 “ ABNORMAL ” 此后 故障 主机 将 重启 其上 的 运行 系统 也 将 重启 如果 某 本地 进程 正在 发送 消息 则 在 其 发送 动作 完毕 后 被 挂 起 所 发送 的 消息 由 本地 运行 系统 保存 在 一个 队列 里 称为 TEMQUEUE 此外 由于 各 运行 系统 非 同时 终止 正常 操作 而 转入 故障 恢复 操作 一个 运行 系统 有 可能 收到 其他 运行 系统 转发 的 消息 这些 消息 也 需 保存 这样 非 故障 敏感 的 进程 一旦 收到 “ NORMAL ” 的 消息 后 无需 真正 回卷 就 可 继续执行 详细 过程 将 在 后 两节 给出 回卷 算法 　 定义 　 　 对 采用 消息传递 模型 的 分布式应用 来说 应用 可 看成 是 由 事件驱动 的 即 一 进程 每 接收 到 一条 消息 就 从 一种 状态 转换 到 另 一种 状态 文献 ［ ］ 中将 接收 消息 定义 为 事件 eij 表示 进程 Pi 的 第 j 个 事件 sij 表示 事件 eij 后 的 状态 SENTije 表示 到 事件 e 发生 为止 进程 Pi 发送到 进程 Pj 的 消息 总数 RECDije 表示 到 事件 e 发生 为止 进程 Pi 接收 到 来自 Pj 的 消息 总数 运行 系统 为 每 一个 本地 进程 保存 一系列 SENT 与 RECD 参数 对 每 发送 或 接收 一条 消息 相应 的 参数 增加 并且 与 消息 一起 保存 到 稳定 的 存储介质 如 硬盘 、 磁带 等 上 这 一 方法 增加 了 系统 空间 上 的 开销 相对 于 较为 廉价 的 存储介质 而言 我们 认为 这一 方法 是 可行 的 但 在 今后 的 工作 中 我们 仍 将 研究 如何 有效 地 降低 系统 的 这 一 开销 的 问题 　 　 故障 发生 后 进程 所处 的 状态 各 不 一样 回卷 算法 的 目的 即 是 要 找到 一个 全局 的 一致 状态 我们 定义 一个 全局 的 一致 状态 是 这样 的 一个 事件 集合 每个 进程 在 该 集合 中有 一个 事件 相对 应 任意 两个 事件 ei 与 ej 之间 满足 SENTijei ≥ RECDjiej 以及 SENTjiej ≥ RECDijei 这里 要求 消息传递 是 有序 的 　 回卷 算法 　 　 回卷 算法 由 发生 短暂 故障 后 重启 的 运行 系统启动 该 运行 系统 首先 从 其他 正常 的 运行 系统 处 获得 逻辑图 结构 的 拷贝 然后 通过 系统 记录 的 动态 信息 得到 DEG 最后 由 DEG 得到 若干 FSG 下面 我们 分别 给出 发生 故障 的 运行 系统 上 执行 的 回卷 算法 算法 和 正常 的 运行 系统 上 执行 的 回卷 算法 算法 　 　 算法 　 　 while 尚有 FSG 未 处理 loop 　 　 　 rbi ← FSG 根 节点 上 故障 进程 Pi 的 最近 事件 ； 　 　 　 ifFSG 中 另 有 一个 故障 进程 Pk 　 then 　 　 　 　 　 rbk ← Pk 的 最近 事件 ； 　 　 　 　 　 ifSENTkirbk ＜ RECDikrbithen 　 　 　 　 　 　 　 Pi 回卷 直至 事件 e ′ 使得 SENTkirbk ≥ RECDike ′ 　 　 　 　 　 　 　 rbi ← e ′ 　 　 　 　 　 　 elseifSENTikrbi ＜ RECDkirbkthen 　 　 　 　 　 　 　 Pk 回卷 直至 事件 e ′ 使得 SENTikrbi ≥ RECDkie ′ 　 　 　 　 　 　 　 rbk ← e ′ 　 　 　 广度 遍历 树 FSG 　 　 　 　 if 所 遍历 的 进程 Pj 是 一个 正常 进程 then 　 　 　 　 　 　 设 Pl 为 Pj 所在 节点 的 父 节点 上 的 进程 ； 　 　 　 　 　 ifPl 为 故障 进程 且 其 回卷 状态 为 rbl 　 then 　 　 　 　 　 　 　 向 Pj 运行 其上 的 运行 系统 发送 UPDATESENTljrblPj 　 　 endloop 　 　 算法 　 　 while 接收 到 消息 loop 　 　 　 if 该 消息 为 UPDATESENTijrbiPj 消息 then 　 　 　 　 从 稳定 存储介质 中 得到 Pj 的 最近 事件 赋给 rbj ； 　 　 　 　 ifSENTijrbi ＜ RECDjirbjthen 　 　 　 　 　 　 Pj 回卷 直至 事件 e ′ 使得 SENTijrbi ≥ RECDjie ′ 　 　 　 　 　 　 rbj ← e ′ 　 　 endloop 　 　 设 ei 为 进程 Pi 的 最近 事件 ej 为 进程 Pj 的 最近 事件 可 证明 SENTijei ＜ RECDjiej 与 SENTjiej ＜ RECDijei 不 可能 同时 成立 证明 如下 ： 　 　 证明 ： 为 简便 起 见 我们 分别 将 SENTijei 与 RECDjiej 简写 为 SENTei 与 RECDej 假设 SENTei ＜ RECDej 这 就 意味着 在 Pi 发送 消息 m 后 故障 发生 SENTei 未 更新 而 Pj 收到 了 消息 m 且 RECDej 已 更新 在此之前 Pi 与 Pj 的 状态 是 一致 的 如果 SENTej ＜ RECDei 则 意味着 Pj 在 事件 ej 发送 消息 m ′ 但 却 未及 更新 SENTej 而 Pi 接收 到 了 消息 m ′ 且 更新 了 RECDei 根据 我们 对 事件 的 定义 及 eiej 分别 为 Pi 与 Pj 的 最近 事件 的 前提条件 m ′ 必须 在 Pj 收到 m 后 发送 根据 消息 有序 发送 的 假定 m ′ 在 事件 ei 后 到达 Pi 而 Pi 在 事件 ei 后 发生 故障 因此 Pi 不 可能 收到 消息 m ′ 并 更新 RECDei 故 SENTijei ＜ RECDjiej 与 SENTjiej ＜ RECDijei 不 可能 同时 成立 　 　 由于 其 不能 同时 成立 算法 中 的 单 方向 的 调整 就 可以 保证 最终 所得 为 一个 全局 一致 状态 故障 恢复 　 　 对 正常 的 运行 系统 而言 恢复 工作 首先 要 处理 保存 在 TEMQUEUE 中 的 消息 处理过程 如下 算法 ： 　 　 算法 　 　 whileTEMQUEUE 非空 loop 　 　 　 　 if 消息 是 发往 本地 进程 then 启动 该 进程 运行 处理 消息 随后 挂 起 该 进程 ； 　 　 　 　 if 消息 是 发往 一 故障 进程 then 丢弃 ； 　 　 　 　 if 消息 是 发往 一 远程 正常 进程 then 进行 常规 处理 ； 　 　 　 endloop 　 　 　 向 所有 其他 正常 的 运行 系统 广播 TEMFINISH 消息 ； 　 　 　 　 if 收到 所有 来自 其他 正常 运行 系统 的 TEMFINISH 消息 　 　 　 　 then 转而 执行 算法 else 等待 　 　 故障 运行 系统 重启 后 即 执行 回卷 算法 然后 从 所 得到 的 一致 状态 处 启动 其上 进程 运行 并设 其 状态 标志 为 “ NORMAL ” 算法 主要 给出 了 恢复 运行 的 前 故障 运行 系统 如何 处理 来自 本地 进程 的 接收 与 发送 请求 以及 如何 处理 “ NORMAL ” 消息 　 　 设 Pf 为 任一 原 故障 进程 ef 为 其 回卷 点 ； Pn 为 某个 FSG 上 的 任一 正常 进程 en 为 其 回卷 点 enl 为 其 最近 事件 ； Pu 为 任一 不 在 任何 FSG 上 的 正常 进程 　 　 算法 　 　 if 消息 是 由 Pf 发往 另 一 故障 进程 then 进行 常规 处理 ； 　 　 if 消息 是 由 Pf 发往 Pnthen 　 　 　 本地 运行 系统对 其 进行 常规 处理 然后 转 交给 远程 的 运行 系统 ； 远程 运行 系统 首先 检查 其 状态 标志 ： 　 　 　 　 if 状态 标志 为 ABNORMALthen 　 　 　 　 　 ifRECDen ≤ SENTefthen 　 　 　 　 　 　 ifen ≠ enl 　 then 将 en 更新 为 下 一个 事件 并 丢弃 所 收到 的 消息 ； 　 　 　 　 　 　 else 将 Pn 状态 标志 设为 NORMAL 启动 其 正常 运行 并 向 所有 相邻 进程 发 NORMAL 消息 ； 　 　 ifPf 请求 由 Pf 发送 的 消息 then 进行 常规 处理 ； 　 　 ifPf 请求 由 Pn 发送 的 消息 then 　 　 　 ifPn 的 状态 标志 为 ABNORMALthen 　 　 　 　 本地 运行 系统 将 请求 及 RECDef 转 交给 远程 运行 系统 ； 远程 运行 系统 接到 请求 后 检查 SENTen 与 RECDef 　 　 　 　 　 ifSENTen ＞ RECDefthen 　 　 　 　 　 　 从 保存 的 目的地 为 Pf 的 发送 消息 队列 中 找到 第 RECDef ＋ 条 消息 发送给 Pf 　 　 　 　 　 　 　 if 队 列为 空且 en ＝ ＝ enl 　 then 　 　 　 　 　 　 　 　 将 Pn 状态 标志 设为 NORMAL 启动 其 正常 运行 并 向 其 邻接 进程 广播 NORMAL 消息 ； 　 　 if 消息 是 发往 某 本地 进程 Pk 的 NORMAL 消息 then 　 　 　 ifPk 的 状态 标志 为 ABNORMALthen 　 　 　 　 ifPk 在 某 一 FSG 上 then 　 　 　 　 　 将 其 状态 标志 设为 NORMAL 启动 其 正常 运行 并 向 所有 不 在 任一 FSG 上 的 邻接 进程 广播 NORMAL 消息 　 　 通过 上述 算法 一个 正常 进程 将 知道 故障 进程 何时 已 正常 运行 并 启动 自身 继续执行 结 　 论 　 　 回卷 算法 与 故障 恢复 目前 已有 大量 的 研究 研究者 提出 了 各种 方法 ［ ～ ～ ］ 本文 旨在 为 我们 早些时候 提出 的 扩充 的 支持 动态 配置 的 面向 图 结构 的 分布式 程序设计 模型 ExGOM 提供 对 暂时性 主机 故障 的 容错 处理 回卷 算法 与 故障 恢复 建立 在 故障 敏感 图 基础 之上 这 使得 相应 算法 无需 对 所有 进程 都 进行 回卷 处理 非 故障 敏感 的 进程 不必 回卷 从而 减少 了 恢复 工作 的 开销 　 　 暂时性 主机 故障 的 容错 处理 可 运用 到 永久性 主机 故障 的 容错 处理 中 例如 通过 冗余 实现 容错 的 系统 可以 及时 地 或是 定期 地 将 检查点 信息 复制到 对 等 主机 故障 发生 后 由 对 等 主机 进行 恢复 此时 对 等 主机 可 采用 暂时性 主机 故障 的 容错 处理 策略 ■ 基金项目 ： 本文 研究 得到 国家 高科技 项目 基金 NoZT 和 香港 理式 大学 研究 　 　 　 　 　 基金 资助 作者简介 ： 柳颖女 年生 博士 主要 研究 领域 为 分布式系统 并行计算 容错 计算 　 　 　 　 　 陈道 蓄年生 教授 主要 研究 领域 为 分布式系统 并行计算 计算机网络 　 　 　 　 　 谢立 年生 教授 博士生 导师 主要 研究 领域 为 并行计算 与 分布式 处理 　 　 　 　 　 曹建 农年生 博士 助教 主要 研究 领域 为 分布式系统 容错 计算 作者 单位 ： 柳颖 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 　 　 　 　 　 陈道 蓄 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 　 　 　 　 　 谢立 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 　 　 　 　 　 曹建农 香港理工大学 计算 系 　 香港 参考文献 ： ［ ］ VenkatesanSTonyTongyingJuangSridharAlagarOptimisticcrashrecoverywithoutchangingapplicationmessagesIEEETransactionsonParallelandDistributedSystems ～ ［ ］ WongKEFranklinMCheckpointingindistributedcomputingsystemsJournalofParallelandDistributedComputing ～ ［ ］ SunondoGhoshMelhemRDanielMosseFaultTolerancethroughschedulingofaperiodictasksinhardrealtimemultiprocessorsystemsIEEETransactionsonParallelandDistributedSystems ～ ［ ］ WeiXiaohuiJuJiubinCheckpointingalgorithmsindistributedsystemsChineseJournalofComputers ～ 魏晓辉 鞠九滨 分布式系统 中 的 检查点 算法 计算机 学报 ～ ［ ］ LiuYingXieLiCaoJiannongGOMagraphorientedmodelfordistributedprogrammingChineseJournalofComputers ～ 柳颖 谢立 曹建农 面向 图 结构 的 分布式 程序设计 模型 GOM 计算机 学报 ～ ［ ］ PankajJaloteFaultToleranceinDistributedSystemsEnglwoodCliffsNJPTRPrenticeHallInc ［ ］ SmithSWJohnsonDBMinimizingtimestampsizeforcompletelyasynchronousoptimisticrecoverywithminimalrollbackInProceedingsofthethIEEESymposiumonReliableDistributedSystems ～ ［ ］ PlankJSImprovingtheperformanceofcoordinatedcheckpointersonnetworksofworkstationsusingRAIDtechniquesInProceedingsofthethIEEESymposiumonReliableDistributedSystems ～ 收稿 日期 ： 修稿 日期 ：
计算机 研究 与 发展 JOURNALOFCOMPUTERRESEARCHANDDEVELOPMENT 年 第卷 第期 VolNo 数据仓库 中多 视图 环境 下 的 联机 维护 摘 　 要 　 数据仓库 的 视图 联机 维护 是 指 数据仓库 中 的 实体化 视图 实时 地 与 信息源 中 的 数据 变化 保持一致 ， 同时 不 影响 前端 用户 对 数据仓库 的 正常 使用 为了 解决 多 视图 环境 中 视图 联机 维护 与 下 钻 查询 的 一致性 问题 ， 文中 在 数据仓库 体系结构 中 引入 了 “ 基库 ” 模型 ， 并 提出 了 相应 的 视图 维护 算法 VPA （ threeversionpaintingalgorithm ） “ 基库 ” 不仅 增强 了 整个 数据仓库 系统 的 伸缩性 ， 而且 为 下 钻 查询 提供 了 更好 的 支持 VPA 采用 补偿 思想 、 同步 等待 机制 和 版本控制 方法 ， 通过 与 “ 基库 ” 的 联合 控制 ， 不但 保证 了 数据仓库 中多 视图 之间 的 数据 一致性 ， 而且 还 保证 了 下 钻 查询 能够 得到 一致 的 结果 关键词 　 数据仓库 ， 实体化 视图 ， 联机 维护 ， 下 钻 查询 ， 一致性 ， 基库 ， VPA 中图法 分类号 　 TPMULTIPLEVIEWSONLINEMAINTENANCEINDATAWAREHOUSEENVIRONMENTLIZiMuMOQianXUMingandZHOUXingMingNationalLaboratoryofParallelDistributedProcessingNationalUniversityofDefenseTechnologyChangshaAbstract 　 ViewsonlinemaintenanceindatawarehouseenvironmentmeansthattherefreshmentsofmaterializedviewsaresynchronizedwiththatofdatasourceswithoutdisturbingusersnormalusewithdatawarehouseatthesametimeDatawarehousebaseDWbaseindatawarehousearchitectureandVPAthreeversionpaintingalgorithmarepresentedtosolvetheconsistencyproblembetweenmultipleviewsonlinemaintenanceanddrilldownqueryTheintroductionofDWbasenotonlyimprovesthescalabilityofdatawarehousesystembutalsoprovidesbettersupportfordrilldownqueryThecombinedcontrolofDWbaseandVPAwhichusescompensatingsynchronizationandversioncontroltechniquesensuresdataconsistencyofmultipleviewsonlinemaintenanceanddrilldownqueryKeywords 　 datawarehousematerializedviewonlinemaintenancedrilldownconsistencyDWbaseVPA 　 引 　 言 　 　 数据仓库 的 主要 应用 是 联机 分析 处理 （ OLAP ） 对于 某些 OLAP 应用 ， 如下 钻 查询 ， 当 用户 知道 了 宏观 数据 ， 又 想 了解 与 这些 宏观 数据 相关 的 细节 数据 时 ， 有时 必须 通过 访问 源 数据库 才能 给出 最终 的 查询 结果 如果 此时 源 数据库 中 的 细节 数据 已 被 修改 ， 而 这种 变化 尚未 反映 在 数据仓库 中 相应 的 实体化 视图 中 时 ， 下 钻 查询 得到 的 细节 数据 便会 与 宏观 数据 不 一致 特别 是 当此 下 钻 查询 用到 了 数据仓库 中 的 多个 实体化 视图 ， 而 其中 有 不 只 一个 实体化 视图 与 这些 被 修改 的 源 数据 相关 时 ， 这种 数据 不 一致 问题 就 更 复杂 了 　 基库 与 VPA 算法 　 　 针对 数据仓库 的 特点 ， 本文 提出 了 一种 改进 的 层 数据仓库 体系结构 ， 如图所示 图 　 改进 的 层 数据仓库 体系结构 图 　 两层 数据仓库 体系结构 它 与 斯坦福大学 提出 的 两层 数据仓库 体系结构 ［ ］ （ 图 ） 的 不同之处 是 在 数据仓库 和 当前 数据库 之间 ， 增加 了 一个 称为 “ 数据仓库 基库 （ DWbase ， 以下 简称 基库 ） ” 的 数据库 它 类似 于 一个 中间件 ， 向上 ， 它 与 数据仓库 打交道 ； 向下 ， 它 与 当前 数据库 打交道 基库 与 当前 数据库 之间 的 数据流 是 单向 的 ， 当前 数据库 只 负责 将 数据库 端 （ DB 端 ） 的 每次 变化 情况 通知 基库 即可 ， 除此之外 无需 做 任何 动作 基库 与 数据仓库 之间 的 数据流 是 双向 的 ， 它 向 DW 端 发送数据 变化 通知 ， 接收 DW 端 发来 的 视图 维护 查询 和 下 钻 查询 ， 并 将 最终 查询 结果 返回 给 DW 　 基库 中 的 数据表示 　 　 基库 实际上 也 是 一个 数据库 ， 它 的 数据 全部 来源于 当前 数据库 ， 只是 类似 于 网络 中 的 数据 “ 打包 ” ， 在 原始数据 的 前面 增加 了 个 属性 ， 如图所示 ： VNIVNDflagdbt 　 图 　 基库 中 的 元组 结构 　 　 其中 ： VNIversionnumberofinsertion ： 生成 这 一元 组时 实体化 视图 FV 的 版本号 ； VNDversionnumberofdeletion ： 删除 本 元组 的 实体化 视图 FV 的 版本号 ； flag ： 标志 位 ， 它 有 两个 标志 ① ： I ： 表明 此 元组 是 刚 插入 的 ； D ： 表明 此 元组 已 被 逻辑 删除 （ 版本 切换 时才 进行 物理 删除 ） ； dbtdatabasetuple ： 来自 源 数据库 的 原始 元组 ； 　 　 这里 采用 版本号 和 标志 位 的 方法 来 区分 最新 数据 与 历史数据 ， 并 对 它们 进行 控制 维护 　 VPA 算法 　 　 基于 这个 层 体系结构 ， VPA 算法 不仅 能够 保证 DW 中多 视图 之间 的 数据 一致性 ， 而且 也 能 保证 视图 联机 维护 与 下 钻 查询 的 一致性 ， 并且 还 很 好地解决 了 VNL 面临 的 事物 重启 和 维护 不 完备 等 问题 ［ ］ VPA 分为 VPAvm ， VPAmp 和 VPAdwb 三 部分 ， 分别 在 DW 端 和 基库 端 执行 它 采用 补偿 思想 ［ ］ 、 同步 等待 机制 和 版本控制 ［ ］ 方法 ， 在 “ 基库 ” 的 参与 下 ， 联合 协调 数据库 、 数据仓库 的 刷新 操作 和 用户 启动 的 下 钻 查询 它 的 基本 工作 原理 如下 ： 　 　 在 当前 数据库 中 加载 一个 Monitor 模块 ， 它 负责 向 基库 报告 DB 中 数据 的 变化 情况 ， 对于 DB 中 数据 的 任何 变化 （ insertdelete ） ， Monitor 都 产生 一个 消息 ， 通知 基库 ； 　 　 基库 收到 DB 端 发来 的 数据 变化 通知 后 ， 对 基库 中 的 数据 做 相应 更新 ， 然后 发送 一个 对应 的 消息 到 DW 端 ， 由 Integrator 将 其 转发给 相应 的 ViewMgr （ VM ） ， 并 告知 MergeProcess （ MP ） 哪些 实体化 视图 与 这次 更新 有关 　 　 每个 VM 都 是 一个 相对 独立 的 视图 维护 进程 ， 分别 负责 某个 实体化 视图 某一 版本 的 更新 维护 工作 VM 计算 出 相应 的 实体化 视图 应 采取 的 更新 操作 后 ， 产生 动作 表 ActionListAL ， 并 将 其 传送 给 MP 　 　 MP 了解 DW 中 所有 实体化 视图 的 定义 和 版本 更新 情况 它 维护 着 两个 不同 版本 的 ViewUpdateTable （ VUT ） ， 通过 VUT 对 DW 中 多个 视图 的 刷新 操作 进行 同步 ， 以 保证 相同 版本号 的 所有 实体化 视图 之间 始终 是 一致 的 　 　 在 DW 端 ， 每个 实体化 视图 都 有 个 不同 的 版本 ： CurrentVersionCV ， NextVersionNV 和 FutureVersionFV 其中 CV 对 用户 始终 是 可见 的 ， 它 是 一个 稳定 的 只读 版本 ， 且 与 基库 的 某个 状态 是 一致 的 NV 是 一个 中间 版本 ， 负责 维护 此 版本 的 VM 不再 接收 来自 基库 的 数据 变化 通知 ， 而 只是 等待 自己 以前 发向 基库 的 维护 查询 的 结果 ， 并 产生 相应 的 AL 传递 给 MP 当 所有 NV 的 更新 全部 完成 后 ， 它们 之间 将 是 一致 的 ， 而且 它们 与 基库 的 某个 状态 也 是 一致 的 这时 它们 变成 可见 ， 以后 用户 启动 的 新 的 OLAP 查询 将 在 这个 版本 上 执行 此时 ， 如果 所有 基于 CV 的 OLAP 查询 都 已 完成 ， 即可 进行 版本 切换 FV 是 DW 端 最 活跃 的 版本 ， 负责 维护 此 版本 的 VM 接收 所有 来自 基库 的 数据 变化 通知 ， 根据 需要 发送 维护 查询 到 基库 ， 并 产生 相应 的 AL 发往 MP 这个 版本 之间 的 关系 是 ： verFVverNVverCV ② 　 　 版本 切换 时 ， NV 取代 原来 的 CV 成为 新 CV ， FV 取代 原来 的 NV 成为 新 NV ， 并 产生 一个 新 的 FV 和 VM 与 此 相应 ， 基库 端 与 CV 对应 的 “ 过时 ” 旧 数据 将 被 物理 清除 　 新 结构 和 算法 的 特点 　 　 新 的 层 数据仓库 体系结构 和 VPA 算法 具有 以下 的 特点 ： 　 　 用户 可以 随时 使用 数据仓库 ， 数据仓库 不再 有 专门 的 对外 服务 时间 和 更新 维护 时间 ， 这 两者 可以 同时 进行 ， 极大地提高 了 系统 的 可用性 ； 　 　 数据仓库 中 的 多个 实体化 视图 之间 ， 以及 它们 与源 数据 之间 始终 是 一致 的 ， 因而 支持 下 钻 查询 ， 且 返回 给 用户 的 查询 结果 是 一致 的 ； 　 　 版本 切换 平滑 ， 不会 导致 任何 事务 的 重启 ； 　 　 基本 保持 现有 数据库系统 不变 ， 使 其 只 需 加载 一个 监控 模块 即可 融入 到 数据仓库 系统 中 ； 融入 数据仓库 系统 中 的 数据库 仍 可以 进行 正常 的 OLTP 操作 ， 性能 基本 不 下降 ； 　 　 基库 的 引入 增强 了 系统 的 伸缩性 ， 数据仓库 的 未来 功能扩充 可以 在 基库 中 进行 ， 而 不必 受 传统 数据库 结构设计 的 约束 　 VPA 和 版本 切换 　 　 在 VPA 中共 涉及 到种 消息 类型 ： 　 　 　 DB 端的 Monitor 发出 的 数据 变化 通知 ， U 为 以下 两个 参数 之一 ： insr ， t ： 在 表 r 中 插入 元组 t ； delr ， t ： 从表 r 中 删除 元组 t ； 　 　 基库 发向 DW 端的 数据 变化 通知 ， 其中 的 参数 U 完全 对应 于 dbup 中 的 参数 ； 　 　 由 DW 端的 发出 的 维护 查询 通知 ， 它 带有 一个 版本号 参数 N ， 表明 此 查询 的 返回 结果 是 用于 维护 的 （ 版本号 为 N 的 实体化 视图 Vx ） ； 　 　 基库 发出 的 完成 查询 后 的 结果 通知 ； 　 　 DW 端 发出 的 下 钻 查询 通知 ， 它 也 带有 一个 版本号 参数 N ， 表明 此下 钻 查询 在 DW 端 是 基于 哪个 版本 的 实体化 视图 的 　 　 基库 发出 的 完成 查询 后 的 结果 通知 ； Integrator 收到 此 通知 后 ， 将 把 直接 提交 给 用户 启动 的 OLAP 查询 ， 而 不 用于 实体化 视图 的 维护 　 　 算法 中 涉及 到 的 变量 ： 　 　 AVN ： ActiveVersionNumber ， AVN 是 当前 FV 的 版本号 ， 即 AVN ＝ verFV ； 　 　 UQSN ： UnansweredQuerySet ， 用于 记录 所有 基于 N 号 版本 视图 的 OLAP 查询 当 用户 启动 一个 基于 N 号 版本 的 OLAP 查询 Q 时 ， UQSN ← UQSN ＋ Q ； 当 此 查询 完成 后 ， UQSN ← UQSN － Q ； 　 VPAdwb 算法 　 　 基库 中 的 数据 全部 来源于 数据库 ， 在 最初 建立 时 ， 任一 元组 的 VNI 都 等于 ， VND 都 是 无穷大 （ 符号 为 ∞ ， 在 实际 中 可以 将 其 初始化 为 一个 不会 到达 的 版本号 ） ， flag 都 为 I 　 　 VPAdwb 通过 标志 位 和 版本号 对 基库 中 的 数据 进行 控制 维护 ， 确保 数据 的 一致性 操作 它 接收 来自 DB 端 Monitor 发来 的 原始数据 变化 通知 ， 刷新 自己 的 库存 数据 ， 并 负责 将 此 变化 通知 Integrator 算法 具体 如下 ： 　 　 对 消息 队列 中 的 消息 做 相应 处理 ： 　 　 　 　 　 ifUiinsr ， tthen 　 　 　 　 ｛ 生成 新元 组 t ； 其中 tVNIAVN ， tVND ∞ ， tflagI ， tdbtt ； ｝ 　 elseUidelr ， t 　 　 ｛ 找到 元组 t ， 使得 tdbtt 　 　 　 　 iftVNIAVNthen 物理 删除 t 　 　 　 　 elsetflagD 　 　 　 　 　 　 　 tVNDAVN 　 　 发送到 DW 端 ； 　 　 　 ifNAVNthen 　 　 QNk 是 基于 FV 的 维护 查询 　 　 　 对于 是 做 QNk 运算 时 涉及 到 的 关系 ） ， 　 　 　 使用 算法 读出 r 中 的 元组 注 ③ ； 　 elseQNk 是 基于 NV 的 维护 查询 　 对于 使用 算法 读出 r 中 的 元组 　 使用 读出 元组 的 dbt 域 做 QNk 运算 ANk ← 结果 ； 　 发送到 DW 端 ； 　 　 　 ifNAVN － then 是 基于 NV 的 下 钻 查询 　 　 对于 使用 算法 读出 r 中 所有 元组 ； 　 else 是 基于 CV 的 下 钻 查询 　 　 对于 使用 算法 读出 r 中 的 元组 ； 　 使用 读出 元组 的 dbt 域 做 运算 ， 结果 ； 　 发送到 DW 端 ； 算法 Repeat ｛ 　 对于 tdbt ∈ r ， 　 iftflagIthen 读出 tUntiltdbt ∈ r 的 元组 已 全部 扫描 算法 Repeat ｛ 对于 tdbt ∈ r ， 　 iftVNI ≤ AVNthen 　 　 ｛ iftflagIthen 读出 t 　 　 elseiftflagD 且 tVNDAVNthen 读出 tUntiltdbt ∈ r 的 元组 已 全部 扫描 过 算法 Repeat ｛ 对于 tdbt ∈ r ， 　 iftVNI ≤ AVNthen 读出 tUntiltdbt ∈ r 的 元组 已 全部 扫描 　 　 基库 对 实体化 视图 的 个 版本 分别 进行 处理 ， 是 为了 保证 各 版本 在 维护 时 只能 看到 它 自己 应 看到 的 数据 变化 ， 而 看不到 与 之 无关 的 数据 状态 只有 这样 才能 保证 CV ， NV 和 FV 在 基库 中 都 有 与 之 对应 的 一致 的 数据 状态 　 VPAvm 算法 　 　 VPAvm 是 DW 端 视图 维护 进程 VM 执行 的 算法 它 负责 与 基库 通信 ， 并 最终 生成 动作 表 AL 在 系统 最初 建立 的 时候 ， 每个 实体化 视图 只有 两个 版本 ： CV 和 FV （ NV ＝ FV ） ， 因此 只有 一个 VM 负责 视图 的 维护 工作 当 系统 进行 版本 更新 ， 系统 中 的 实体化 视图 出现 个 版本 后 ， 每个 实体化 视图 Vx 则 有 两个 VM ： VMNVx 和 VMFVx 分别 负责 维护 它 的 NV 和 FV 　 　 VMFVx 执行 全部 的 VPAvm 算法 ， VMNVx 由于 不再 接收 基库 发来 的 数据 变化 通知 ， 所以 它 不再 执行 对 dwbup 事件 的 处理 算法 具体 如下 （ 设 执行 此 算法 的 是 VMNx ） ： 　 　 初始化 变量 ： 对 基库 发来 的 消息 做 相应 处理 ： 　 　 　 　 　 　 thenm ＝ i ； 记下 本轮 动作 表 的 第一个 序号 　 　 　 　 ifUi ＝ insr ， tthen ｛ k ＝ k ＋ ； 　 　 　 　 　 　 　 　 　 　 　 　 发送到 基库 端 ； 　 　 　 　 　 　 WASNx ← WASNx ＋ QNk ； PNk ＝ ； ｝ 　 　 　 　 elseifUi ＝ delr ， tthenk ＝ k ＋ ； 　 　 　 　 　 　 　 　 　 　 　 　 发送到 基库 端 ； 　 　 　 　 　 　 WASNx ← WASNx ＋ QNk ； PNk ＝ ； ｝ 　 　 　 　 　 　 DeltaNx ← DeltaNx ＋ PNkANk ； WASNx ← WASNxQNk ； 　 　 　 　 n ＝ k 　 当时 ， n 即为 本轮 动作 表 的 最后 一个 序号 　 　 　 　 ifthen ｛ 　 发送到 MP ； ｝ 　 　 当某 一 时刻 DB 端 数据 更新 的 速度 较 快 ， 或 DW 端 版本 切换 较慢 时 ， VM 发出 的 维护 查询 需要 做 补偿 处理 ， WASNx （ waitingforanswerset ） 即 是 用于 记录 那些 尚未 收到 结果 的 维护 查询 的 DeltaNx 是 一个 临时 变量 ， 用于 记录 对 实体化 视图 VNx 的 更新 操作 记录 了 从 Um 到 Un 所 引起 的 应对 实体化 视图 VNx 采取 的 更新 操作 V 是 数据仓库 中 实体化 视图 的 定义 ， 例如 （ 用 r 的 元组 ［ ］ 替代 表达式 中 相应 的 关系 ） QNk 是 DW 端 发往 基库 端的 维护 查询 ， 形式 上 与 V 类似 　 VPAmp 算法 　 　 MP 负责 维护 两个 VUT （ FV 版本 和 NV 版本 ） ， VPAmp 是 其 在 VUT 上 执行 的 算法 ， 用以 维护 版本号 相同 的 多个 实体化 视图 之间 的 数据 一致性 它 采用 SPA 算法 ［ ］ 思想 ， 不同之处 是 ， VPAmp 带有 版本 概念 ， 而且 由于 VM 采用 的 是 具有 补偿 思想 的 VPAvm 算法 ， 所以 算法 中 VUT 的 每 一行 可以 是 与 源 数据库 中 的 多个 更新 操作 对应 的 算法 具体 如下 ： 　 　 初始化 ： 　 　 收到 RELNi ： 　 　 　 　 ifthenCollect ← Collect ∪ RELNi 　 　 　 　 else 　 　 　 收到 ： 　 　 　 　 ｛ ifthen 　 　 　 　 　 ｛ 在 VUTN 中 新增 一 s 行 ， 其中 VUTN ［ sx ］ 对应 于 Um 到 Un 和 VNx ； 　 　 　 　 　 　 　 　 　 　 ｛ 对于 colorwhite 　 　 　 　 　 　 elseVUTN ［ sx ］ colorblack 　 　 　 　 　 对于 所有 的 项 ， 调用 ProcessActionss 　 　 　 　 　 else ｛ 调用 ProcessAction ｝ ｝ 　 　 procedureProcessAction 　 　 　 ｛ VUTN ［ sx ］ colorred 　 　 　 ifVUTN － 为 空表 then 调用 ProcessRows ｝ 　 　 procedureProcessRows 　 　 　 ｛ if 　 x 且 VUTN ［ sx ］ colorwhitethenreturn 　 　 　 　 if 　 xss 使得 VUTN ［ sx ］ colorred 且 VUTN ［ sx ］ colorredthenreturn 　 　 　 　 对于 x ∈ VMN ， ifVUTN ［ sx ］ colorredthenVUTN ［ sx ］ colorgray 　 　 　 　 对 所有 VUTN ［ sx ］ colorgray 的 项 ， ifNextRedsxN ≠ then 调用 ProcessRowNextRedsxN 　 　 　 　 从 VUTN 中 删除 s 行 ， return ｝ 　 　 上述 算法 中 ， RELNi 是 用于 记录 与 Ui 相关 的 实体化 视图 的 ， 当 Integrator 每次 收到 基库 发来 的 Ui 后 ， 便 确定 RELNi 的 值 ， 并 将 其 传送 给 MPALLRELNs 记录 了 与 Um 到 Un 这些 更新 有关 的 实体化 视图 ， 它 时刻 与 VUT 保持一致 ， 当 VUTN 为 空表时 ， ALLRELNs 也 为 空集 WTNs 用于 收集 相关 实体化 视图 的 动作 表 由于 动作 表 涉及 到 的 更新 操作 可能 不 只 一个 ， 而 RELNi 总是 先于 相应 的 AL 到达 MP ， 所以 MP 在 收到 之前 无法 确定 与 之 对应 的 的 ALLRELNs 内容 ， 只能 用 一 临时 变量 Collect 来 保存 每次 的 RELNi 　 　 在 ProcessAction 过程 中 ， 对 VUTN － 进行 了 判断 ， 因为 NV 的 更新 是 基于 CV 的 ， FV 的 更新 是 基于 NV 的 ， 只有 当 它们 的 前 一 版本 稳定下来 后 （ 即 VUTN － 为 空表时 ） ， 才 可以 用前 一 版本 实体化 视图 的 内容 和 当前 版本 的 动作 表 一起 更新 当前 版本 实体化 视图 ProcessRow 中 的 即 是 用来 完成 此项 功能 的 NextRedsxN 返回 的 是 紧排 在 VUTN ［ sx ］ 下面 的 color 域 为 red 的 项 的 行标 　 版本 切换 　 　 在 DW 端 ， 当 所有 基于 NV 版本 的 视图 维护 工作 已经 完成 （ 为 空表 ） ， 且 基于 CV 的 OLAP 查询 也 已 全部 完成 （ ） 时 ， 即可 进行 版本 切换 在 DW 端 ， 版本 切换 要 执行 的 操作 如下 ： 　 　 AVN ← AVN ＋ ； 删除 所有 CV 版本 的 实体化 视图 ； 杀死 相应 的 VM ； 删除 VUTCV ； 　 　 CV ← NV ； NV ← FV ； VUTCV ← VUTNV ； VUTNV ← VUTFV ； 　 　 每个 实体化 视图 Vx 再 生成 一个 新 的 FV 版本 ， 由 VMFVx 负责 维护 ； MP 产生 一个 新 的 空 的 VUTFV ； 　 　 在 基库 端 ， 与 之 对应 的 是 “ 旧 数据 ” 回收 即 VND ≤ AVN － 且 flagD 的 元组 从 基库 中 物理 删除 　 结束语 　 　 数据仓库 联机 维护 技术 已经 成为 重要 的 研究 方向 本文 中 提出 的 层 数据仓库 体系结构 和 VPA 算法 不仅 增强 了 整个 系统 的 伸缩性 ， 而且 使得 数据库 和 数据仓库 更能 专注 于 自己 的 OLTP 和 OLAP 应用 ， 提高 了 数据仓库 系统 的 整体 性能 由于 采用 了 三 版本 维护 方法 ， 数据仓库 的 刷新 和 查询 可以 同时 进行 ， 系统 的 更新 不会 中止 任何 正在 进行 的 查询 事务 ， 消除 了 现有 系统 必须 在 专门 时间 对系统 进行 更新 维护 的 缺点 ， 提高 了 系统 的 可用性 ① modify 操作 可以 看做 是 先 删除 后 插入 ， 也 可以 单独 对 其 进行 处理 ， 本文 对此 不 做 讨论 ② 　 FVNVCV 分别 表示 实体化 视图 的 个 不同 版本 ； verFVverNVverCV 分别 表示 FV ， NV 和 CV 这个 版本 的 实体化 视图 的 版本号 ③ r 是 基库 按照 图 的 结构 建立 的 与 r 对应 的 表 ④ 运算符 的 运算 规则 为 作者简介 ： 李子 木 ， 男 ， 年月生 ， 博士 研究生 ， 研究 领域 为 数据仓库 、 数据库 协同工作 、 计算机网络 莫倩 ， 男 ， 年月生 ， 博士 研究生 ， 研究 领域 为 数据库 协同工作 徐明 ， 男 ， 年生 ， 博士 ， 副教授 ， 研究 领域 为 数据库 协同工作 、 面向对象 数据库 、 高性能 计算机 体系结构 周兴铭 ， 男 ， 年生 ， 博士生 导师 ， 中科院 院士 ， 研究 领域 为 数据库 协同工作 、 分布 并行计算 、 高性能 计算机 体系结构 作者 单位 ： 李子 木 　 莫 　 倩 　 　 徐 　 明 　 周兴铭 　 国防科技大学 并行 与 分布 处理 国家 重点 实验室 　 长沙 　 参考文献 　 ZhugeYWienerJMolinaHGMultipleviewconsistencyfordatawarehousingInProceedingsoftheInternationalConferenceonDataEngineeringBrimingham ～ 　 QuassDWidomJOnlinewarehouseviewmaintenanceforbatchupdatesInProceedingsoftheACMSIGMODConferenceTusconArizona 　 ZhugeYMolinaHGHammerJWidomJViewmaintenanceinawarehousingenvironmentInProceedingsofACMSIGMODConferenceSanJoseUSA ～ 　 BoberPMTowardspracticalmultiversionlockingtechniquesforonlinequeryprocessing ［ PhDdissertation ］ UniversityofWisconsinMadison 收到 日期 ： 修改 日期 ：
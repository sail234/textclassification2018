软件 学报 JOURNALOFSOFTWARE 　 Vol 　 No 　 PAdaI 支持 保护 对象 继承 的 Ada 扩充 语言 陆嘉 　 温冬婵 　 王鼎兴 　 摘要 　 面向对象 并发程序 设计 语言 能够 帮助 程序员 利用 面向对象 技术 编写 并发程序 从而 获得 面向对象 技术 给 软件开发 带来 的 种种 好处 然而 ， 由于 继承 异常现象 的 存在 ， 影响 了 并发程序 设计 语言 引入 继承 特性 Ada 语言 是 支持 并发程序 设计 的 面向对象 语言 之一 但 并 不 支持 保护 对象 的 继承 AdaI 语言 在 Ada 语言 的 基础 上 进行 扩充 从而 支持 保护 对象 的 继承 并且 避免 了 继承 异常现象 的 出现 　 关键词 　 Ada 保护 对象 继承 继承 异常 面向对象 并发程序 设计 语言 　 中图法 分类号 　 TPAdaIAnExtensionLanguageSupportingInheritanceofProtectedObjectsBasedonAdaLUJia 　 WENDongchan 　 WANGDingxing （ DepartmentofComputerScienceandTechnology 　 TsinghuaUniversity 　 Beijing 　 ） Abstract 　 　 ObjectOrientedconcurrentlanguagescanhelpprogrammerstodevelopconcurrentprogramsandtogainbenefitsbyusingobjectorientedtechnologysuchasencapsulationandinheritanceButinheritanceanomalyinfluencesdesigningobjectorientedconcurrentlanguagesAdaisoneoftheobjectorientedlanguagesthatsupportconcurrentprogramdesigningbutitdoesnotsupporttheinheritanceofprotectedobjectsAdaIlanguagebasedonAdasupportstheinheritanceofprotectedobjectsandcanavoidtheinheritanceanomalyKeywords 　 Adaprotectedobjectinheritanceinheritanceanomalyobjectorientedconcurrentlanguage 　 　 目前 面向对象 技术 在 计算机科学 的 各个领域 上 有 非常 广泛 的 应用 出现 了 许多 面向对象 并发程序 设计 语言 如 ABCLPrestoACT 等等 但 由于 继承 异常 inheritanceanomaly 现象 一些 面向对象 并发程序 设计 语言 不能 很 好 地 支持 代码 复用 破坏 了 对象 的 继承性 针对 该 问题 许多 学者 提出 了 解决方案 ［ ～ ］ 　 　 Ada 语言 是 少数几个 能 支持 并发程序 设计 且 广泛应用 的 高级 语言 之一 它 定义 了 任务 task 类型 保护 protected 类型 以及 一系列 支持 并发程序 设计 的 语法 语义 在 Ada 中 并发程序 以 任务 对象 和 保护 对象 为 单位 通过 任务 对象 和 保护 对象 的 并发 处理 ， 协同 完成 某一 特定 的 计算 和 处理 任务 我们 将 Ada 中 的 任务 对象 和 保护 对象 统一 称为 并发 对象 　 　 虽然 Ada 已经 在 顺序程序 设计 方面 适应 了 面向对象 程序设计 的 要求 支持 继承 、 多态 、 封装 等 典型 面向对象 特性 在 并发程序 设计 方面 ， Ada 中 的 并发 对象 也 具有 了 一些 面向对象 特性 如 封装 性 但是 Ada 并 不 支持 并发 对象 的 继承 因此 ， Ada 还 不能 满足 面向对象 并发程序 设计 的 要求 　 　 因为 Ada 中 任务 对象 的 语言 描述 框架 与 面向对象 技术 中 的 对象 描述 框架 差异 较大 如 任务 对象 之间 可以 通过 数据共享 交互 面向对象 技术 中 的 对象 只 通过 消息传递 交互 ， 所以 任务 对象 不易 抽象 出 面向对象 技术 中 方法 的 概念 而 Ada 中 的 保护 对象 的 语言 描述 框架 与 面向对象 技术 中 的 对象 类似 比较 容易 引入 继承 的 特性 因此 ， 在 本文 中 我们 主要 讨论 保护 对象 的 继承 问题 　 　 在 本文 中 我们 基于 Ada 语言 提出 了 一个 支持 保护 对象 继承 的 扩充 语言 AdaI 并 在 该 语言 中 消除 了 继承 异常现象 　 继承 异常现象 　 　 继承 是 面向对象 程序设计 的 关键 概念 之一 是 在 顺序 面向对象 程序设计 中 解决 代码 复用 问题 的 常用 方法 当前 虽然 许多 面向对象 技术 可以 很 方便 地 引入 到 并发程序 设计 中 进行 面向对象 并发程序 设计 但是 继承 却 不能 按照 顺序 面向对象 程序设计 中 的 使用 方法 简单 地 引入 并发程序 设计 因为 这样 会 导致 继承 异常现象 的 出现 也就是说 ， 子类 不能 进行 增量 式 声明 也 即 只 声明 父类 中 不 具有 的 变量 、 方法 等 而 其他 的 变量 、 方法 从 其 继承 的 父类 中 进行 代码 复用 无需 再作 声明 当 出现 继承 异常现象 时 子类 不仅 要 声明 父类 中 不 具备 的 变量 、 方法 而且 不得不 对 父类 中 定义 的 某些 方法 甚至 所有 方法 在 子类 中 重新 定义 　 　 在 面向对象 并发 系统 中 由于 可以 同时 有 多个 消息 访问 一个 并发 对象 对象 之间 的 消息传递 具有 不确定性 所以 ， 为了 保证 并发 对象 的 完整性 和 并发 对象 中 数据 的 一致性 每个 并发 对象 对 接收 到 的 消息 通常 按照 运行 条件 检查 、 运行 相应 方法 以及 运行 后 相应 的 状态 转换 这个 步骤 来 处理 当 并发 对象 的 当前 状态 不 满足 所 接收 消息 的 运行 条件 时 并发 对象 则 不 处理 该 消息 直到 并发 对象 的 状态 满足 该 消息 条件 为止 满足 某个 接收 消息 运行 条件 的 并发 对象 的 所有 状态 称为 该 消息 的 可纳 状态 acceptablestates 所有 消息 的 可纳 状态 的 总和 称为 该 并发 对象 的 可纳 状态 集 　 　 Matsuoka 与 Yonezawa 在 文献 ［ ］ 中 分析 了 并发 对象 继承 异常现象 出现 的 原因 认为 并发 对象 继承 异常 问题 的 出现 是因为 子类 对象 在 继承 父类 对象 方法 时 增加 的 新 方法 改变 了 父类 对象 的 可纳 状态 集 的 情况 又 因为 与 处理 可纳 状态 相关 的 运行 条件 检查和 状态 转换 是 和 对象 的 方法 紧密 相关 的 从而 导致 需要 重新 改写 父类 对象 的 方法 以 满足 新 的 运行 条件 检查和 状态 转换 的 要求 文献 ［ ］ 将 可纳 状态 的 改变 分成 以下 类 ： 可纳 状态 集 的 重新 划分 ； 可纳 状态 集 的 历史 相关 ； 可纳 状态 集 的 扩充 与 修改 　 　 下面 我们 以类 C 的 面向对象 并发程序 设计 语言 对 继承 异常现象 出现 的 原因 作一 简单 介绍 　 可纳 状态 集 的 重新 划分 　 　 由于 每个 并发 对象 的 运行 可以 考虑 为 一系列 的 状态 转换 而 每 一个 状态 是 由 并发 对象 的 所有 变量 当前 的 取值 构成 的 我们 可以 根据 并发 对象 每 一个 方法 的 可 接收 条件 也 就是 相对 应 消息 的 可纳 状态 形成 可纳 状态 集 的 一个 划分 　 　 以有界 队列 Buffer 为例 有界 队列 有 两个 基本 方法 get 从 队列 中取 一个 元素 putx 将 元素 x 放入 队列 显然 当 队列 元素 个数 为 即 队列 空时 get 不能 运行 当 队列 满时 putx 不能 运行 于是 我们 可以 得到 有 界 队列 可纳 状态 集 的 一个 划分 ： emptypartialfull 相应 为 队列 空 、 队列 半满 、 队列 满 　 　 我们 将 有界 队列 Buffer 作为 基类 由 其 派生 一个 新 的 子类 SubBuffer 在 该 子类 中 我们 增加 一个 新 的 方法 get 即 从 队列 中 取出 两个 元素 显然 ， 当 队列 中 元素 个数 为 时 get 不能 运行 而 getputx 依然 能够 运行 我们 可以 看出 子类 SubBuffer 的 可纳 状态 集与 父类 Buffer 相比 多 了 一个 get 的 可纳 状态 one 因此 ， 子类 SubBuffer 对 父类 的 可纳 状态 集 进行 了 新 的 划分 ： emptyonepartialfull ， 如图所示 Fig 　 Repartitionofacceptablestatesset 图 　 可纳 状态 集 的 重新 划分 　 　 我们 可以 看到 子类 SubBuffer 重写 了 父类 中 已有 的 方法 而 不能 直接 继承 这 就 出现 了 继承 异常现象 　 可纳 状态 集 的 历史 相关 　 　 可纳 状态 集 的 历史 相关 指 子类 派生 的 新 方法 与 父类 方法 运行 的 次序 相关 例如 我们 以有界 队列 Buffer 为 基类 派生 一个 新类 NewBuffer 这个 新类 中 增加 了 一个 新 的 方法 gget 它 的 运行 条件 是 在 它 运行 之前 有 连续 两个 putx 方法 运行 　 　 如图所示 为了 描述 gget 的 可纳 状态 我们 需要 重新 描述 父类 中 的 getputx 等 方法 从而 导致 出现 继承 异常现象 Fig 　 Historyrelationofacceptablestatesset 图 　 可纳 状态 集 的 历史 相关 　 可纳 状态 集 的 扩充 与 修改 　 　 对于 子类 SubBuffer 而言 它 并 没有 扩充 或 修改 父类 的 可纳 状态 集而 只是 改变 了 可纳 状态 集 的 划分 如果 我们 需要 从 基类 Buffer 派 生出 一个 新 的 子类 LockBuffer 这个 子类 引入 一个 新 的 条件 ： 是否 加锁 如果 已经 加锁 的话 方法 getputx 不能 运行 ； 如果 没有 加锁 则 能 运行 这样 方法 get 和 putx 的 可 运行 条件 就 增加 了 也就是说 ， 相应 的 可纳 状态 集 扩充 了 　 　 因为 如果 我们 采用 和 图 、 图 相同 的 语言 描述 方法 将 不会 出现 继承 异常现象 为了 说明 问题 我们 采用 新 的 语言 描述 方法 如图所示 在 这种 描述 方法 下 父类 的 方法 需要 重新 定义 出现 了 继承 异常现象 Fig 　 Modificationofacceptablestatesset 图 　 可纳 状态 集 的 修改 与 扩充 　 　 从 这个 例子 我们 可以 看到 不同 的 语言 描述 方法 出现 继承 异常现象 的 原因 也 是 不同 的 　 保护 对象 　 　 保护 对象 是 Ada 语言 新 增加 的 语言 成分 用来 描述 专门 为 其他 对象 服务 的 并发 对象 保护 对象 的 结构 与 程序包 和 任务 的 结构 相似 但 其中 的 说明 和体 不同 保护 对象 的 说明 部分 给出 访问 权限 而体 则 给出 实现 的 细节 与 程序包 和 任务 不 一样 的 是 保护 对象 的 体 不能 说明 任何 数据 ， 而 只能 说明 子程序 和 实体 数据 必须 放在 私有 部分 说明 　 　 保护 对象 可以 由 保护 类型 声明 保护 类型 与 保护 对象 之间 的 关系 与 面向对象 语言 中 的 类 与 对象 实例 相同 保护 对象 的 操作 分为 保护 子程序 和 保护 入口 而 保护 子程序 又 分为 过程 和 函数 过程 、 函数 和 入口 分别 由 关键字 procedurefunction 和 entry 说明 过程 可以 用 任意 方式 访问 私有 数据 函数 则 只能 读 私有 数据 而 入口 可以 任意 访问 私有 数据 但 它 带有 入口 限制 条件 只有 在 满足 限制 条件 的 情况 下 ， 保护 对象 才能 运行 相应 的 入口 体 　 我们 的 扩充 语言 方案 　 　 Ada 在 顺序程序 设计 方面 支持 面向对象 程序设计 支持 继承 、 多态 、 封装 等 典型 的 面向对象 特性 而 在 并发程序 设计 方面 Ada 不能 全面 支持 面向对象 程序设计 任务 对象 、 保护 对象 等 支持 封装 但 不 支持 继承 由于 保护 对象 的 语言 描述 特性 与 典型 的 面向对象 程序设计 语言 描述 特性 相似 例如 ， 数据 的 私有 、 多种 操作 的 独立 描述 因此 我们 在 Ada 语言 的 基础 上 针对 保护 对象 增加 支持 继承 的 特性 设计 了 AdaI 语言 ， 并且 在 这种 语言 描述 方法 的 基础 上 消除 了 继承 异常现象 　 保护 类型 声明 　 　 AdaI 中 的 保护 类型 声明 与 Ada 中 的 类似 由 类型 说明 和 类型 体 构成 在 类型 说明 中 声明 保护 类型 的 可 调用 操作 和 内部 数据 在 类型 体中 声明 各个 操作 的 具体 实现 　 　 保护 类型 可以 派生 子 类型 为了 使 AdaI 语言 简单 易懂 我们 支持 单 继承 而 不 支持 多 继承 子 类型 从父 类型 中 继承 父 类型 的 变量 和 操作 子 类型 只 定义 不同于 父 类型 的 那些 变量 和 操作 一方面 ， 子 类型 可以 增加 父 类型 中 没有 的 变量 和 操作 另一方面 子 类型 还 可以 重新 定 义父 类型 的 变量 和 操作 　 　 子 类型 声明 在 类型 说明 中 采用 关键字 inherit 来 说明 该子 类型 是从 某个 父 类型 派生 出来 的 同时 ， 在 类型 说明 中 声明 父 类型 中 没有 的 变量 和 操作 以及 需要 重新 定义 的 操作 　 　 子 类型 的 类型 说明 中 所 提及 的 操作 的 具体 实现 在 类型 体中 加以 声明 　 　 子 类型 声明 的 语言 描述 如下 ： 　 　 protectedtype 〈 子 类型 标识符 〉 inherit 〈 父 类型 标识符 〉 is — — 类型 说明 　 　 　 〈 父 类型 中 未定义 的 操作 〉 　 　 　 〈 子 类型 重新 定义 的 父 类型 已有 操作 〉 　 　 　 　 　 private 　 　 　 〈 父 类型 中 未定义 的 数据 〉 　 　 　 　 　 end 〈 子 类型 标识符 〉 　 保护 类型 操作 描述 　 　 由于 Ada 中 原来 的 保护 对象 操作 的 描述 方法 与 图 中 的 描述 法相 类似 因此 会 导致 继承 异常现象 的 发生 为了 消除 继承 异常现象 我们 将 改变 保护 对象 原来 的 描述 方法 　 　 因为 保护 对象 中 的 过程 操作 和 入口 操作 具有 一定 的 相似性 两者 的 差别 就 在于 过程 操作 没有 运行 条件 检查 而 入口 操作 需要 在 运行 前 进行 运行 条件 检查 所以 ， 我们 用 不 进行 运行 条件 检查 的 入口 操作 代替 过程 操作 于是 ， 在 AdaI 中 保护 对象 就 有 函数 和 入口 这 两类 操作 　 　 同时 我们 将 保护 对象 原来 的 入口 操作 分成 两个 部分 ： 运行 条件 检查和 操作 运行 动作 在 AdaI 中 分别 用 关键字 conditionaction 加以 说明 我们 可以 将 condition 和 action 理解 成 保护 类型 入口 操作 的 两种 属性 属性 condition 是 一个 条件 表达式 而 属性 action 是 一系列 动作 　 　 AdaI 中 保护 对象 入口 操作 的 基本 描述 结构 如下 ： 　 　 entry 〈 标识符 〉 参数表 is 　 　 begin 　 　 　 　 condition 　 　 　 　 begin 　 　 　 　 　 　 〈 入口 条件 表达式 〉 　 　 　 　 endcondition 　 　 　 　 action 　 　 　 　 begin 　 　 　 　 　 　 〈 操作 运行 动作 〉 　 　 　 　 endaction ； 　 　 end 　 　 当 AdaI 中 的 保护 对象 入口 被 调用 时 保护 对象 首先 检查 入口 条件 表达式 如果 条件 表达式 结果 为 真 继续执行 action 中 描述 的 运行 动作 ； 否则 该 入口 调用 排队 等待 其中 的 condition 可以 缺省 Condition 缺省 表示 入口 条件 永为 真 也 就是 不 作 入口 条件 检查 用 缺省 condition 描述 的 入口 操作 相当于 Ada 中 的 过程 操作 　 　 AdaI 中 保护 对象 的 函数 操作 与 Ada 中 的 一样 没有 运行 条件 检查 并且 多个 函数 操作 之间 可以 并发 运行 　 　 以 有界队 列为 例其 描述 如图所示 Fig 　 Boundedbuffer 图 　 有 界 队列 　 操作 代码 复用 　 　 为了 实现 操作 代码 的 复用 我们 可以 在子 类型 操作 中 直接 引用 父 类型 的 操作 于是 我们 引入 描述 父 类型 操作 和子 类型 操作 关系 的 关键字 super 用以 表示 父 类型 　 　 Super 关键字 可以 用 在 某 一 入口 操作 的 condition 的 声明 部分 也 可以 用 在 action 的 声明 部分 它 表示 子 类型 的 入口 操作 在 condition 和 action 中 分别 继承 相应 的 父 类型 中 入口 操作 的 相应 部分 在 condition 部分 使用 其 语言 描述 如下 ： super 〈 父 类型 操作 标识符 〉 condition 　 　 在 action 部分 使用 其 语言 描述 如下 ： super 〈 父 类型 操作 标识符 〉 action 　 　 在 condition 部分 使用 表示 继承 父 类型 中 某 入口 操作 的 condition 条件 表达式 因此 该 表达式 可以 与 其他 条件 表达式 进行 一定 的 布尔运算 即 可以 进行 与 、 或 、 非 运算 分别 用 andornot 表示 而 在 action 部分 使用 表示 继承 父 类型 中 某 入口 操作 的 action 动作 　 　 在子 类型 中 如果 我们 重新 定义 一个 父 类型 入口 操作 在 描述 过程 中 需要 将 condition 和 action 两 部分 都 重新 说明 如果 缺省 condition 或 action 中 的 一部分 ， 则 表示 相应 部分 从父 类型 中 继承 　 　 我们 以有界 队列 Buffer 和 派生 子 类型 LockBuffer 为例 该子 类型 引入 一个 条件 是否 加锁 和 两个 操作 ： 加锁 lock 和 开锁 unlock 当 队列 被 锁 时 get 与 put 都 不能 操作 直到 队列 被 开锁 如图所示 我们 在子 类型 LockBuffer 的 condition 中 采用 superget 和 superput 来 分别 表示 父 类型 Buffer 的 get 和 put 的 入口 条件 表达式 重写 了 get 和 put 的 入口 条件 用 缺省 action 表达 了 对父 类型 的 动作 代码 复用 Fig 　 Lockedboundedbuffer 图 　 加锁 有 界 队列 　 　 我们 可以 看到 在 AdaI 中子 类型 可以 最大 限度 地 继承 父 类型 中 的 操作 而 不 需要 重新 定 义父 类型 的 操作 　 消除 继承 异常现象 　 　 我们 在 第节 分析 了 出现 继承 异常现象 的 个 原因 AdaI 可以 有效 地 消除 由 这些 原因 所 引起 的 继承 异常现象 从而 提高 代码 复用 的 效率 　 　 因为 在 AdaI 中 保护 对象 操作 的 代码 被 分为 两 部分 ： condition 和 action ， 而 这 两 部分 可以 分别 进行 代码 复用 所以 由于 运行 前 检查 条件 变化 引起 的 继承 异常现象 都 可以 通过 重新 定义 操作 中 的 condition 部分 得以 解决 无需 重新 定义 操作 的 动作 部分 　 　 可纳 状态 集 的 重新 划分 和 可纳 状态 集 的 扩充 与 修改 都 是 由于 父类 方法 在 子类 中 的 运行 条件 发生变化 而 引起 的 因此 ， 如图所示 我们 在 AdaI 中 可以 消除 可纳 状态 集 的 扩充 与 修改 所 引起 的 继承 异常现象 如图所示 我们 可以 消除 可纳 状态 集 的 重新 划分 所 引起 的 继承 异常现象 对于 可纳 状态 集 的 历史 相关 引起 的 继承 异常现象 如图所示 我们 可以 将子 类型 中 操作 的 action 部分 分成 两个 步骤 第步 ， 通过 super 引用 父 类型 操作 第步 ， 对 引入 的 新 变量 进行 处理 这样 我们 可以 复用 父 类型 中 操作 的 condition 部分 代码 和 action 部分 代码 而 不必 再 将 这些 代码 在子 类型 中 重写 一遍 Fig 　 Boundedbufferforget 图 　 增加 get 的 有界 队列 Fig 　 Newboundedbuffer 图 　 新有界 队列 　 　 从 上面 的 简单 分析 和 例子 我们 可以 看出 在 AdaI 中 的 保护 类型 对象 继承 可以 消除 继承 异常现象 或者说 可以 最大 限度 地 进行 代码 复用 　 小 　 结 　 　 面向对象 并发程序 设计 语言 能够 帮助 程序员 利用 面向对象 技术 编写 并发程序 从而 获得 面向对象 技术 给 软件开发 带来 的 种种 好处 然而 ， 由于 继承 异常现象 的 存在 ， 影响 了 并发程序 设计 语言 引入 继承 特性 　 　 Ada 语言 是 支持 并发程序 设计 的 面向对象 语言 之一 但 并 不 支持 保护 对象 的 继承 我们 在 Ada 语言 的 基础 上 设计 了 AdaI 语言 它 支持 保护 对象 的 继承 并且 避免 了 继承 异常现象 的 出现 　 　 AdaI 语言 将 保护 类型 的 入口 操作 分为 运行 条件 描述 和 运行 动作 两 部分 这 两 部分 作为 入口 操作 的 两种 属性 ， 可以 在子 类型 中 加以 引用 这为 程序员 提供 了 灵活 、 易用 的 描述 手段 以 进行 面向对象 并发程序 设计 陆嘉 （ 清华大学 计算机科学 与 技术 系 　 北京 　 ） 　 温冬婵 （ 清华大学 计算机科学 与 技术 系 　 北京 　 ） 　 王鼎兴 （ 清华大学 计算机科学 与 技术 系 　 北京 　 ） 参考文献 ， MatsuokaSYonezawaAAnalysisofinheritanceanomalyinobjectorientedconcurrentlanguagesInAghaGWegnerPYonezawaAedsResearchDirectionsinConcurrentObjectOrientedProgrammingCambridgeMAMITPress ～ ， NeusiusCSynchronizingactionsInAmericaPedProceedingsoftheECOOPBerlinSpringerVerlag ～ ， MeseguerJos é SolvingtheinheritanceanomalyinconcurrentobjectorientedprogrammingInNierstraszOedProceedingsoftheECOOPBerlinSpringerVerlag ～ ， FrolundSInheritanceofsynchronizationconstraintsinconcurrentobjectorientedprogramminglanguagesInMadsenOedProceedingsoftheECOOPBerlinSpringerVerlag ～
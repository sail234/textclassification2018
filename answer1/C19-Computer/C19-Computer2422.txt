计算机 研究 与 发展 JOURNALOFCOMPUTERRESEARCHANDDEVELOPMENT 年 　 第卷 　 第期 　 Vol 　 No 　 基于 分布 对象 的 冗余 服务 模型 钱 　 方 　 邹 　 鹏 　 陈 　 渝 　 黄 　 杰摘 　 要 ： 针对 现有 的 分布 计算 模型 不能 充分 描述 冗余 服务 的 特点 ， 文中 基于 分布 对象 的 观点 ， 提出 一个 面向 冗余 服务 的 计算 模型 HORIS 它 利用 类 和 实例 的 概念 定义 了 冗余 服务 ， 并 将 状态 服务 和 无 状态 服务 区分 开来 ， 同时 还 刻画 了 分布 计算环境 中 的 请求 和 主机 的 概念 在 HORIS 的 基础 之上 ， 文中 创建 了 一个 冗余 服务 的 管理 框架 AMA ， 并 在 CORBA 平台 上 进行 了 实现 与 其它 冗余 服务 的 管理 框架 相比 ， 它 具有 接口 开放 、 适应性 强 、 能 管理 异构 服务 以及 可扩展性 强 等 优点 关键词 ： 分布 对象 ， 客户服务器 ， 分布 计算 模型 ， 冗余 服务 ， CORBA 中图法 分类号 ； TPAREDUNDANTSERVERMODELBASEDONDISTRIBUTEDOBJECTSQIANFangZOUPengCHENYuandHUNAGJieDepartmentofComputerScienceStateKeyLaboratoryforParallelismandDistributionNationalUniversityofDefenseTechnologyChangshaAbstract 　 InconsiderationofthedrawbacksofthecurrentdistributedcomputingmodelsdistributedobjecttechnologiesareadoptedinthepresentpapertoprovideacomputingmodelHORISforredundantserversRedundantserversaredefinitelydefinedthroughtheconceptsofclassandinstanceandstatefulserversaredistinguishedfromstatelessserversFurthermoretheconceptsofrequestsandhostsareabstractedfromdistributedcomputingenvironmentinthemodelBasedonHORISmanagementarchitectureAMAiscreatedforredundantserversanditsimplementationisdevelopedontheCORBAplatformComparedwithothermanagementarchitecturesofredundantserversAMApossessestheadvantagesofopennessadaptabilityheterogeneityandscalabilityKeywords 　 distributedobjectsclientserverdistributedcomputingmodelredundantserversCORBA 　 引 　 言 　 　 随着 分布 计算技术 的 发展 ， 客户服务器 计算 模式 逐渐 成为 分布 计算 的 主流 由于 单个 服务器 的 分布 计算环境 存在 着 性能 瓶颈 和 可用性 问题 ， 越来越 多 的 系统 ［ ～ ］ 采用 服务器 冗余技术 然而 ， 现有 的 计算 模型 不能 充分 描述 含有 冗余 服务 的 分布 计算环境 ： 如 文献 ［ ］ 通过 状态机 来 描述 分布 计算环境 ， 它 引入 了 复制 和 状态 一致性 ， 但 没有 采用 对象 的 观点 ； CoreLegion 对象 模型 ［ ］ 虽然 完全 采用 面向对象 技术 建模 ， 但 它 基于 Legion 系统 ， 而且 没有 引入 冗余 服务 的 概念 ； ROMANCE 模型 ［ ］ 引入 了 复制 对象 ， 但 它 只是 对 数据 进行 封装 ， 实现 的 是 被动 passive 对象 ； 在 Arjuna 系统 ［ ］ 中 对象 可以 嵌套 调用 ， 但 它 只 实现 了 有 状态 的 服务 ， 而且 没有 对 冗余 服务 进行 明确 的 定义 ； 在 文献 ［ ］ 和 文献 ［ ］ 中 分别 对 对象 组 objectgroup 和 对 等 服务 equalservice 进行 了 定义 ， 但 它们 不能 充分 涵盖 冗余 服务 的 特点 　 　 综上所述 ， 现有 的 分布 计算 模型 存在 着 以下 问题 ： 第 ， 对 冗余 服务 没有 明确 的 描述 和 定义 ； 第 ， 所 描述 的 服务器 大都 是 状态 服务器 statefulserver ［ ］ ； 第 ， 虽然 有 一些 系统 采用 了 面向对象 的 观点 ， 但 实现 的 是 被动 对象 针对 上述 问题 ， 本文 基于 分布 对象 的 观点 ， 提出 一个 面向 冗余 服务 的 分布 计算 模型 HORIS 并 在 此基础 之上 ， 在 CORBACommonObjectRequestBrokerArchitecture ［ ］ 平台 上 实现 一个 面向 冗余 服务 的 管理 框架 AMA 　 冗余 服务 模型 　 设计 思路 　 主动 对象 　 　 由于 对象 具有 封装 、 可 重用 和 继承 等 特性 ， 因此 被 许多 分布 计算 模型 所 采用 但 现有 的 对象 模型 ［ ～ ］ 大都 只 对 数据 进行 封装 ， 实现 的 是 被动 对象 ， 只能 接受 读写 请求 而 不能 访问 其它 对象 这些 系统 中 对象 的 复制 只 实现 了 数据 冗余 ， 没有 实现 计算 冗余 ， 因而 系统 的 可用性 和 性能 仍然 是 瓶颈 因此 ， 本文 采用 主动 active 对象 描述 分布 计算环境 ， 它们 不但 向 用户 提供 状态 信息 ， 还 向 用户 提供 计算 服务 　 状态 服务 和 无 状态 服务 　 　 状态 服务 将 系统 状态 封装 在 内部 实现 ， 冗余 的 服务器之间 要 对 状态 进行 一致性 维护 ［ ， ， ］ 随着 客户服务器 层 模型 的 流行 ， 越来越 多 的 中间层 服务器 只 封装 了 应用逻辑 ， 即 实现 的 是 无 状态 服务器 statelessserver ［ ］ 它们 的 状态 由 第层 的 数据 服务器 实现 （ 如图所示 ） 本文 将 服务 定义 为 有 状态 和 无 状态 两类 ： 一是 为了 符合 日益 流行 的 层 客户服务器 结构 ； 二 是因为 状态 服务 和 无 状态 服务 的 管理策略 大不相同 冗余 的 状态 服务器之间 ， 要 对 状态 进行 一致性 维护 ； 而 无 状态 服务器 则 无需 状态 一致性 维护 开销 ， 但 它们 必须 互斥 地 访问共享 的 外部 状态 ， 并且 一个 请求 只能 被 执行 一遍 图 　 客户服务器 层 模型 　 冗余 服务 　 　 现有 的 分布 计算 模型 常常 将 冗余 服务 和 对 等 服务 、 复制 replicated 服务 混淆 复制 服务 和 冗余 服务 的 区别 在于 ： 无论 服务 状态 、 接口 和 实现 代码 ， 复制 服务 都 是 完全相同 的 ； 而 冗余 服务 虽然 能够 向 用户 提供 相同 功能 的 服务 ， 但 它们 可以 有 不同 的 实现 ， 因此 可以 从 一定 程度 上 避免 软件 错误 ［ ］ 文献 ［ ］ 、 ［ ］ 将 对象 组和对 等 服务 定义 为 具有 相同 接口 的 服务 ， 然而 接口 相同 并不一定 是 冗余 服务 例如 局域网 A 中 的 名字 服务器 ， 虽然 和 局域网 B 中 的 名字 服务器 具有 相同 的 服务 接口 ， 但 它们 是 为 不同 的 目标 环境 创建 的 ， 因而 不是 冗余 服务 综上所述 ， 冗余 服务 应 具有 以下 几个 特性 ： ① 等效 性 ， 无论如何 实现 的 ， 冗余 服务 所 提供 的 功能 相同 ； ② 从属性 ， 等效 的 服务 并不一定 是 冗余 服务 ， 它们 应当 属于 同一 目标 环境 冗余 服务 的 等效 性 可以 用 服务 接口 的 一致性 来 描述 ， 但 从属性 很难 确切 地 定义 本文 利用 类 和 实例 的 概念 ， 可以 对 冗余 服务 的 这 一 难以描述 的 特性 进行 定义 　 　 在 HORIS 模型 中 ， 每个 客户 可见 的 服务 对象 是 一个 抽象类 ， 它们 有 多个 实例 同一个 服务 对象 的 多个 实例 互为 冗余 服务 ： 它们 继承 相同 的 接口 ， 因此 能 提供 相同 功能 的 服务 ； 它们 是 某 一 特定 服务 对象 的 实例 化 ， 因而 具有 从属性 如图所示 ， 服务 对象 A 和 B 分别 是 局域网 A 和 B 的 名字 服务器 ， 它们 继承 同一 名字 服务器 ， 接口 相同 且 对 客户 可见 其中 ， 服务 对象 A 有 两个 实例 A 和 A ， 它们 互为 冗余 服务 ， 对 客户 透明 服务 对象 B 的 实例 B 虽然 和 A ， A 具有 相同 的 服务 接口 ， 但 它们 是 不同 服务 对象 的 实例 ， 因此 不是 冗余 服务 图 　 名字 服务器 　 请求 　 　 本文 用 请求 来 划分 客户 和 服务器 的 概念 ： 当 一个 对象 向 其它 对象 发出请求 时 ， 它 是 客户 ； 当 它 接受 其它 对象 的 请求 时 ， 它 成为 服务器 因此 ， 分布 计算环境 中 的 客户服务器 模型 可 抽象 成 请求 和 对象 之间 的 调度 而且 ， 作为 客户 方 发送给 服务 方 的 消息 ， 请求 具有 时间 特征 现有 的 计算 模型 通常 用 发送 请求 和 接收 结果 两个 事件 来 刻画 请求 ， 然而 要 维护 冗余 服务 （ 尤其 是 状态 服务 ） 的 状态 一致性 ， 只 需 满足 agreement 和 order 两个 要求 ［ ］ ， 即 保证 各个 冗余 服务 以 相同 的 顺序 接收 请求 即可 因此 ， 本文 将 请求 在 接收 方 定义 和 排序 ， 这 简化 了 原有 的 分布 计算 模型 　 　 除此之外 ， 为了 描述 服务 的 负载 特征 ， 在 HORIS 模型 中 还 定义 了 主机 的 概念 因为 服务器 的 负载 状况 是 由 所在 主机 节点 的 负载 状况 决定 的 ， 而且 各个 主机 之间 的 通信 开销 很大 程度 上 决定 了 服务器 响应 客户 请求 的 速度 　 概 　 述 　 　 基于 上述 的 设计 思路 ， 本文 从 分布 计算环境 中 抽象 出个 概念 ： 主机 host 、 服务 对象 serverobject （ 简称 服务 、 对象 ） 、 请求 request 、 服务 对象 实例 serverobjectinstance （ 简称 对象 实例 、 实例 ） 和 状态 state ， 构造 成 HOIRS 模型 ， 用 它 来 描述 含有 冗余 服务 的 分布 计算环境 （ 如图所示 ） 它 采用 CoreLegion 对象 模型 ［ ］ 中父 类 和 子类 的 继承 关系 kindof ， 以及 类 和 实例 之间 的 实例 化 关系 isa ， 定义 对象 之间 的 关系 系统 有 唯一 的 基类 Object ， Object 有 个子 类 ： ServerObjectHost 和 Request ， 分别 对应 于 系统 中 的 服务 对象 、 主机 和 请求 其中 ， 服务 对象 有 两个 子类 ： StatefulObject 和 StatelessObject ， 分别 对应 于 系统 中 的 状态 服务 和 无 状态 服务 状态 服务 有 一个 特殊 的 子类 ： StateObject ， 它 相当于 以前 的 计算 模型 中 的 被动 对象 StatefulObjectStatelessObject 和 StateObject 都 可以 进行 实例 化 ， 同一个 子类 的 实例 互为 冗余 服务 图 　 HORIS 对象 模型 　 模型 定义 　 　 假设 系统 基于 可靠 通信 ， 每个 节点 上 每种 服务 对象 的 实例 最 多 只有 一个 而且 每个 节点 上 有 局部 时钟 ， 可以 对 请求 进行 排序 　 　 主机 ： HostOi ≤ i ≤ n 　 　 Host 为 系统 中 所有 主机 的 集合 Hi ∷ 〈 hostnamemaxloadcurrentload 〉 ， hostname 为 主机 的 唯一 标识 ， maxload 为 主机 的 负载 阈值 ， currentload 为 主机 的 当前 负载 值 　 　 服务 对象 ： ObjectOi ≤ i ≤ m 　 　 Object 为 系统 中 客户 可见 的 所有 服务 对象 的 集合 Oi ∷ 〈 objectnameattributesmethods 〉 ， objectname 是 服务 对象 的 唯一 标识 ； attributes 是 对象 的 属性 ， methods 是 对象 的 方法 ， 它们 构成 服务 对象 的 接口 　 　 服务 对象 实例 ： 　 　 INSTANCE 是 系统 中 所有 服务 对象 的 实例 的 集合 其中 ， 驻留 在 节点 Hi 上 所有 实例 的 集合 ， InstiIiik ≤ k ≤ mi ； 服务 对象 Oj 所有 实例 的 集合 ， InstjIjjk ≤ k ≤ njIji 是 驻留 在 主机 Hi 上 服务 对象 Oj 的 实例 ， Iji ∷ 〈 HiOjSharedStatePrivateState 〉 SharedState 是 同一 服务 对象 的 实例 （ 即 冗余 服务 ） 所 共享 的 状态 ， 如 服务 对象 的 属性 等 ； PrivateState 是 各个 实例 的 私有 状态 ， 如 实例 的 负载 状况 和 地址 等 　 　 状态 ： 　 　 State 是 系统 中 所有 服务 对象 状态 的 集合 ， Si 是 服务 对象 Oi 的 状态 对 无 状态 服务 而言 （ 如图 a 所示 ） ， Si 是 由 各个 实例 所 共享 的 外部 状态 对象 实现 的 ， 因此 ， Iij ∈ Insti 都 有 Si ＝ Iijsharedstate ； 对 状态 服务器 而言 ， 必须 提供 一定 的 系统 支持 （ 如 定期 更新 状态 等 ） ， 使得 服务 对象 Oi 所有 实例 Iij 的 共享 状态 SharedState 与 服务 对象 的 状态 Si 保持一致 （ 如图 b 所示 ） 图 　 无 状态 服务器 和 状态 服务器 　 　 请求 ： 　 　 REQUEST 是 系统 中 所有 请求 的 集合 ， REQj 是 所有 申请 对象 Oj 服务 的 请求 的 集合 为了 保证 各个 冗余 服务 的 状态 一致性 ， 系统对 发送给 同一 对象 的 请求 进行 全局 排序 ［ ］ ： REQjRji ≤ i ≤ qj 其中 ， i 为 请求 的 序号 ， Rji ∷ 〈 IkhOjmethodtypeinstancelist 〉 Ikh 是 发送 请求 的 客户 方 实例 ， Oj 是 请求 服务 的 对象 类型 ， method 是 请求 服务 的 方法 ， type 是 请求 的 类型 ： 同步 synch 或 异步 asynch ， instancelist 是 处理 请求 的 实例 列表 冗余 实例 可以 采用 不同 的 机制 响应 客户 的 请求 ， 如 activereplication 或 passivereplication 等 ［ ］ 　 管理 框架 AMA 及其 实现 　 管理 框架 　 　 基于 上 一节 所 定义 的 HORIS 对象 模型 ， 本文 创建 了 一个 面向 冗余 服务 的 管理 框架 AMAAdministratorManagerAgent （ 如图所示 ） 图 　 AMAAdministratorManagerAgent 系统管理 框架 　 　 AMA 管理 框架 采用 层 的 manageragent 管理 结构 ， 为 HOIRS 模型 中 的 被 管理 对象 （ 主机 、 服务 对象 、 实例 和 请求 ） 提供 了 管理 接口 它 由 Administrator ， Manager 和 Agent 部分 组成 ： 　 　 Administrator ： 是 系统 中 所有 Manager 的 管理者 ， 它 负责 收集 和 维护 全局 的 管理 信息 ； 同时 ， 面向 系统管理员 ， 提供 图形用户界面 ， 以便 系统管理员 动态 地 监视 和 控制系统 ； 　 　 Manager ： 包括 OMobjectmanager 和 HMhostmanager 两类 其中 ， OM 管理 服务 对象 的 所有 实例 ， 同时 也 是 Administrator 的 被管理者 ； HM 驻留 在 每个 主机 节点 上 ， 它 是 Administrator 的 被 管理 对象 ， 也 是 本地 Agent 的 管理者 OM 和 HM 负责 收集 和 维护 系统 局部 的 管理 信息 ， 一方面 提供 给 全局 的 Administrator ， 另一方面 根据 系统 的 负载 状况 和 失效 信息 ， 动态 调度 客户 请求 ， 管理 冗余 服务 ； 　 　 Agent ： 分为 两类 ， 一类 是 请求 代理 RArequestagent ， 它 为 请求 提供 了 管理 接口 ， 负责 发送 请求 和 处理结果 ， 例如 采用 何种 投票 机制 选择 正确 结果 ， 对 请求 进行 排序 等 ； 另一类 是 服务器 代理 SAserveragent ， 它 在 每个 对象 实现 即 实例 之上 ， 增加 了 管理 接口 ， 封装 了 系统 的 管理策略 （ 如 本地 的 负载 阀值 等 ） ， 从而 有效 地 实现 了 系统 的 自动 管理 功能 　 实 　 现 　 　 本文 采用 OMG 的 CORBA ［ ］ 作为 系统 的 实现 平台 CORBA 是 OMG 组织 关于 对象 请求 代理 ORBobjectrequestbroker 的 技术标准 ， 它 为 不同 语言 和 异构 平台 上 的 对象 提供 了 互操作 机制 本文 所 采用 的 具体 平台 是 我们 开发 的 StarBus 分布 计算环境 ， 它 遵循 CORBA 标准 除了 多线程 ORB 外 ， 它 还 为 用户 提供 了 IDL 编译器 、 名字 服务 、 事件 服务 和 永久 对象 服务 等 　 　 （ ） Administrator 作为 系统 的 管理 服务 实现 它 一方面 为 新 加入 的 对象 实现 或 主机 创建 OM 和 HM ； 另一方面 ， 接受 系统管理员 的 查询 和 控制 它 的 接口 用 IDL 语言 描述 如下 ： 　 　 　 　 　 InterfaceAdministratorStatefulObject 　 　 　 　 typedefsequence 〈 OM 〉 OMSeq ； 　 　 　 　 typedefsequence 〈 HM 〉 HMSeq ； 　 　 　 　 OMSeqOMList ； 　 　 　 系统 中 所有 OM 对象 引用 的 列表 　 　 　 　 HMSeqHMList ； 　 　 　 系统 中 所有 HM 对象 引用 的 列表 　 　 　 　 OMSeqgetOMList ； 　 　 　 　 objrefcreateOMinstringObjName ； 为 服务 对象 创建 管理者 OM ， 并 加入 到 OM 列表 中 　 　 　 　 DeleteOM ； 　 　 　 　 HMSeqgetHMList ； 　 　 　 　 objrefcreateHMinstringHostNameinfloatCurrentLoad ； 　 　 为 主机 创建 HM ， 并 加入 到 HM 列表 中 　 　 　 　 DeleteHM ； 　 　 　 　 （ ） HM 除了 维护 本地 实例 的 SA 对象 外 ， 还 封装 了 主机 的 负载 阈值 和 当前 负载 值 其中 ， 前者 是 由 Administrator 在 创建 HM 时 配置 的 ， 后者 则 随着 主机 上 所 驻留 实例 的 多少 而 动态变化 HM 的 接口 描述 如下 ： 　 　 　 　 　 　 　 InterfaceHMStatefulObject 　 　 　 　 typedefsequence 〈 SA 〉 SASeq ； 　 　 　 　 SASeqSAList ； 　 　 　 主机 上 所有 实例 的 SA 列表 　 　 　 　 floatCurrentLoad ； 　 　 　 主机 当前 负载 值 　 　 　 　 floatMaxLoad ； 　 　 　 　 　 主机 的 负载 阈值 　 　 　 　 SASeqgetSAList ； 　 　 　 　 addSAListobjrefSA ； 将 SA 的 对象 引用 加入 到 HM 的 SA 列表 中 　 　 　 　 setmaxloadinfloatMaxLoad ； 　 　 　 　 floatgetmaxload ； 　 　 　 　 setcurrentloadinfloatCurrentLoad ； 　 　 　 　 floatgetcurrentload ； 　 　 　 　 （ ） OM 负责 维护 服务 对象 实例 的 SA 列表 它 既 可以 接受 Administrator 的 调用 ， 为 对象 实现 创建 SA ； 也 可以 由 新创建 的 SA 主动 向 它 注册 它 的 接口 描述 如下 ： 　 　 　 　 　 InterfaceOMStatefulObject 　 　 　 　 typedefsequence 〈 SA 〉 SASeq ； 　 　 　 　 SASeqSAList ； 　 　 　 服务 对象 OM 所含 实例 的 SA 列表 　 　 　 　 SASeqgetSAList ； 　 　 　 　 registerSAobjrefSA ； 　 　 新创建 的 SA 向 OM 注册 　 　 　 　 objrefcreateSAinstringObjName ； 　 　 为 服务 对象 实例 创建 SA ， 并 加入 到 SA 列表 中 　 　 　 　 DeleteSA ； 　 　 　 　 （ ） 通过 增加 IDL 编译器 的 功能 ， SA 和 RA 可以 在 服务器 方 的 Skeleton 和 客户 方 的 Stub 中 自动 生成 ， 它们 也 可以 由 系统管理员 通过 Administrator 的 GUI 界面 进行 配置 SA 封装 了 对 冗余 服务 （ 即 服务 对象 实例 ） 的 具体 管理策略 ， 如 activereplication ， passivereplication 或 ROWAReadOnceWriteAll ［ ］ 等 为了 实现 系统 的 负载平衡 ， 它们 可以 通过 向 HM 查询 主机 的 当前 负载 状况 ， 决定 是否 对 请求 进行 处理 RA 一方面 根据 冗余 服务 的 负载 状况 和 通信 开销 ， 选择 适当 的 实例 发送 客户 请求 ； 另一方面 ， 它 对 各个 服务 对象 实例 所 返回 结果 进行 处理 ， 通过 acceptancetest 和 投票 机制 ［ ］ 选出 正确 结果 　 相关 工作 比较 　 　 文献 ［ ］ 通过 将 冗余 服务 的 管理者 ServiceManager 分别 驻留 在 客户 方 和 服务 方 ， 实现 对 冗余 服务 的 分散 管理 它 的 缺点 是 没有 引入 分布 对象 的 观点 ， 因而 对 异构 平台 上 的 服务 不能 进行 有效 地 管理 ； 同时 由于 采用 分散 管理 方式 ， 各个 管理者 之间 需要 协调 ， 造成 管理 冗余 服务 的 难度 和 复杂度 较大 ROMANCE ［ ］ 和 Arjuna ［ ］ 系统 通过 引入 对象 的 观点 对 异构 服务 进行 封装 ， 能够 管理系统 中 异构 的 服务 资源 ， 但 它们 只能 对 状态 服务 进行 管理 ， 而且 由于 管理系统 基于 特定 平台 ， 它们 没有 与 其它 管理系统 互操作 的 开放 接口 基于 CoreLegion 对象 模型 ， Legion ［ ］ 开发 了 基于 CORBA 平台 的 管理 框架 ， 它 实现 了 异构 的 管理 应用 之间 的 互操作 ， 但 它 采用 的 是 基于 任务 主机 的 并行计算 模型 ， 无法 对 基于 客户服务器 模型 的 冗余 服务 进行 管理 IBM 的 ComponentBroker ［ ］ 基于 CORBA 平台 实现 了 对 冗余 服务 的 工作量 （ workload ） 管理 ， 它 基于 客户服务器 模型 ， 能够 对 异构 环境 中 的 冗余 服务 进行 管理 ， 但 它 采取 分散 管理模式 ， 将 冗余 服务 的 管理者 驻留 在 客户 方 的 扩展 ORB 中 ， 而且 没有 区分 对 状态 服务 和 无 状态 服务 的 管理策略 　 　 综上所述 ， 与 其它 管理 框架 相比 ， 基于 HORIS 对象 模型 的 管理 框架 AMA 具有 以下 优点 ： ① 通过 采用 分布 对象 的 观点 ， 将 服务 资源 封装 成 主动 对象 ， AMA 可以 对 异构 环境 中 的 冗余 服务 进行 管理 ； ② 通过 采用 CORBA 标准 作为 实现 平台 ， 可以 提供 开放 接口 ， 实现 AMA 系统 与 其它 管理系统 之间 的 互操作 ； ③ AMA 管理 框架 不但 管理 冗余 的 状态 服务 ， 还 可以 采取 不同 策略 对 无 状态 的 冗余 服务 进行 管理 ， 具有 较强 的 适应性 ； ④ 它 采取 manageragent 管理模式 ， 对 冗余 服务 进行 集中管理 ， 不但 减少 了 系统 的 管理 开销 ， 还 降低 了 管理 的 复杂度 除此之外 ， 它 采取 层次结构 ， 使 管理系统 具有 较强 的 可扩展性 ； 同时 ， 通过 administrator 它 可以 为 系统管理员 提供 全局 的 管理 视图 　 结束语 　 　 针对 现有 的 分布 计算 模型 的 缺陷 ， 本文 采用 分布 对象 技术 ， 为 含有 冗余 服务 的 分布 计算环境 定义 了 一个 新 的 对象 模型 HORIS 比较 以前 的 分布 计算 模型 ， 它 具有 以下 优点 ： ① 完全 采用 了 分布 对象 技术 ， 基于 主动 对象 ； ② 利用 类 和 实例 的 概念 ， 对 冗余 服务 进行 了 明确 的 定义 ； ③ 区分 了 状态 服务 和 无 状态 服务 ； ④ 利用 请求 刻画 系统 中 的 客户 和 服务器 ， 并 按 接收 方对 请求 排序 ； ⑤ 对 服务 的 硬件 环境 — — 主机 进行 了 描述 基于 HORIS 模型 ， 可以 对 分布 计算环境 中 的 冗余 服务 进行 有效 的 管理 ， 本文 因此 实现 了 CORBA 平台 上 的 管理 框架 AMA 我们 下 一步 工作 ， 就是 在 现有 的 对象 模型 和 管理 框架 的 基础 之上 ， 深入研究 分布 计算环境 中 冗余 服务 的 容错 和 负载平衡 机制 本 课题 得到 国家 “ 八 六三 ” 重点项目 基金 资助 作者简介 ： 钱方 ， 女 ， 年生 ， 博士 研究生 ， 主要 研究 领域 为 分布 计算 和 系统管理 　 　 　 　 　 邹鹏 ， 男 ， 年生 ， 教授 ， 博士生 导师 ， 主要 研究 领域 为 操作系统 和 分布 计算 　 　 　 　 　 陈渝 ， 男 ， 年生 ， 博士 研究生 ， 主要 研究 领域 为 并行 与 分布 计算 　 　 　 　 　 黄杰 ， 男 ， 年生 ， 硕士 研究生 ， 主要 研究 领域 为 分布 计算 作者 单位 ： 钱 　 方 　 邹 　 鹏 　 陈 　 渝 　 黄 　 杰 　 国防科学技术大学 计算机科学 系 　 并行 与 分布 国家 重点 实验室 　 长沙 　 参考文献 　 LuicRodriguesPauloVerissimoTheROMANCEapproachtoreplicatedobjectmanagementInProcofthethWorkshoponFutureTrendsofDistributedComputingSystemLisboaPatugal 　 LittleMetalObjectreplicationinarjunaComputingLaboratoryUniversityofNewcastleuponTyneTechRepTR 　 SilvanoMaffiesTheobjectgroupdesignpatternCornellUniversityTechRepTR 　 JiHuaXieLiAdistributedcomputingmodelbasedonmultiserverACMTransonOperatingSystemReview ～ 　 SchneiderFBImplementingfaulttoleranceservicesusingthestatemachineapproachAtutorialACMComputerSurveys ～ 　 LewisMetalThecorelegionobjectmodelInProcofthethIEEEIntlSymposiumonHighPerformanceDistributedComputing 　 SilvanoMaffiesClientServertermdefinitionInHemmendingerDedEncyclopaediaofComputerScienceZurichInternationalThomsonComputerPublishing 　 ObjectManagementGroupTheCommonObjectRequestBrokerArchitectureandSpecificationRevision 　 SomaniAKVaidyaNHUnderstandingfaulttoleranceandreliabilityIEEEComputer ～ 　 JurgenNehmerFriedmannMatternFrameworkfortheorganizationofcooperativeservicesindistributedclientserversystemsComputerCommunication ～ 　 AndrewGrimshawetalWideareacomputingResourcesharingonalargescaleComputerMay ～ 　 OrenGampeletalWorkloadmanagementInIBMComponentBrokerConnectorOverviewJuneURLhttpwwwibmcompublicpubsbookmgrredbookssgbook 原稿 收到 日期 ： ； 修改稿 收到 日期 ：
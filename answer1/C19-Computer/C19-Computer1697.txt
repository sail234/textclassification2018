软件 学报 JOURNALOFSOFTWARE 　 Vol 　 No 　 P 面向对象 Z 的 子 类型 继承 和 推理 规则 　 王云峰 　 李必信 　 郑国梁 摘要 　 讨论 了 COOZcompleteobjectorientedZ 中 的 继承 关系 将 继承 分为 增量 继承 和子 类型化 继承 并 重点 讨论 了 子 类型化 继承 定义 了 一种 行为 子 类型化 继承 证明 了 该 方法 的 合理性 并 据此 定义 了 COOZ 的 规约 继承 及 规约 继承 的 推理 规则 所 讨论 的 子 类型化 方法 与 ECusack 等 人 的 方法 相比 具有 可 构造性 并且 比 Liskov 等 人 的 方法 具有 更大 的 灵活性 　 关键词 　 形式 方法 面向对象 继承 子 类型 形式 规约 　 中图法 分类号 　 TPOnSubtypingInheritanceandInferenceRulesinObjectOrientedZWANGYunfeng （ tateKeyLaboratoryforNovelSoftwareTechnology 　 NanjingUniversity 　 Nanjing 　 ） （ MeteorologyCollege 　 PLAUniversityofTechnology 　 NanjingUniversity 　 Nanjing 　 ） LIBixin （ tateKeyLaboratoryforNovelSoftwareTechnology 　 NanjingUniversity 　 Nanjing 　 ） ZHENGGuoliang （ tateKeyLaboratoryforNovelSoftwareTechnology 　 NanjingUniversity 　 Nanjing 　 ） Abstract 　 TheinheritancerelationofCOOZisdiscussedItisdividedintoincreasinginheritanceandsubtypinginheritanceThelatterisstudiedandabehavioralsubtypinginheritanceisdefinedbywhichthespecificationinheritanceanditsinferencerulesaredefinedThesoundnessofthemethodisprovedTheofferedmethodisconstructivecomparedwiththatofECusackandismoreflexiblethanthatofLiskovetalKeywords 　 Formalmethodobjectorientedinheritancesubtypingformalspecification 　 　 将 形式 方法 与 面向对象 方法 相结合 已 成为 软件开发 方法 研究 的 一个 重要 方向 年代 初 将 形式 规约 语言 Z 进行 面向对象 的 扩充 成为 研究 热点 先后 产生 了 若干个 Z 的 面向对象 扩充 版本 ［ ］ COOZcompleteobjectorientedZ 是 在 分析 以往 Z 的 面向对象 扩充 的 基础 上 采用 更为 先进 、 合理 的 技术 对 Z 进行 面向对象 的 扩充 对 Z 进行 面向对象 的 扩充 使得 形式 方法 和 面向对象 方法 相得益彰 如 OO 方法 中类 及其 关系 的 构造 技术 使 Z 适宜 描述 大型 和 复杂 系统 同时 Z 本身 的 数学 特性 使 我们 可以 对 规约 进行 推理 和 计算 以 保证 规约 的 正确性 　 　 继承 是 面向对象 方法 的 最 重要 的 概念 继承 一般 用于 两个 方面 ： 行为 继承 和 实现 继承 行为 继承 即 规约 继承 是 一种 强子 类型化 继承 ［ ］ 任意 一处 父类 对象 均 可 由 子类 对象 代替 实现 继承 即 增量 继承 通过 修改 已有 的 类 派生 出新 类 体现 了 复用 和 代码 共享 在 实现 子 类型化 时有 多种 方法 许多 面向对象 语言 通过 对 实现 继承 增加 约束条件 来 实现 子 类型化 约束条件 一般 通过 方法 的 型构 定义 ［ ］ 这些 约束条件 使得 在 应用 子 类型 多态 时 不致 出现 运行 错误 但 不能 保证 语义上 的 一致 　 　 我们 定义 子 类型化 的 目的 在于 ： 如果 已知 父类 的 属性 和 功能 即 父类 的 规约 当 对子 类 进行 推理 时能 直接 利用 已知 的 信息 增强 对 复杂 系统 功能 进行 推理 的 能力 其次 为了 使子 类型 对象 具有 所有 父类 的 属性 和 行为 保证 子 类型 对象 可以 代替 父类 对象 使 其 成为 一种 精化 手段 其三 保证 COOZ 规约 验证 的 模块性 ［ ］ 例如 方法 m 的 验证 是 针对 父 类型 对象 规约 的 当子 类型 对象 代替 父 类型 对象 时 对象 规约 发生 改变 此时 本 应该 针对 新 规约 重新 验证 m 但 这 意味着 对 继承 来 的 原有 代码 （ 或 规约 ） 均 要 重新 验证 这是 不必要 的 可以 定义 一种 模块化 的 验证 方法 这一 方法 的 基础 就是 规约 继承 　 　 我们 在 下面 对 COOZ 的 继承 关系 的 讨论 中 把 继承 分为 派生 和子 类型化 两种 方式 分别 给出 形式 定义 重点 讨论 具有 较大 灵活性 的 一种 子 类型化 继承 ， 并 定义 了 规约 继承 的 方法 同时 讨论 了 该 方法 的 合理性 为了 能 利用 规约 中 的 子 类型 关系 进行 推理 给出 了 基于 逻辑 的 COOZ 继承 的 推理 规则 　 COOZ 简介 　 　 COOZ ［ ］ 是 一种 面向对象 的 形式 规约 语言 其中 的 类 由类 模式 （ classschema ） 表示 　 　 类 模式 由类 名 、 类 参数 、 父类 列表 、 对象 接口 、 局部 定义 、 状态 模式 、 初始化 模式 、 方法 模式 以及 表示 对象 实时 历史 约束 的 类 不变式 等 组成 类 模式 的 详细 语法 及 语义 见 文献 ［ ］ 每个 类 模式 都 有 AnonymousStateSchema （ 无名 状态 模式 ） 描述 类 属性 和 类 不变式 即 描述 该类 对象 的 状态 空间 在 继承 时 无名 状态 模式 自动 加以 合并 　 　 类 模式 可以 有 多个 方法 模式 类 对象 可 接受 的 消息 必须 通过 其 方法 模式 加以 说明 无名 状态 模式 被 自动 引入 该类 对象 的 方法 模式 在 继承 时 根据 同名 模式 进行 合并 的 原则 同名 方法 模式 进行 合并 这里 模式 合并 的 含义 是 模式 的 合取 ［ ］ 　 COOZ 中 的 继承 ： 派生 和子 类型化 　 　 我们 把 继承 分为 增量 继承 和子 类型化 继承 两种 增量 继承 为 一般 意义 上 的 派生 继承 即 在 已有 类 的 基础 上 构造 新类 是 重用 现有 规约 的 基础 子 类型化 继承 是 一个 类 替代 另 一个 类 的 基础 可 作为 类 的 精化 机制 下面 ， 我们 将 分别 讨论 这 两种 继承 并且 为了 与 规约 精化 的 实现 语言 C 相适应 我们 引入 一种 将类 作为 类型 、 将 子类 作为 子 类型 的 子 类型化 继承 方法 　 增量 继承 — — 派生 　 　 增量 继承 是 在 现有 的 类 定义 上 增加 “ 方法 和 变量 ” 构成 新类 的 过程 增量 继承 不能 保证 派生类 的 对象 也 是 父类 的 对象 即 不能 保证 派生类 是 父类 的 子 类型 我们 简化 并 扩展 CusackE ［ ］ 关于 继承 的 定义 　 　 设类 A 的 状态 模式 为 SAXA 为 SA 的 状态 空间 Oj 为类 A 的 j 个 方法 类 B 的 状态 模式 为 SBXB 为 SB 的 状态 空间 Pj 为类 B 的 j 个 方法 若 SB 为 SA 的 实例 （ 见 文献 ［ ］ 中 的 定义 ） 则 存在 映射 f ： XB → XA 把 SB 的 实例 映射 到 SA 的 实例 根据 类 完整性 定义 Oj 可 看成 是 XA 之间 的 关系 R （ Oj ） 显然 R （ Oj ） XA × XA 同样 可得 R （ Pj ） XB × XB 相应 地 ， f 可得 映射 f × f ： XB × XB → XA × XA 若 相应 类 A 的 方法 Oj 和 Pj 在 类 中 无 显式 定义 则 有无 派生类 的 定义 如下 　 　 定义 若 B 的 状态 模式 SB 的 实例 为类 A 的 状态 模式 SA 的 实例 即 存在 映射 f ： XB → XA 若类 B 的 方法 Pj 由下式 定义 RPjf × fROj ∩ XfB × XfB ， 则 B 为 A 的 派生类 若 RPjf × f 为 空则 Pj 在 B 中 无 定义 　 　 定义 是 极为 严格 的 继承 定义 其 定义 的 子类 不能 修改 父类 的 方法 事实上 增量 继承 相当于 宏 定义 通过 把 类 模式 的 继承 语句 全部 展开 为 实际 语句 可 得到 没有 继承 关系 的 规约 　 子 类型化 继承 　 　 ECusack 定义 的 子 类型化 继承 是 一种 非 构造性 方法 并且 限制 子 类型 修改 父 类型 的 方法 SDrossoplou 等 人 提出 的 “ ST ＆ T ” 子 类型化 方法 是 一种 极弱 的 子 类型化 方法 仅能 满足 子 类型化 的 语法 约束 可以 保证 子 类型 表达式 代替 父 类型 表达式 时 类型 不 出错 但 不能 保证 子 类型 对象 行为 与 父 类型 对象 一致 事实上 类型 检查 只能 查出 程序 部分 错误 类型 正确 不能 保证 行为 正确 　 　 为了 达到 前述 子 类型化 的 个 目的 需要 定义 一种 “ 行为 子 类型化 ” 概念 既 满足 子 类型化 的 语法 约束 又 满足 子 类型化 的 语义 约束 保证 子 类型 对象 行为 与 父 类型 对象 一致 即 保证 子 类型 对象 代替 父 类型 对象 时 不会 出现 超出 父类 行为 规约 的 行为 （ 意外 行为 ） 　 　 为了 比较 子 类型 和 父 类型 我们 扩展 了 文献 ［ ］ 中 的 映射 对于 存在 子 类型 关系 的 集合 XYX ≤ Y （ 符号 ≤ 表示 子 类型 关系 ） 存在 模拟 函数 fX → YX ≤ Y 要 判断 子 类型化 继承 既 要 比较 类型 的 状态 模式 又 要 比较 类型 的 方法 模式 比较 类型 的 状态 模式 就是 比较 类型 状态 空间 中 的 不变式 我们 用 IX （ vz ） 表示 类型 X 的 不变式 其中 vX 表示 X 的 取值 　 　 为了 比较 方法 模式 我们 用 分别 表示 类型 ST 的 方法 m 的 输入 变量 类型 用 分别 表示 类型 ST 的 方法 m 的 输出 变量 类型 　 　 用 表示 S 的 方法 m 的 前置条件 用 表示 S 的 方法 m 的 后置 条件 其中 Δ X 表示 X ∩ X ′ 即 操作 前后 的 变量 下面 给出 一种 子 类型化 继承 的 定义 　 　 定义 （ 行为 子 类型化 继承 ） 类型 S 为 类型 T 的 子 类型 当且 仅 当 下列 条件 满足 ： 　 　 。 不变式 规则 ： 对 所有 S 的 值 vS 　 　 。 方法 规则 　 　 对 所有 S 的 对象 thisS 输入 变量 　 　 前置条件 规则 　 　 后置 条件 规则 需要 指出 的 是 式 中 反映 了 子 类型 关系 的 逆变 原则 （ contravariance ） 而 则 反映 了 子 类型 关系 的 协变 原则 （ convariance ） 　 强制 规约 继承 　 　 在 使用 COOZ 建立 程序 规约 时 为了 保证 在 使用 继承 时 自动 保证 子 类型 关系 我们 根据上述 子 类型 关系 的 定义 定义 一种 强制 规约 继承 的 方法 虽然 这样 限制 了 继承 的 灵活性 但 却 具有 在 文章 开始 部分 中 谈到 的 个 好处 使用 规约 继承 强制 父 类型 对象 的 方法 在子 类型 对象 中 进行 正确 的 操作 而且 如 下面 所 要 讨论 的 这 一 方法 较 其他 子 类型化 方法 更为 灵活 为 表示 方便 引入 符号 ↑ I 表示 继承 的 不变式 ↑ pre ↑ post 分别 表示 继承 的 前后 置 条件 这些 符号 的 定义 在 第节 中 给出 　 　 定义 （ 强制 规约 继承 ） 设 S 为 若干 类型 的 子 类型 则 S 的 完整 的 规约 为 ： 　 　 。 不变式 IvIsv ∧ ↑ I 　 　 。 前置条件 　 　 。 后置 条件 值得注意 的 是 后置 条件 的 定义 比 Liskov ［ ］ 等 人 所 定义 的 条件 范围 要 大 允许 子 类型 方法 在 父 类型 方法 定义域 之外 仍然 有效 　 　 例如 左边 两个 操作 模式 分别 表示 父 类型 和子 类型 的 方法 m 根据 强制 规约 继承 的 定义 完整 的 子 类型 方法 m 的 后置 条件 为 该 后置 条件 并 不 蕴含 父 类型 方法 的 后置 条件 但 在 行为 上子 类型 对象 可 代替 父 类型 对象 为了 便于 比较 下面 给出 Liskov 等 人 的 行为 子 类型化 继承 的 定义 　 　 S 为 T 的 子 类型 需要 满足 下述 条件 ： 　 　 （ ） 不变式 规则 ： 　 　 （ ） 方法 规则 　 　 　 　 前置条件 规则 　 　 　 　 后置 条件 规则 其中 s 为类 S 的 状态变量 s ′ 表示 后 状态变量 f 表示 模拟 函数 见 第节 中 的 定义 Mx 表示 类 x 中 的 方法 　 　 由此可见 ， 强制 规约 继承 的 方法 比 LiskovECusack 定义 的 行为 子 类型化 继承 的 条件 要弱 如 上例 并 不 满足 Liskov 的 条件 但 在 行为 上子 类型 对象 可 代替 父 类型 对象 因此 强制 规约 继承 的 方法 可 在 给 程序 规约 设计者 使用 继承 时 提供 更大 的 灵活性 另外 在 对 m 的 调用 进行 推理 时 当作 用于 父 类型 对象 时子 类型 对象 的 m 仍然 是 有效 的 同时 ， 子 类型 方法 的 后置 条件 蕴涵 了 父 类型 方法 的 规约 使父 类型 方法 的 规约 在子 类型 对象 中 自动 满足 为 模块化 推理 提供 了 基础 　 实 　 例 　 　 为了 说明 规约 继承 下面 给出 一个 简单 的 实例 类 模式 schemaBankAccount 表示 银行帐户 类 模式 TwoAccount 为 BankAccount 的 子 类型 它 将 BankAccoount 中 的 属性 credit 精 化成 currency 和 check 由于 TwoAccount 具有 更 多 的 信息 为了 保持 父 类型 的 规约 子 类型 应该 提供 建立 其 抽象 值 与 父 类型 相应 的 抽象 值 关系 的 模式 这种 抽象 模式 最初 是 用 模拟 函数 （ simulationfunction ） 表示 之后 扩展 为 关系 为 简单 起 见 实例 中 采用 模拟 函数 RString 为 已有 类型 分别 表示 实数 和 字符串 　 　 其中 Simulation 代表 从 TwoAccount 到 BankAccount 的 模拟 函数 根据 规约 继承 TwoAccount 的 操作 模式 Withdraw 完全 展开 的 形式 为 其中 self 表示 TwoAccount 对象 不难看出 Withdraw 反映 了 前面 定义 的 规约 继承 　 COOZ 中 继承 关系 的 推理 规则 　 　 在 COOZ 中 我们 引入 扩充 的 Z 的 逻辑 ［ ］ 建立 相关 的 推理 规则 这里 我们 先 介绍 然后 重点 讨论 COOZ 中 和 继承 相关 的 的 扩充 　 逻辑 　 　 是 一种 Gentzen 式 的 相继 式 演算 公理 和定 理由 相继 式 表示 然后 运用 推理 规则 推导 出 其余 定理 为了 表示 方便 引入 元 函数 这些 元 函数 在 本 逻辑 以外 定义 　 　 。 相继 式 　 　 相继 式 的 形式 为 ： d ｜ Ψ ├ Φ 　 　 其中 d 为 声明 表 Ψ 为 谓词 集合 称为 “ 前提 ” Φ 也 是 谓词 集合 称为 “ 结果 ” 在 d 的 环境 条件 下当 Ψ 的 所有 谓词 均 为 真时 Φ 中 至少 有 一个 谓词 为 真 此时 形式 d ｜ Ψ ├ Φ 有效 事实上 相当于 Ψ 的 谓词 合取 而 Φ 的 谓词 析取 　 　 。 推理 规则 　 　 相继 式 的 推理 规则 采用 以下 形式 ： 其中 premisses 为 规则 的 前提 由个 相继 式 组成 ； conclusion 是 单一 的 相继 式 为 规则 的 结论 ； proviso 是 规则 应用 的 环境 中 必须 为 真的 谓词 为 规则 有效 的 条件 如果 proviso 满足 且 premisses 有效 conclusion 有效 则 称 推理 规则 是 合理 的 规则 中 的 name 用于 标识 该 规则 称为 规则 名 　 规约 继承 的 推理 规则 　 　 为 讨论 方便 先 定义 几个 相关 的 元 函数 元 函数 χ 返回 子类 继承 的 父类 名 的 集合 如 S 继承 TTn 则 有 χ S ｛ TTn ｝ 元 函数 Ω 返回 类中 的 方法 名 包括 继承 的 方法 　 　 下面 以 推理 规则 的 形式 给出 ↑ I ↑ pre ↑ post 的 定义 　 　 。 继承 的 不变式 ↑ I 的 定义 其中 　 　 。 继承 的 操作 （ 方法 ） 的 定义 　 　 继承 的 前置条件 其中 　 　 继承 的 后置 条件 q 说明 m 是 T … Tk 共有 的 方法 m 不 属于 Tk … Tn 　 　 这样 定义 保证 了 S 和 Ti 的 规约 继承 的 关系 这种 定义 可 作为 操作 模式 schema 和 状态 模式 合取 ∧ 的 语义 基础 上述 揄 规则 为 COOZ 规约 中 的 继承 关系 的 揄 奠定 了 理论 基础 　 规约 继承 的 合理性 　 　 为了 讨论 上述 规约 继承 的 合理性 引入 以 最弱 前置条件 表示 程序 语义 的 精化 演算 ［ ］ 用 其中 的 Frame 表示 类中 的 方法 ： 其中 x 表示 在 操作 中 发生 改变 的 变量 P 表示 谓词 ≡ 表示 “ 定义 为 ” 　 　 COOZ 中 的 子 类型 的 方法 定义 为 其中 下标 st 分别 表示 父 类型 和子 类型 显然 上式 即 为 规约 继承 的 方法 模式 的 定义 根据上述 定义 用 x ［ prepost ］ 表示 子 类型 的 完整 的 方法 不难 证明 即 由 规约 继承 所 得到 的 子 类型 的 方法 满足 行为 子 类型 的 性质 由此 可以 看出 ， 本文 所 定义 的 规约 继承 是 合理 的 　 　 值得 指出 的 是 规约 继承 可 作为 类 精化 的 手段 相关 内容 将 另文 讨论 规约 继承 作为 一种 行为 子 类型 的 方法 能否 实现 所有 的 行为 子 类型 即该 方法 是否 完备 还 需 进一步 研究 　 结论 和 进一步 的 研究 　 　 本文 讨论 了 COOZ 中 的 继承 关系 将 继承 分为 增量 继承 和子 类型化 继承 重点 讨论 了 子 类型化 继承 我们 定义 了 一种 行为 子 类型化 继承 并 据此 定义 了 COOZ 的 规约 继承 及 规约 继承 的 推理 规则 本文 所 讨论 的 子 类型化 方法 与 ECusack 等 人 的 方法 相比 具有 可 构造性 并且 比 Liskov 等 人 的 方法 具有 更大 的 灵活性 文中 讨论 时 省略 了 “ 约束条件 ” 如何 在 继承 中 考虑 COOZ 的 “ 实时 和 历史 约束 ” 值得 研究 另外 根据 文中 的 推理 规则 给出 推理 策略 以便 在 规约 精化 和 验证 中 加以 应用 ， 这项 工作 还 需要 进一步 研究 王云峰 （ 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 ） （ 解放军理工大学 气象 学院 　 南京 　 ） 　 李必信 （ 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 ） 　 郑国梁 （ 南京大学 计算机软件 新 技术 国家 重点 实验室 　 南京 　 ） 参考文献 ， StepneySBardenRCooperDObjectOrientationinZLondonSpringerVerlag ， DharaKKLeavensGTForcingbehavioralsubtypingthroughspecificationinheritanceInKemmererRAedProceedingsoftheICSEWashingtonDCIEEEPress ～ ， DrossopolouSKarathanosSYangDanStatictypingforobjectorientedlanguageInGoldsackSJKentSJHedsFormalMethodandObjectTechnologyLondonSpringerVerlag ～ ， YuanXiaodongHuDeqiangXuHaoetalCOOZacompleteobjectorientedextensiontoZACMSoftwareEngineeringNotes ～ ， SpiveyJMTheZNotationAReferenceManualndEditionSeriesinComputerScienceLondonPrenticeHallInc ， CusackEInheritanceinobjectorientedZInAmericaPedProceedingsoftheECOOPVolumeofLectureNotesinComputerScienceNewYorkSpringerVerlag ～ ， LiskovBWingJMAbehavioralnotationofsubtypingACMTransactionsonProgrammingLanguagesandSystems ～ ， SmithGExtendingofobjectZInBowenJPHincheyMGedZUMtheZformalspecificationnotationProceedingsofthethAnnualZUserMeetingVolumeofLectureNotesinComputerScienceLondonSpringerVerlag ～ ， MorganCCGardinerPHBDatarefinementbycalculationActaInformation ～
计算机 应用 研究 APPLICATIONRESEARCHOFCOMPUTERS 　 Vol 　 No 　 P 位 操作系统 下 的 混合 编程 朱国强 　 刘勇 　 洪嘉振 摘要 通过 研究 混合 语言 编程 的 接口 规范 ， 从 以下 三个 方面 ： 变量 和 过程 的 命名 约定 ； 堆栈 的 调用 约定 ； 不同 语言 生成 的 子程序 之间 参数传递 的 约定 ， 讨论 了 在位 视窗 操作系统 下 混合 编程 的 实现 方法 ， 并 通过 若干 实例 演示 了 其 实际 应用 。 关键词 混合 编程 调用 约定 命名 约定 参数传递 约定 　 　 混合 语言 编程 是 指 源程序 使用 两种 或 两种 以上 计算机 编程语言 来 生成 应用程序 的 过程 。 尽管 混合 语言 编程 会 给 编程 者 带来 一些 额外 的 挑战 ， 但 它 的 价值 在于 ： 它 使 你 能够 调用 现有 的 用 其它 语言 编程 的 代码 ； 它 使 你 能够 使用 单一 语言 难以实现 的 过程 ； 它 使 你 能够 在 执行 速度 、 效率 上 得到 提高 。 　 　 混合 语言 编程 必须 了解 以下 规则 ： 变量 和 过程 的 命名 约定 ； 堆栈 的 调用 约定 ； 不同 语言 生成 的 子程序 之间 参数传递 的 约定 。 这三大 约定 组合 在 一起 ， 统称 为 混合 编程 的 接口 规范 。 调整 调用 约定 　 　 调用 约定 决定 了 程序 怎样 调用 子程序 和 参数 在 哪里 进行 传递 。 在 混合 语言 的 程序 中 ， 你 不能 使 所有 模块 共享 相同 的 子程序 声明 ， 你 必须 考虑 采用 什么样 的 调用 约定 。 假如 你 在 混合 编程 中 使用 不 一致 的 调用 规则 ， 在 程序 的 连接 编译 中 并 不会 出错 ， 只有 在 程序运行 时 执行 到 呼叫 调用 这 一步 时才 会 出错 。 这种 错误 往往 是 致命 的 ， 会 导致 程序 非法 退出 甚至 系统 中止 ， 直接 原因 是 由于 调用 错误 导致 的 内存 堆栈 出错 。 因此 ， 混合 编程 必须 使用 一致 的 调用 约定 。 在 Windows 操作系统 环境 中 ， 高级 语言 编程 常用 的 调用 约定 有 ： FortranPowerStation 默认 调用 约定 以下 简称 For ； CC 默认 调用 约定 ； Basic 默认 调用 约定 ； Pascal 默认 调用 约定 ； Stdcall 调用 约定 微软 的 WindowsAPI 使用 的 调用 约定 。 各 约定 的 具体 细节 如下 ： 变量 ForCCVBDELPHIStdCall 标量 默认 地址 值 地址 值值 标量 传值 值值 值值值 标量 指针 地址 地址 地址 地址 地址 字符串 地址 长度 第一个 字符 地址 第一个 字符 第一个 字符 字符串 指针 地址 长度 地址 地址 地址 数组 地址 地址 地址 地址 地址 数组 指针 地址 地址 地址 地址 地址 过程 名称 后缀 nNoneNone 大小写 大写 小写 　 小写 堆栈 的 销毁 被 调用 模块 被 调用 模块 被 调用 模块 被 调用 模块 被 调用 模块 　 　 表格 中 ， 术语 的 含义 如下 ： 　 　 标量 ： 指 整型 、 长 整型 、 浮点 型 、 双 精度 型 等 数据类型 。 　 　 标量 默认 ： 采用 编程语言 默认 方式 传递 标量 。 如 ： CC 源代码 ： voidtestintVAR ， floatVAR 　 　 标量 传值 ： 采用 编程语言 显式 以 传值 方式 传递 标量 。 如 ： CC 源代码 ： voidtestintVAR ， floatVAR 　 　 标量 传 地址 ： CC 源代码 ： voidtestintVAR ， floatampVAR 　 　 值 ： 变量 按照 它 的 值 压入 堆栈 ， 以个 字节 为 分界线 。 　 　 地址 ： 由个 字节 组成 的 地址 值压入 堆栈 。 　 　 第一个 字符 ： 对于 字符串 而言 ， 将 第一个 字符 按 ASCII 码 转换成 字节 整数 压入 堆栈 。 　 　 n ： 参数表 的 字节数 十进制 。 调整 命名 约定 　 　 命名 约定 决定 了 高级 语言 在 标识 名称 外部 变量名 、 过程 名 放置 于 OBJ 文件 中时作 什么样 的 改变 。 对于 程序 后 紧跟 的 参数 列表 中 的 参数 名称 则 不受 影响 。 命名 约定 与 调用 约定 关系 十分 密切 ， 因为 编译器 在 确定 调用 约定 的 同时 也 确定 了 命名 约定 。 但是 ， 值得注意 的 是 ， CC 在 它 的 符号表 中是 大小写 敏感 的 ， 而 其它 语言 的 符号表 则 不然 ， 这 也许 会 带来 一些 额外 的 麻烦 ， 但是 你 可以 使用 Alias 属性 解决 命名 上 的 冲突 。 　 　 下面 这 张表 总结 了 Fortran 、 CC 、 VB 、 DELPHI 使用 的 命名 约定 。 命名 规则 　 ForCCVBDelphiStdCall 后缀 nNoneNone 大小写 大写 大小写 　 小写 　 　 例如 ， 假设 VC 中 的 有 一段 函数 声明 如下 ： 　 　 externintstdcallSumUpintaintbintc 　 　 每个 整型 占个 字节 ， 因此 OBJ 文件 中 的 标识 名 如下 ： SumUp 确定 参数传递 方式 　 　 对于 FortranPowerStation 、 CC 、 DELPHI 而言 ， 调用 例程 传给 被 调用 例程 的 参数 按 传递 方式 分为 两种 ： 传值 与 传 地址 。 传值 是 指 被 调用 例程 另外 开辟 参数 内存空间 ， 在 程序运行 期间 调用 例程 将 实际 参数 的 值 压入 堆栈 传给 被 调用 例程 ， 被 调用 例程 内 参数值 的 改变 不会 影响 调用 例程 中 对应 参数值 的 变化 。 传 地址 是 指 在 程序运行 期间 调用 例程 将 实际 参数 的 地址 个 字节 压入 堆栈 传给 被 调用 例程 ， 被 调用 例程 与 调用 例程 共享 参数 所 占 内存 ， 因此 被 调用 例程 中 参数 的 变化 直接 影响 调用 例程 中 对应 参数 的 值 。 由于 Windows 是 位 操作系统 ， 所有 地址 均 是 字节 长度 ， 可 直接 寻址 范围 达 G ， 因此 ， 不再 需要 原 DOS 、 Windowsx 操作系统 下 的 near ， far 指针 。 　 　 采用 传值 方式 时 ， 调用 例程 与 被 调用 例程 的 参数 列表 中 的 对应 参数 必须 兼容 。 由于 每种 语言 的 侧重点 不同 ， 它们 的 数据类型 不 完全 兼容 。 FortranPowerStation 、 CC 、 DELPHI 、 VB 相对 应 的 常用 数据类型 对应 关系 如下 表 所示 ： 　 ForCCVBDELPHI 整型 字节 INTEGERshortIntegersmallint 长 整型 字节 INTEGERint ， longLonginteger 浮点 型 字节 REALfloatsinglesingle 双 精度 字节 REALdoubleDoubledouble 数组 DIMENSIONmnmmTonarraymnof 定长 字符串 CHARACTERLENnCharvarnStringn 无变长 字符串 CHARACTERCharvarStringString 实际 示例 　 　 为了 充分利用 Windows 操作系统 在 多任务处理 方面 的 增强 特性 ， 我们 采用 的 方法 是 将 某 一 语言 的 源程序 被 调用 程序 编译成 动态 连接 库 DLL ， 而 将 另 一 语言 的 源程序 调用 程序 编译成 可执行程序 。 鉴于 工程界 对 Fortran 程序 可视化 的 要求 最高 ， 因此 我们 采用 将 Fortran 源代码 作为 被 调用 程序 ， 而 将 面向对象 的 其它 高级 语言 作为 调用 程序 的 办法 。 VB 调用 FORTRAN 　 　 VisualBasic 从 小巧玲珑 的 编程 工具 发展 ， 经过 微软 的 不断完善 ， 成为 强大 的 开发工具 。 VBA 成为 OFFICE 系列 软件 的 编程 工具 ， 而 VBScript 则 成为 Windows 的 主要 脚本语言 ， 就 充分说明 了 微软 对 VisualBasic 的 重视 。 工程界 经常 使用 VB 作为 可视化 界面 的 开发工具 ， 相对 其它 语言 而言 ， VB 的 数据类型 较 少 ， 但 这 并 不 妨碍 用 它 来 编写 主 调用 程序 的 功能 。 　 　 在 MSFORTRANPOWERSTATION 集成 开发 环境 下 新建 一个 动态 连接 库 项目 ， 名称 为 FORDLL ， 内 包含 三个 子程序 ， 源程序 声明 部分 如下 ： SUBROUTINEFORDLLAMNMSIFNOTDEFINEDLINKDIRECTMSATTRIBUTESDLLEXPORTFORDLLAMSATTRIBUTESVALUEMMSENDIFINTEGERMNRETURNENDSUBROUTINEFORDLLBSTRmsifnotdefinedLINKDIRECTmsattributesdllexportFORDLLBmsendifCHARACTERSTRRETURNendREALFUNCTIONFORDLLCARRAYXMSIFNOTDEFINEDLINKDIRECTMSATTRIBUTESDLLEXPORTFORDLLCMSENDIFREALDIMENSIONARRAYXFORDLLCARRAYXARRAYXARRAYXARRAYXRETURNEND 　 　 源程序 说明 ： 　 　 MSATTRIBUTESDLLEXPORTFORDLLA 　 　 这 说明 DLL 采用 For 调用 约定 ， 同时 也 确定 了 采用 For 命名 约定 。 根据 前述 命名 约定 ， 在 DLL 中 FORDLLA 子程序 的 标识 名为 “ FORDLLA ” ， 名称 字符 全部 大写 ， 后缀 表示 参数表 长度 为个 字节 ， 其中 含 一个 位 的 地址 值 和 一个 字节 长 的 整型 。 DLL 中 的 第二个 子程序 的 标识 名为 “ FORDLLB ” ， 这 是因为 For 调用 约定 规定 字符串 参数传递 时 除了 位 地址 以外 ， 还要 传 一个 字节 的 字符串 长度 信息 。 　 　 MSATTRIBUTESVALUEM 子程序 参数 M 采用 传值 方式 ， For 调用 约定 默认 是 标量 采用 传 地址 方式 。 　 　 CHARACTERSTR 　 　 由于 FORTRAN 中变长 字符串 不能 出现 在 参数表 中 ， 因此 使用 一个 定 长 字符串 代替 。 编译 后 生成 的 动态 连接 库 FORDLLDLL 中 包含 了 三个 子程序 。 子程序 名称 分别 是 FORDLLA ， FORDLLB ， FORDLLC 。 调用 程序 采用 VB 语言 ， 在 MSVisualBasic 中 输入 源程序 如下 。 　 　 VB 部分 源程序 中 ， 为了 能 调用 Fortran 的 子 例程 ， 必须 在 模块 部分 对 动态 库中 子程序 进行 声明 ： PrivateDeclareSubcallforALibquotfordllquotAliasquotFORDLLAquotByValaAsIntegerbAsIntegerPrivateDeclareSubcallforBLibquotfordllquotAliasquotFORDLLBquotByValstrAsStringcAsLongPrivateDeclareFunctioncallforCLibquotfordllquotAliasquotFORDLLCquotxAsSingleAsSingle 　 　 然后 就 可以 在 程序 中 进行 如下 调用 了 。 DimMAsIntegerNAsIntegerValueAsIntegerDimstrAs 　 StringDimarrayXToToAsSinglecallforAMNcallforBstrcValuecallforCarrayX 　 　 对于 每个 要 调用 的 其它 语言 的 例程 ， 在 VB 中 都 需 使用 Declare 语句 进行 声明 ， 后面 紧跟 的 是 VB 程序 中 所 使用 的 例程 名 。 Lib 表明 了 例程 所在 动态 连接 库 的 名称 和 位置 。 若 省略 路径 ， 则 按 下述 路径 进行 寻找 ： 当前目录 ， 系统目录 一般 为 CWindowssystem ， PATH 所定 的 目录 。 Alias 表明 了 被 调用 例程 在 OBJ 目标 文件 中 的 例程 名 ， 这个 名称 由 被 调用 例程 所 使用 的 调用 规则 确定 。 　 　 在 参数表 中 ， 对于 标量 参数 的 传递 ， 若 被 调用 例程 中 使用 按值 传递 ， VB 中要 使用 ByVal 进行 说明 ； 若 被 调用 例程 中 使用 按 地址 传递 ， VB 中要 使用 ByRef 进行 说明 或 采用 默认 方式 。 对于 字符串 参数 ， VB 中 使用 ByValstrAsString 语法 将 字符串 地址 压入 调用 堆栈 ， 由于 FORTRAN 的 字符串 参数 还 需 获得 字节 的 字符串 长度 信息 ， 因此 VB 调用 例程 的 参数表 中 还 应 传递 一个 字节 长 整型 的 长度 值 。 对于 数组 参数 ， 如果 是 传递 数组 中 的 单个 元素 ， 方法 与 传递 同 类型 的 变量 相同 。 有时 需要 将 整个 数组 传递 到 DLL 过程 中 。 如果 DLL 过程 是 专门 为 自动化 编写 的 ， 那么 将 数组 传递 到 DLL 过程 的 方式 与 传递 到 VisualBasic 过程 是 相同 的 ： 加上 空 的 括号 。 如果 DLL 过程 不能 直接 接收 自动化 数组 ， 数值 数组 仍 可以 整个 进行 传递 ； 以 引用 方式 传递 数组 的 第一个 单元 。 因为 数值 数组 数据 总是 按 顺序 放在 内存 中 ， 因此 这种 办法 是 可行 的 。 只 需要 将 数组 的 第一个 元素 传递 到 DLL 过程 ， 该 DLL 就 能够 访问 数组 的 所有 单元 。 VC 调用 FORTRAN 　 　 上面 例子 展示 了 这样 一种 技术 ， FORTRAN 被 调用 例程 使用 FORTRAN 调用 约定 ， VB 调用 例程 也 使用 FORTRAN 调用 约定 。 然而 ， 调用 例程 与 被 调用 例程 也 可 都 采用 调用 例程 的 调用 约定 。 下面 这个 例子 展示 了 这样 一个 技术 。 FORTRAN 源程序 声明 和 VB 调用 FORTRAN 例子 中 的 相应 部分 大体 相同 ， 如下 ： SUBROUTINEFORDLLAMNMSIFNOTDEFINEDLINKDIRECTMSATTRIBUTESCDLLEXPORTFORDLLA 　 INTEGERMNMSATTRIBUTESVALUEMMSATTRIBUTESREFERENCENMSENDIFSUBROUTINEFORDLLBSTRMSIFNOTDEFINEDLINKDIRECTMSATTRIBUTESCDLLEXPORTFORDLLBCHARACTERSTRMSATTRIBUTESREFERENCESTRMSENDIFstrlenSTRlenSTRcharREALFUNCTIONFORDLLCARRAYXMSIFNOTDEFINEDLINKDIRECTMSATTRIBUTESCDLLEXPORTFORDLLCMSENDIFREALDIMENSIONARRAYX 　 　 程序 说明 ： 　 　 MSATTRIBUTESCDLLEXPORTFORDLLA 　 　 表明 采用 C 调用 约定 来 代替 默认 调用 约定 。 　 　 MSATTRIBUTESREFERENCESTR 　 　 字符串 STR 采用 传 地址 方式 传递 。 这样 ， 被 调用 例程 对 字符串 参数 的 修改 就 会 影响 调用 例程 中 相应 的 字符串 。 字符串 STR 也 可 采用 传值 方式 传递 ， 但 被 调用 例程 对 字符串 参数 的 修改 不会 影响 调用 例程 中 相应 的 字符串 。 　 　 STRLENSTRLENSTRCHAR 　 　 CC 中 的 字符串 是 以 “ n ” 结尾 ， 因此 FORTRAN 中 字符串 的 最后 一个 字符 也 填 NULL 。 VC 源程序 的 声明 部分 如下 ： externquotCquot 　 voidfordllaintvarintvar 　 voidfordllbcharstrintarg 　 floatfordllcfloata 　 　 VC 调用 其它 语言 例程 要用 externquotCquot 语句 进行 声明 。 externquotCquot 语句 应 放在 所有 对 该 例程 的 调用 之前 。 由于 本例 中 被 调用 例程 采用 了 C 调用 约定 ， externquotCquot 语句 中 的 例程 名 全部 小写 。 在 参数表 中 ， CC 的 标量 数据 默认 是 按值 传递 ， 若 按 地址 传递 ， 则 应当 传递 参数 的 指针 ， 若 要 传递 整个 数组 ， 只 需 将 数组 第一个 元素 的 地址 传给 被 调用 例程 即可 ， 对于 字符串 参数 ， CC 调用 例程 需要 传递 两个 参数 ： 字符串 指针 个 字节 和 字符串 长度 。 由于 每种 语言 对 数组 在 内存 中 的 分配 不同 ， 对于 多维 数组 ， 有 按列 排列 和 按行 排列 两种 。 FORTRAN 与 VB 缺省 采用 按列 排列 ； DELPHI 与 VC 缺省 采用 按行 排列 。 例如 ： 对于 数组 X ， ， FORTRAN 数组 在 内存 中 的 前个 元素 为 ： X ， ， X ， ， X ， ， X ， ， VC 数组 在 内存 中 的 前个 元素 为 ： X ， l ， X ， ， Xl ， ， X ， 。 　 　 以下 是 VC 中 调用 的 实现 部分 。 intmnunsignedintcfloatacharbfordllamncmStrGetLengthfordllbbcmrtnSumfordllcampaDELPHI 调用 FORTRAN 　 　 与 微软 的 编程 工具 相比 ， BORLANDDELPHI 具有 以下 令人 欣赏 的 特性 ： 基于 窗体 和 面向对象 的 方法 ， 高速 的 编译器 ， 强大 的 数据库 支持 ， 与 Windows 编程 的 紧密结合 ， 及其 组件 技术 ， 新 版本 又 增加 了 DLL 调试 功能 ， 它 正 受到 愈来愈多 的 程序员 的 欢迎 。 如同 VB 、 VC 一样 ， DELPHI 也 支持 标准 的 WindowsDLL 的 调用 。 但 由于 DELPHI 与 FORTRANPOWERSTATION 出自 不同 的 两个 公司 的 产品 ， 它们 之间 混合 编程 采用 的 调用 约定 无法 和 前面 一样 直接 统一 。 不过 ， 由于 FORTRANPOWERSTATION 提供 了 生成 stdcallWindowAPI 接口 调用 约定 例程 的 功能 ， 而 DELPHI 的 外部 例程 声明 语句 也 提供 了 符合 stdcall 调用 约定 的 外部 例程 调用 的 功能 ， 因此 我们 可以 让 调用 例程 和 被 调用 例程 都 使用 stdcall 调用 约定 。 其 具体做法 见 以下 示例 。 FORTRAN 源程序 如下 ： SUBROUTINEFORDLLAMNMSIFNOTDEFINEDLINKDIRECTMSATTRIBUTESSTDCALLDLLEXPORTFORDLLAINTEGERMNMSATTRIBUTESVALUEMMSATTRIBUTESREFERENCENMSENDIFSUBROUTINEFORDLLBSTRMSIFNOTDEFINEDLINKDIRECTMSATTRIBUTESSTDCALLDLLEXPORTFORDLLBCHARACTERSTRMSATTRIBUTESREFERENCESTRMSENDIFREALFUNCTIONFORDLLCARRAYXMSIFNOTDEFINEDLINKDIRECTMSATTRIBUTESSTDCALLDLLEXPORTFORDLLCMSENDIF 　 　 程序 说明 ： 　 　 MSATTRIBUTESSTDCALLDLLEXPORTFORDLLA 表明 采用 stdcall 调用 约定 来 代替 默认 调用 约定 。 　 　 MSATTRIBUTESREFERENCESTR 字符串 STR 采用 传 地址 方式 传递 。 这样 ， 被 调用 例程 对 字符串 参数 的 修改 就 会 影响 调用 例程 中 相应 的 字符串 。 字符串 STR 也 可 采用 传值 方式 传递 ， 但 被 调用 例程 对 字符串 参数 的 修改 不会 影响 调用 例程 中 相应 的 字符串 。 DELPHI 源程序 的 声明 部分 如下 ： procedurecallforAxintegervaryinteger 　 stdcallexternalfordlldllnamefordllaprocedurecallforBSstring 　 stdcallexternalfordlldllnamefordllbfunctioncallforCvarasinglesingle 　 stdcallexternalfordlldllnamefordllc 　 　 DELPHI 源程序 的 调用 部分 如下 ： procedureTFormcmdCallDllsClickSenderTObjectvar 　 mninteger 　 sumsingle 　 arrayXarraylofsingle 　 strstringbegin 　 mstrtointeditltext 　 nstrtointedittext 　 strtrimedittext 　 setlengthstrl 　 arrayX 　 arrayX 　 arrayX 　 arrayX 　 callforAmn 　 callforBStrl 　 sumcallforCarrayX 　 labelCaptionIntToStrm 　 labelCaptionIntToStrn 　 labelCaptionstr 　 memoLinesAppendSumFloatToStrsumend 　 　 程序 说明 ： 　 　 DELPHI 使用 external 语句 来 声明 对外部 例程 的 调用 　 　 其 语法 如下 ： externalDLL 名称 name 被 调用 例程 在 DLL 内 的 名称 　 　 在 本例 中 ， fordlldll 即为 DLL 名称 ， 省略 路径 ， 则 按 下述 路径 进行 寻找 ： 当前目录 ， 系统目录 一般 为 CWindowssystem ， PATH 所定 的 目录 。 fordlla 是 被 调用 例程 在 DLL 内 的 名称 ， 大小写 依 按 前面 所述 stdcall 调用 约定 。 参数表 中 ， 在 DELPHI 中 标量 数据 默认 是 按值 传递 ， 若 按 地址 传递 ， 则 应当 在 参数 说明 前加 var 关键字 。 对于 传递 整个 数组 参数 的 情况 ， 只 需 将 数组 第一个 元素 的 地址 传给 被 调用 例程 即可 ， 在 参数表 的 声明 中加 var 关键字 。 对于 数组 元素 在 内存 中 的 排列 次序 ， 见 前节 VC 调用 FORTRAN 。 　 　 setlengthstrl 　 　 当 参数 是 字符串 时 ， 由于 DELPHI 不 允许 字符串 长度 越界 ， 所以 在 传递 字符串 参数 前 必须 用 setlength 语句 分配内存 ， 而且 ， 设定 长度 要 大于 FORTRAN 被 调用 例程 中 对应 定 长 字符串 长度 的 长度 ， 否则 程序运行 时会 出现 地址 越界 错误 。 其它 　 　 对于 Windows 编程 工具 VB 、 VC 、 DELPHI 而言 ， 它们 之间 相互 调用 一般 不再 采用 上述 方法 ， 而是 采用 面向对象 方法 封装 的 ActiveX 控件 技术 。 这 已 超出 本文 讨论 范围 ， 有 兴趣 者 可以 参考 有关 书籍 。 朱国强 上海交通大学 上海 刘勇 上海交通大学 上海 洪嘉振 上海交通大学 上海 参考文献 ， MSPOWERSTATIONProgrammersGuide 联机帮助 ， MSVisualCProgrammersGuide 联机帮助 ， DelphiHelp 联机帮助 ， ObjectPascalReference 联机帮助 ， MasteringDelphi 北京 电子 工业 出版社 ISBN ， MasteringVisualBasic 北京 电子 工业 出版社 ISBN ， 计算机 常用 语言 混合 编程 南京 南京大学 出版社 ISBN 收稿 日期 ：